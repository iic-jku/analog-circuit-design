[
  {
    "objectID": "sizing/sizing_current_mirror.html",
    "href": "sizing/sizing_current_mirror.html",
    "title": "Sizing for Improved Current Mirror",
    "section": "",
    "text": "Copyright 2024 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given values\nid_spec = 20e-6\ngm_id_spec = 5\nL_spec = 5\n\n\n# we can calculate the gm directly\ngm = gm_id_spec * id_spec\nprint('gm =', round(gm/1e-3, 3), 'mS')\n\ngm = 0.1 mS\n\n\n\nvgs = lv_nmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=0.75, VSB=0.0)\nvgs = lv_nmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0.0)\n\n\n# the gm_gds we look up and calculate gds from it\ngm_gds = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0)\ngds = gm / gm_gds\nprint('gds =', round(gds/1e-6, 3), 'uS')\n\ngds = 2.264 uS\n\n\n\n# find f_T (which is not stored directly, but we can find the gm to gate capacitance ratio)\ngm_cgg = lv_nmos.lookup('GM_CGG', GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0)\nf_T = gm_cgg / (2*np.pi)\nprint('Cgg =', round(gm/gm_cgg/1e-15, 1), 'fF')\nprint('f_T =', round(f_T/1e6, 2), 'MHz')\n\nCgg = 153.3 fF\nf_T = 103.82 MHz\n\n\n\n# find the W of the diode transistor\nid_w = lv_nmos.lookup('ID_W', GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0)\nw = id_spec / id_w\nprint('W =', round(w, 2), 'um, rounded W =', round(w*2)/2, 'um')\n\nW = 3.68 um, rounded W = 3.5 um\n\n\n\n# let's now find the other interesting values\nsth = lv_nmos.lookup('STH_GM', VGS=vgs, L=L_spec, VDS=vgs, VSB=0)*gm\nsfl = lv_nmos.lookup('SFL_GM', VGS=vgs, L=L_spec, VDS=vgs, VSB=0)*gm\n\ngamma = sth/(4*1.38e-23*300*gm)\n\nf_co = sfl/sth\nprint('V_GS =', round(float(vgs), 3), 'V')\nprint('gamma =', round(gamma, 2))\nprint('f_co =', round(f_co/1e6, 2), 'MHz')\n\nV_GS = 0.593 V\ngamma = 0.8\nf_co = 0.13 MHz"
  },
  {
    "objectID": "sizing/techsweep_sg13_txt_to_mat.html",
    "href": "sizing/techsweep_sg13_txt_to_mat.html",
    "title": "Conversion of TXT to MAT for gm/ID result files for SG13G2",
    "section": "",
    "text": "(c) 2024 Boris Murmann and Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\nimport pandas as pd\nimport numpy as np\nfrom numpy.core.records import fromarrays\nfrom scipy.io import savemat\n\n\nchoice = 0  #start from 0\ndevices = ['sg13_lv_nmos', 'sg13_lv_pmos']\n\n# widths used for characterization and fringe cap parameters (fringe caps are not included in ngspice output)\nw = np.array([5, 5])\nnfing = np.array([1, 1])\n\n\ndf_raw = pd.read_csv('techsweep_'+devices[choice]+'.txt', sep=r'\\s+')\npar_names = df_raw.columns.to_list()\npar_prefix = par_names[1].split('[')[0]\n\n\n# remove extra headers in file body and unwanted columns\ndf = df_raw.drop(['frequency', 'frequency.1'], axis=1)\ndf = df.apply(pd.to_numeric)\n\n# rename columns for readability\ndf.columns = df.columns.str.removeprefix(par_prefix+'[')\ndf.columns = df.columns.str.replace(par_prefix[1:], '')\ndf.columns = df.columns.str.removesuffix(']')\n\n# round sweep vectors to easily addressable values\ndf['l'] = df['l'].apply(lambda x: round(x*1e6, 3))\ndf['vgs'] = df['vgs'].apply(lambda x: round(x, 3))\ndf['vds'] = df['vds'].apply(lambda x: round(x, 3))\ndf['vsb'] = df['vsb'].apply(lambda x: round(x, 3))\ndf\n\n\n\n\n\n\n\n\ncdd\ncgb\ncgd\ncgdol\ncgg\ncgs\ncgsol\ncjd\ncjs\ncss\n...\nids\nl\nrg\nsfl\nsid\nvds\nvdss\nvgs\nvsb\nvth\n\n\n\n\n0\n6.818000e-21\n4.501000e-16\n1.732000e-19\n3.025000e-15\n4.504000e-16\n1.732000e-19\n3.025000e-15\n1.998000e-15\n1.998000e-15\n6.818000e-21\n...\n0.000000e+00\n0.13\n20.0400\n0.000000e+00\n2.834000e-29\n0.000\n0.1245\n0.0\n0.0\n0.4360\n\n\n1\n1.367000e-21\n3.647000e-16\n6.294000e-20\n3.025000e-15\n3.648000e-16\n6.294000e-20\n3.025000e-15\n1.727000e-15\n1.727000e-15\n1.367000e-21\n...\n0.000000e+00\n0.13\n20.0400\n0.000000e+00\n5.621000e-30\n0.000\n0.1245\n-0.0\n0.4\n0.4746\n\n\n2\n3.731000e-22\n3.156000e-16\n3.074000e-20\n3.025000e-15\n3.157000e-16\n3.074000e-20\n3.025000e-15\n1.565000e-15\n1.565000e-15\n3.731000e-22\n...\n0.000000e+00\n0.13\n20.0400\n0.000000e+00\n1.519000e-30\n0.000\n0.1245\n-0.0\n0.8\n0.5078\n\n\n3\n1.222000e-22\n2.827000e-16\n1.767000e-20\n3.025000e-15\n2.827000e-16\n1.767000e-20\n3.025000e-15\n1.453000e-15\n1.453000e-15\n1.222000e-22\n...\n0.000000e+00\n0.13\n20.0400\n0.000000e+00\n4.927000e-31\n0.000\n0.1245\n-0.0\n1.2\n0.5375\n\n\n4\n2.974000e-21\n4.501000e-16\n-2.534000e-19\n3.018000e-15\n4.504000e-16\n5.849000e-19\n3.025000e-15\n1.975000e-15\n1.998000e-15\n6.916000e-21\n...\n2.946000e-11\n0.13\n20.0400\n1.046000e-28\n2.090000e-29\n0.025\n0.1245\n0.0\n0.0\n0.4360\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n119067\n8.308000e-16\n1.355000e-14\n1.016000e-15\n3.032000e-15\n4.518000e-13\n4.372000e-13\n3.235000e-15\n1.211000e-15\n1.453000e-15\n2.724000e-13\n...\n1.135000e-04\n10.00\n0.2605\n2.918000e-19\n2.417000e-24\n1.475\n0.9454\n1.5\n1.2\n0.2935\n\n\n119068\n1.033000e-15\n1.514000e-14\n1.240000e-15\n3.025000e-15\n4.575000e-13\n4.411000e-13\n3.235000e-15\n1.387000e-15\n1.998000e-15\n2.808000e-13\n...\n1.360000e-04\n10.00\n0.2605\n3.562000e-19\n2.708000e-24\n1.500\n1.0030\n1.5\n0.0\n0.1808\n\n\n119069\n9.320000e-16\n1.471000e-14\n1.128000e-15\n3.025000e-15\n4.552000e-13\n4.394000e-13\n3.235000e-15\n1.316000e-15\n1.727000e-15\n2.771000e-13\n...\n1.274000e-04\n10.00\n0.2605\n3.321000e-19\n2.595000e-24\n1.500\n0.9838\n1.5\n0.4\n0.2238\n\n\n119070\n8.504000e-16\n1.413000e-14\n1.035000e-15\n3.025000e-15\n4.533000e-13\n4.382000e-13\n3.235000e-15\n1.257000e-15\n1.565000e-15\n2.744000e-13\n...\n1.200000e-04\n10.00\n0.2605\n3.109000e-19\n2.501000e-24\n1.500\n0.9644\n1.5\n0.8\n0.2607\n\n\n119071\n7.841000e-16\n1.356000e-14\n9.578000e-16\n3.025000e-15\n4.517000e-13\n4.372000e-13\n3.235000e-15\n1.208000e-15\n1.453000e-15\n2.724000e-13\n...\n1.135000e-04\n10.00\n0.2605\n2.920000e-19\n2.418000e-24\n1.500\n0.9454\n1.5\n1.2\n0.2935\n\n\n\n\n119072 rows × 24 columns\n\n\n\n\n# sweep variable vectors\nl = np.unique(abs(df['l']))\nvgs = np.unique(abs(df['vgs']))\nvds = np.unique(abs(df['vds']))\nvsb = np.unique(abs(df['vsb']))\n\n\n# data\n# ngspice sweep order is l, vgs, vds, vsb\ndims = [len(l), len(vgs), len(vds), len(vsb)]\nid = np.reshape(df['ids'].values, dims, order='C')\nvt = np.reshape(df['vth'].values, dims, order='C')\ngm = np.reshape(df['gm'].values, dims, order='C')\ngmb = np.reshape(df['gmb'].values, dims, order='C')\ngds = np.reshape(df['gds'].values, dims, order='C')\ncgsol = np.reshape(df['cgsol'].values, dims, order='C')\ncgg = np.reshape(df['cgg'].values, dims, order='C') \\\n      + np.reshape(df['cgdol'].values, dims, order='C') \\\n      + np.reshape(df['cgsol'].values, dims, order='C')\ncgb = -np.reshape(df['cgb'].values, dims, order='C')\ncgd = -np.reshape(df['cgd'].values, dims, order='C') \\\n      + np.reshape(df['cgdol'].values, dims, order='C')\ncgs = -np.reshape(df['cgs'].values, dims, order='C') \\\n      + np.reshape(df['cgsol'].values, dims, order='C')\ncdd = np.reshape(df['cdd'].values, dims, order='C') \\\n      + np.reshape(df['cjd'].values, dims, order='C') \\\n      + np.reshape(df['cgdol'].values, dims, order='C')\ncss = np.reshape(df['css'].values, dims, order='C') \\\n      + np.reshape(df['cjs'].values, dims, order='C') \\\n      + np.reshape(df['cgsol'].values, dims, order='C')\nsth = np.reshape(df['sid'].values, dims, order='C')\nsfl = np.reshape(df['sfl'].values, dims, order='C')\n\n\ndic = {\n  \"INFO\": \"IHP SG13G2, 130nm CMOS, PSP\",\n  \"CORNER\": \"NOM\",\n  \"TEMP\": 300.0,\n  \"VGS\": vgs,\n  \"VDS\": vds,\n  \"VSB\": vsb,\n  \"L\": l,\n  \"W\": w[choice],\n  \"NFING\": nfing[choice],\n  \"ID\": id,\n  \"VT\": vt,\n  \"GM\": gm,\n  \"GMB\": gmb,\n  \"GDS\": gds,\n  \"CGG\": cgg,\n  \"CGB\": cgb,\n  \"CGD\": cgd,\n  \"CGS\": cgs,\n  \"CDD\": cdd,\n  \"CSS\": css,\n  \"STH\": sth,\n  \"SFL\": sfl\n}\n\nsavemat(devices[choice]+'.mat', {devices[choice]: dic})"
  },
  {
    "objectID": "sizing/sizing_basic_ota.html",
    "href": "sizing/sizing_basic_ota.html",
    "title": "Sizing for Basic 5T-OTA",
    "section": "",
    "text": "Copyright 2024 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given parameters as taken from the specification table or inital guesses\nc_load = 50e-15\ngm_id_m12 = 10\ngm_id_m34 = 5\ngm_id_m56 = 5\nl_12 = 5\nl_34 = 5\nl_56 = 5\nf_bw = 10e6 # -3dB bandwidth of the voltage buffer\ni_total_limit = 10e-6\ni_bias_in = 20e-6\noutput_voltage = 1.3\nvin_min = 0.7\nvin_max = 0.9\nvdd_min = 1.45\nvdd_max = 1.55\n\n\n# we get the required gm of M1/2 from the -3dB bandwidth requirement of the voltage buffer specification\n# note that the -3dB bandwidth of the voltage buffer with gain Av=1 is equal to the unity gain bandwidth\n# of the ota, hence we wet them equal here\n# we add a factor of 3 to allow for PVT variation plus additional MOSFET parasitic loading\ngm_m12 = f_bw * 3 * 4*np.pi*c_load\nprint('gm12 =', round(gm_m12/1e-3, 4), 'mS')\n\ngm12 = 0.0188 mS\n\n\n\n# since we know gm12 and the gmid we can calculate the bias current\nid_m12 = gm_m12 / gm_id_m12\ni_total = 2*id_m12\nprint('i_total (exact) =', round(i_total/1e-6, 1), 'µA')\n# we round to 0.5µA bias currents\ni_total = max(round(i_total / 1e-6 * 2) / 2 * 1e-6, 0.5e-6)\nid_m12 = i_total/2\n\nprint('i_total (rounded) =', i_total/1e-6, 'µA')\nif i_total &lt; i_total_limit:\n    print('[info] power consumption target is met!')\nelse:\n    print('[info] power consumption target is NOT met!') \n\ni_total (exact) = 3.8 µA\ni_total (rounded) = 4.0 µA\n[info] power consumption target is met!\n\n\n\n# we calculate the dc gain\ngm_gds_m12 = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_gds_m34 = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0)\n\ngds_m12 = gm_m12 / gm_gds_m12\ngm_m34 = gm_id_m34 * i_total/2\ngds_m34 = gm_m34 / gm_gds_m34\n\na0 = gm_m12 / (gds_m12 + gds_m34)\nprint('a0 =', round(20*np.log10(a0), 1), 'dB')\n\na0 = 34.8 dB\n\n\n\n# we calculate the MOSFET capacitance which adds to Cload, to see the impact on the BW\ngm_cgs_m12 = lv_nmos.lookup('GM_CGS', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_cdd_m12 = lv_nmos.lookup('GM_CDD', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_cdd_m34 = lv_pmos.lookup('GM_CDD', GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0)\n\nc_load_parasitic = abs(gm_m12/gm_cgs_m12) + abs(gm_m12/gm_cdd_m12) + abs(gm_m34/gm_cdd_m34)\nprint('additional load capacitance =', round(c_load_parasitic/1e-15, 1), 'fF')\n\nf_bw = gm_m12 / (4*np.pi * (c_load + c_load_parasitic))\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\n\nadditional load capacitance = 54.9 fF\nunity gain bandwidth incl. parasitics = 14.3 MHz\n\n\n\n# we can now look up the VGS of the MOSFET\nvgs_m12 = lv_nmos.look_upVGS(GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0.0)\nvgs_m34 = lv_pmos.look_upVGS(GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0.0) \nvgs_m56 = lv_nmos.look_upVGS(GM_ID=gm_id_m56, L=l_56, VDS=0.75, VSB=0.0) \n\nprint('vgs_12 =', round(float(vgs_m12), 3), 'V')\nprint('vgs_34 =', round(float(vgs_m34), 3), 'V')\nprint('vgs_56 =', round(float(vgs_m56), 3), 'V')\n\nvgs_12 = 0.367 V\nvgs_34 = 0.729 V\nvgs_56 = 0.591 V\n\n\n\n# calculate settling time due to slewing with the calculated bias current\nt_slew = (c_load + c_load_parasitic) * output_voltage / i_total\nprint('slewing time =', round(t_slew/1e-6, 3), 'µs')\nt_settle = 5/(2*np.pi*f_bw)\nprint('settling time =', round(t_settle/1e-6, 3), 'µs')\n\nslewing time = 0.034 µs\nsettling time = 0.056 µs\n\n\n\n# calculate voltage gain error\ngain_error = a0 / (1 + a0)\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\n\nvoltage gain error = -1.8 %\n\n\n\n# calculate total rms output noise\nsth_m12 = lv_nmos.lookup('STH_GM', VGS=vgs_m12, L=l_12, VDS=0.75, VSB=0) * gm_m12\ngamma_m12 = sth_m12/(4*1.38e-23*300*gm_m12)\n\nsth_m34 = lv_pmos.lookup('STH_GM', VGS=vgs_m34, L=l_34, VDS=0.75, VSB=0) * gm_m34\ngamma_m34 = sth_m34/(4*1.38e-23*300*gm_m34)\n\noutput_noise_rms = np.sqrt(1.38e-23*300 / (c_load + c_load_parasitic) * (2*gamma_m12 + 2*gamma_m34 * gm_m34/gm_m12))\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\n\noutput noise = 354.2 µVrms\n\n\n\n# calculate all widths\nid_w_m12 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m12, L=l_12, VDS=vgs_m12, VSB=0)\nw_12 = id_m12 / id_w_m12\nw_12_round = max(round(w_12*2)/2, 0.5)\nprint('M1/2 W =', round(w_12, 2), 'um, rounded W =', w_12_round, 'um')\n\nid_m34 = id_m12\nid_w_m34 = lv_pmos.lookup('ID_W', GM_ID=gm_id_m34, L=l_34, VDS=vgs_m34, VSB=0)\nw_34 = id_m34 / id_w_m34\nw_34_round = max(round(w_34*2)/2, 0.5) \nprint('M3/4 W =', round(w_34, 2), 'um, rounded W =', w_34_round, 'um')\n\nid_w_m5 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m56, L=l_56, VDS=vgs_m56, VSB=0)\nw_5 = i_total / id_w_m5\nw_5_round = max(round(w_5*2)/2, 0.5)\nprint('M5 W =', round(w_5, 2), 'um, rounded W =', w_5_round, 'um')\nw_6 = w_5_round * i_bias_in / i_total\nw_6_round = max(round(w_6*2)/2, 0.5)\nprint('M6 W =', round(w_6_round, 2), 'um')\n\nM1/2 W = 1.77 um, rounded W = 2.0 um\nM3/4 W = 1.64 um, rounded W = 1.5 um\nM5 W = 0.74 um, rounded W = 0.5 um\nM6 W = 2.5 um\n\n\n\n# print out final design values\nprint('5T-OTA dimensioning:')\nprint('--------------------')\nprint('M1/2 W=', w_12_round, ', L=', l_12)\nprint('M3/4 W=', w_34_round, ', L=', l_34)\nprint('M5   W=', w_5_round, ', L=', l_56)\nprint('M6   W=', w_6_round, ', L=', l_56)\nprint()\nprint('5T-OTA performance summary:')\nprint('---------------------------')\nprint('supply current =', round(i_total/1e-6, 1), 'µA')\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\nprint('turn-on time (slewing+settling) =', round((t_slew+t_settle)/1e-6, 3), 'µs')\nprint()\nprint('5T-OTA bias point check:')\nprint('------------------------')\nprint('headroom M1 =', round(vdd_min-vgs_m34+vgs_m12-vin_max, 3), 'V')\nprint('headroom M4 =', round(vdd_min-vin_max, 3), 'V')\nprint('headroom M5 =', round(vin_min-vgs_m12, 3), 'V')\n\n5T-OTA dimensioning:\n--------------------\nM1/2 W= 2.0 , L= 5\nM3/4 W= 1.5 , L= 5\nM5   W= 0.5 , L= 5\nM6   W= 2.5 , L= 5\n\n5T-OTA performance summary:\n---------------------------\nsupply current = 4.0 µA\noutput noise = 354.2 µVrms\nvoltage gain error = -1.8 %\nunity gain bandwidth incl. parasitics = 14.3 MHz\nturn-on time (slewing+settling) = 0.09 µs\n\n5T-OTA bias point check:\n------------------------\nheadroom M1 = 0.188 V\nheadroom M4 = 0.55 V\nheadroom M5 = 0.333 V"
  },
  {
    "objectID": "sizing/sizing_measurement_amplifier.html",
    "href": "sizing/sizing_measurement_amplifier.html",
    "title": "Sizing for Measurement Amplifier",
    "section": "",
    "text": "Copyright 2024 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the specified values\nAv_spec = 1\nRl_spec = 50 # Ohm\ngm_spec = Av_spec / (Rl_spec/2)\ngm_id_spec = 8\nL_spec = 0.13 # um\nVdd = 1.5 # V\n\n\n# we can calculate the bias current ID directly\nid = gm_spec / gm_id_spec\nprint('Id =', round(id/1e-3, 3), 'mA')\n\nId = 5.0 mA\n\n\n\n# find the W of the transistor\nvout_dc = Rl_spec/2*id\nid_w = lv_pmos.lookup('ID_W', GM_ID=gm_id_spec, L=L_spec, VDS=(Vdd-vout_dc), VSB=0)\nw = id / id_w\nw_round = round(w/10,0)*10\nprint('W =', round(w, 2), 'um, rounded W =', w_round, 'um')\n\nW = 264.3 um, rounded W = 260.0 um\n\n\n\nvgs = lv_pmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=(Vdd-vout_dc), VSB=0.0)\nprint ('Vgs =', round(float(vgs),3), 'V')\n\nVgs = 0.601 V\n\n\n\n# the gm_gds we look up and calculate gds from it\ngm_gds = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_spec, L=L_spec, VDS=(Vdd-vout_dc), VSB=0)\ngds = gm_spec / gm_gds\n# calculate the effective load impedance taking gds into account\nRload = 1/(2/Rl_spec + gds)\nprint('Rload =', round(Rload, 1), 'Ohm')\nAv = gm_spec * Rload\nprint('Av =', round(20*np.log10(Av),1), 'dB')\ncin = gm_spec*lv_pmos.lookup('CGG_GM', GM_ID=gm_id_spec, L=L_spec, VDS=(Vdd-vout_dc), VSB=0)\nprint('Cin =', round(float(cin)/1e-15), 'fF')\n\nRload = 23.8 Ohm\nAv = -0.4 dB\nCin = 351 fF\n\n\n\n# draw the final circuit with calculated values\n#| label: fig-meas-amp-sized\n#| fig-cap: Measurement amplifier with calculated circuit sizing.\nimport schemdraw as sd\nimport schemdraw.elements as elm\nsd.svgconfig.svg2 = False\nwith sd.Drawing(canvas='svg') as d:\n    d.config(unit=2)\n    d.config(fontsize=16)\n    elm.Vdd().label(str(Vdd)+'V')\n    M1 = elm.AnalogPFet(offset_gate=False).drop('drain').theta(0).reverse().label(str(round(w_round))+'µm/'+str(round(L_spec,2))+'µm', loc='right')\n    drainline = elm.Line().down().length(1)\n    elm.CurrentLabelInline(direction='in', ofst=-0).at(drainline).label(str(id/1e-3)+'mA')\n    d.push()\n    elm.Line().right().dot(open=True).length(2).idot().label(str(id*50/2)+'V')\n    elm.Line().right().length(1.5).label(r'$v_\\mathrm{out}$')\n    Rload = elm.Resistor().down().label(str(Rl_spec)+r'$\\Omega$')\n    elm.Ground()\n    d.pop()\n    R1 = elm.Resistor().down().label(str(Rl_spec)+r'$\\Omega$')\n    elm.Ground()\n    elm.Line().left().at(M1.gate).length(0.5).dot()\n    d.push()\n    Cin = elm.Capacitor().up().label(str(round(cin/1e-15,1))+'fF').color('red')\n    elm.Vdd()\n    d.pop()\n    elm.Line().left().length(2).label(str(round(Vdd-vgs,3))+'V')\n    elm.Line().left().dot(open=True).length(0.5).label(r'$v_\\mathrm{in}$', 'left')"
  },
  {
    "objectID": "sizing/sizing_basic_ota_improved.html",
    "href": "sizing/sizing_basic_ota_improved.html",
    "title": "Sizing for Basic (Improved) OTA",
    "section": "",
    "text": "Copyright 2024-2025 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given parameters as taken from the specification table or initial guesses\nc_load = 50e-15\ngm_id_m12 = 13\ngm_id_m12c = 13\ngm_id_m34 = 13\ngm_id_m34c = 13\ngm_id_m56 = 13\nl_12 = 0.5\nl_12c = 0.5\nl_34 = 0.5\nl_34c = 0.5\nl_56 = 5\nf_bw = 10e6 # -3dB bandwidth of the voltage buffer\ni_total_limit = 10e-6 # we plan 2x5uA in addition for additional bias voltage generation\ni_bias_in = 5e-6\noutput_voltage = 1.3\nvin_min = 0.7\nvin_max = 0.9\nvdd_min = 1.45\nvdd_max = 1.55\nvds_headroom = 0.2\n\n\n# we get the required gm of M1/2 from the -3dB bandwidth requirement of the voltage buffer specification\n# note that the -3dB bandwidth of the voltage buffer with gain Av=1 is equal to the unity gain bandwidth\n# of the ota, hence we wet them equal here\n# we add a factor of 3 to allow for PVT variation plus additional MOSFET parasitic loading\n# we also add an additional factor of 2 to get more dc gain (and there is power still in the budget)\ngm_m12 = f_bw * 3 * 4*np.pi*c_load * 3\nprint('gm12 =', round(gm_m12/1e-3, 4), 'mS')\n\ngm12 = 0.0565 mS\n\n\n\n# since we know gm12 and the gmid we can calculate the bias current\nid_m12 = gm_m12 / gm_id_m12\ni_total = 2*id_m12\nprint('i_total (exact) =', round(i_total/1e-6, 1), 'µA')\n# we round to 0.5µA bias currents\ni_total = max(round(i_total / 1e-6 * 2) / 2 * 1e-6, 0.5e-6)\n# here is a manual override to set the current; we keep a reserve of 2µA for bias branch\ni_total = 8e-6\nid_m12 = i_total/2\n\nprint('i_total (rounded) =', i_total/1e-6, 'µA')\nif i_total &lt; i_total_limit:\n    print('[info] power consumption target is met!')\nelse:\n    print('[info] power consumption target is NOT met!') \n\ni_total (exact) = 8.7 µA\ni_total (rounded) = 8.0 µA\n[info] power consumption target is met!\n\n\n\n# we calculate the dc gain\ngm_gds_m12 = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\ngm_gds_m12c = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\ngm_gds_m34 = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_m34, L=l_34, VDS=vds_headroom, VSB=0)\ngm_gds_m34c = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom)\n# conductance of lower cascoded differential pair\ngds_m12 = gm_m12 / gm_gds_m12\ngds_m12_casc = gds_m12 / gm_gds_m12c\n# conductance of upper cascoded current mirror\ngm_m34 = gm_id_m34 * i_total/2\ngds_m34 = gm_m34 / gm_gds_m34\ngds_m34_casc = gds_m34 / gm_gds_m34c\n\nprint('gds_12 =', round(gds_m12/1e-6, 3), 'µs')\nprint('gm_12c/gds_12c =',round(float(gm_gds_m12c), 1))\nprint('gds_34 =', round(gds_m34/1e-6, 3), 'µs')\nprint('gm_34c/gds_34c =', round(float(gm_gds_m34c), 1))\n\na0 = gm_m12 / (gds_m12_casc + gds_m34_casc)\nprint('a0 =', round(20*np.log10(a0), 1), 'dB')\n\ngds_12 = 4.026 µs\ngm_12c/gds_12c = 13.4\ngds_34 = 2.031 µs\ngm_34c/gds_34c = 24.9\na0 = 43.4 dB\n\n\n\n# we calculate the MOSFET capacitance which adds to Cload, to see the impact on the BW\ngm_cgs_m12 = lv_nmos.lookup('GM_CGS', GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\ngm_cdd_m12c = lv_nmos.lookup('GM_CDD', GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\ngm_cdd_m34c = lv_pmos.lookup('GM_CDD', GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom)\n\nc_load_parasitic = abs(gm_m12/gm_cgs_m12) + abs(gm_m12/gm_cdd_m12c) + abs(gm_m34/gm_cdd_m34c)\nprint('additional load capacitance =', round(c_load_parasitic/1e-15, 1), 'fF')\n\nf_bw = gm_m12 / (4*np.pi * (c_load + c_load_parasitic))\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\n\nadditional load capacitance = 5.5 fF\nunity gain bandwidth incl. parasitics = 81.15 MHz\n\n\n\n# we can now look up the VGS of the MOSFET\nvgs_m12 = lv_nmos.look_upVGS(GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\nvgs_m12c = lv_nmos.look_upVGS(GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\nvgs_m34 = lv_pmos.look_upVGS(GM_ID=gm_id_m34, L=l_34, VDS=vds_headroom, VSB=0.0) \nvgs_m34c = lv_pmos.look_upVGS(GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom) \nvgs_m56 = lv_nmos.look_upVGS(GM_ID=gm_id_m56, L=l_56, VDS=vds_headroom, VSB=0.0) \n\nprint('vgs_12  =', round(float(vgs_m12), 3), 'V')\nprint('vgs_12c =', round(float(vgs_m12c), 3), 'V')\nprint('vgs_34  =', round(float(vgs_m34), 3), 'V')\nprint('vgs_34c =', round(float(vgs_m34c), 3), 'V')\nprint('vgs_56  =', round(float(vgs_m56), 3), 'V')\n\nvgs_12  = 0.436 V\nvgs_12c = 0.458 V\nvgs_34  = 0.475 V\nvgs_34c = 0.512 V\nvgs_56  = 0.318 V\n\n\n\n# calculate settling time due to slewing with the calculated bias current\nt_slew = (c_load + c_load_parasitic) * output_voltage / i_total\nprint('slewing time  =', round(t_slew/1e-6, 3), 'µs')\nt_settle = 5/(2*np.pi*f_bw)\nprint('settling time =', round(t_settle/1e-6, 3), 'µs')\n\nslewing time  = 0.009 µs\nsettling time = 0.01 µs\n\n\n\n# calculate voltage gain error\ngain_error = a0 / (1 + a0)\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\n\nvoltage gain error = -0.7 %\n\n\n\n# calculate total rms output noise\nsth_m12 = lv_nmos.lookup('STH_GM', VGS=vgs_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom) * gm_m12\ngamma_m12 = sth_m12/(4*1.38e-23*300*gm_m12)\n\nsth_m34 = lv_pmos.lookup('STH_GM', VGS=vgs_m34, L=l_34, VDS=vds_headroom, VSB=0) * gm_m34\ngamma_m34 = sth_m34/(4*1.38e-23*300*gm_m34)\n\noutput_noise_rms = np.sqrt(1.38e-23*300 / (c_load + c_load_parasitic) * (2*gamma_m12 + 2*gamma_m34 * gm_m34/gm_m12))\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\n\noutput noise = 555.4 µVrms\n\n\n\n# calculate all widths\nid_w_m12 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\nw_12 = id_m12 / id_w_m12\nw_12_round = max(round(w_12*2)/2, 0.5)\nprint('M1/2  W =', round(w_12, 2), 'um, rounded W =', w_12_round, 'um')\n\nid_m12c = id_m12\nid_w_m12c = lv_nmos.lookup('ID_W', GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\nw_12c = id_m12c / id_w_m12c\nw_12c_round = max(round(w_12c*2)/2, 0.5)\nprint('M1/2c W =', round(w_12c, 2), 'um, rounded W =', w_12c_round, 'um')\n\nid_m34 = id_m12\nid_w_m34 = lv_pmos.lookup('ID_W', GM_ID=gm_id_m34, L=l_34, VDS=vds_headroom, VSB=0)\nw_34 = id_m34 / id_w_m34\nw_34_round = max(round(w_34*2)/2, 0.5) \nprint('M3/4  W =', round(w_34, 2), 'um, rounded W =', w_34_round, 'um')\n\nid_m34c = id_m12\nid_w_m34c = lv_pmos.lookup('ID_W', GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom)\nw_34c = id_m34c / id_w_m34c\nw_34c_round = max(round(w_34c*2)/2, 0.5) \nprint('M3/4c W =', round(w_34c, 2), 'um, rounded W =', w_34c_round, 'um')\n\nid_w_m5 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m56, L=l_56, VDS=vds_headroom, VSB=0)\nw_5 = i_total / id_w_m5\nw_5_round = max(round(w_5*2)/2, 0.5)\nprint('M5    W =', round(w_5, 2), 'um, rounded W =', w_5_round, 'um')\n\nw_6 = w_5_round * i_bias_in / i_total\nprint('M6    W =', round(w_6, 2), 'um')\n\nM1/2  W = 0.83 um, rounded W = 1.0 um\nM1/2c W = 0.8 um, rounded W = 1.0 um\nM3/4  W = 3.28 um, rounded W = 3.5 um\nM3/4c W = 2.99 um, rounded W = 3.0 um\nM5    W = 14.2 um, rounded W = 14.0 um\nM6    W = 8.75 um\n\n\n\n# Print out final design values\nprint('Improved OTA dimensioning:')\nprint('--------------------------')\nprint('M1/2  W=', w_12_round, ', L=', l_12)\nprint('M1/2c W=', w_12c_round, ', L=', l_12c)\nprint('M3/4  W=', w_34_round, ', L=', l_34)\nprint('M3/4c W=', w_34c_round, ', L=', l_34c)\nprint('M5   W=', w_5_round, ', L=', l_56)\nprint('M6   W=', round(w_6, 2), ', L=', l_56)\nprint()\nprint('Improved OTA performance summary:')\nprint('---------------------------------')\nprint('supply current =', round(i_total/1e-6, 1), 'µA')\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\nprint('turn-on time (slewing+settling) =', round((t_slew+t_settle)/1e-6, 3), 'µs')\nprint()\nprint('Improved OTA bias point check:')\nprint('------------------------------')\nprint('headroom M1+M1c =', round(vdd_min-vgs_m34+vgs_m12-vin_max, 3), 'V')\nprint('headroom M4+M4c =', round(vdd_min-vin_max, 3), 'V')\nprint('headroom M5     =', round(vin_min-vgs_m12, 3), 'V')\n\nImproved OTA dimensioning:\n--------------------------\nM1/2  W= 1.0 , L= 0.5\nM1/2c W= 1.0 , L= 0.5\nM3/4  W= 3.5 , L= 0.5\nM3/4c W= 3.0 , L= 0.5\nM5   W= 14.0 , L= 5\nM6   W= 8.75 , L= 5\n\nImproved OTA performance summary:\n---------------------------------\nsupply current = 8.0 µA\noutput noise = 555.4 µVrms\nvoltage gain error = -0.7 %\nunity gain bandwidth incl. parasitics = 81.15 MHz\nturn-on time (slewing+settling) = 0.019 µs\n\nImproved OTA bias point check:\n------------------------------\nheadroom M1+M1c = 0.512 V\nheadroom M4+M4c = 0.55 V\nheadroom M5     = 0.264 V"
  },
  {
    "objectID": "sizing/techsweep_sg13_plots_pmos.html",
    "href": "sizing/techsweep_sg13_plots_pmos.html",
    "title": "MOSFET gm/ID Evaluation Script for IHP SG13G2",
    "section": "",
    "text": "Copyright 2024 Boris Murmann and Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\nThis notebook displays various important metrics for the SG13G2 CMOS technology. The corresponding Xschem testbenches are named techsweep_sg13g2_lv_nmos.sch and techsweep_sg13g2_lv_pmos.sch (to be found in the xschem folder).\n\ndevices = ['sg13_lv_nmos', 'sg13_lv_pmos']\nchoice = 1 # select which device to plot, start from 0\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n# widths used for characterization\nw = np.array([5, 5])\n\n\n# read ngspice data\ndf_raw = pd.read_csv('./techsweep_'+devices[choice]+'.txt', sep=r'\\s+')\npar_names = df_raw.columns.to_list()\npar_prefix = par_names[1].split('[')[0]\n\n# remove extra headers in file body and unwanted columns\n#df_raw = df_raw[~df_raw['v-sweep'].str.contains('v-sweep')]\ndf = df_raw.drop(['frequency', 'frequency.1'], axis=1)\ndf = df.apply(pd.to_numeric)\n\n# rename columns for readability\ndf.columns = df.columns.str.removeprefix(par_prefix+'[')\ndf.columns = df.columns.str.replace(par_prefix[1:], '')\ndf.columns = df.columns.str.removesuffix(']')\n\n# round sweep vectors to easily addressable values\ndf['l'] = df['l'].apply(lambda x: round(x/1e-6, 3))\ndf['vgs'] = df['vgs'].apply(lambda x: round(x, 3))\ndf['vds'] = df['vds'].apply(lambda x: round(x, 3))\ndf['vsb'] = df['vsb'].apply(lambda x: round(x, 3))\n\nprint(df.columns)\n# Note on noise data: \n# 1.: sid, sfl are thermal and flicker noise current densities at 1 Hz in A^2/Hz from operating point data\n\nIndex(['cdd', 'cgb', 'cgd', 'cgdol', 'cgg', 'cgs', 'cgsol', 'cjd', 'cjs',\n       'css', 'fug', 'gds', 'gm', 'gmb', 'ids', 'l', 'rg', 'sfl', 'sid', 'vds',\n       'vdss', 'vgs', 'vsb', 'vth'],\n      dtype='object')\n\n\n\n# sweep variable vectors\nl = np.unique(abs(df['l']))\nvgs = np.unique(abs(df['vgs']))\nvds = np.unique(abs(df['vds']))\nvsb = np.unique(abs(df['vsb']))\n\n\n# plot gm/ID and fT versus gate bias\n#| label: fig-pmos-gmid-ft-vs-vgs\n#| fig-cap: $g_m/I_D$ and $f_T$ as a function of the gate-source voltage.\nL1 = min(l); VDS1=0.75; VSB1=0\ndf1 = df.loc[(df['l'] == L1) & (abs(df['vds']) == VDS1) & (abs(df['vsb']) == VSB1)]\ngm_id1 = df1['gm'].values/df1['ids'].values\ncgg1 = df1['cgg'].values + df1['cgdol'].values+df1['cgsol'].values \nft1 = df1['gm'].values/cgg1/2/np.pi\nft2 = df1['fug'].values\n\nfig, ax1 = plt.subplots()\nax1.grid(axis='x')\nax1.set_xlabel(r'$V_\\mathrm{GS}$ (V)')\ncolor = 'tab:blue'\nax1.set_ylabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)', color=color)\nax1.plot(vgs, gm_id1, color=color)\nax1.tick_params(axis='y', labelcolor=color)\nax2 = ax1.twinx()\ncolor = 'tab:red'\nax2.set_ylabel(r'$f_\\mathrm{T}$ (GHz)', color=color)\nax2.plot(vgs, ft1/1e9, color=color)\nax2.plot(vgs, ft2/1e9, color=color)\nax2.tick_params(axis='y', labelcolor=color)\nfig.tight_layout()\nplt.title(devices[choice]+', $L$='+str(L1)+r'µm, $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.xlim(0, 1.5)\nplt.axvline(x = df1['vth'].values[0], color='k', linestyle='--')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_gmID_fT_VGS.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\n\n# plot product of gm/ID and fT versus gm/ID\nfig, ax1 = plt.subplots()\nplt.plot(gm_id1, gm_id1*ft1/1e9)\nplt.xlim(2, 26)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{T} \\cdot g_\\mathrm{m}/I_\\mathrm{D}$ (GHz $\\cdot$ S/A)')\nplt.title(devices[choice]+', $L$='+str(L1)+r'µm, $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_fTgmID_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\n\n# plot fT versus gm/ID\n#| label: fig-pmos-ft-vs-gmid\n#| fig-cap: $f_T$ vs. $g_m/I_D$.\nplt.plot(gm_id1, ft1/1e9)\nplt.xlim(2, 26)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{T}$ (GHz)')\nplt.title(devices[choice]+', $L$='+str(L1)+r'µm, $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n# plot fT versus gm/ID for all L\n#| label: fig-pmos-ft-vs-gmid-vs-l\n#| fig-cap: $f_T$ vs. $g_m/I_D$ as a function of $L$.\nVDS2=0.75; VSB2=0\ndf2 = df.loc[(abs(df['vds']) == VDS2) & (abs(df['vsb']) == VSB2)]\ngm_id2 = df2['gm'].values/df2['ids'].values\ngm_id2 = np.reshape(gm_id2, (len(vgs), -1), order='F')\nft2 = df2['gm'].values/(df2['cgg'].values+df2['cgdol'].values+df2['cgsol'].values)/2/np.pi\nft2 = np.reshape(ft2, (len(vgs), -1), order='F')\n\nfig, ax = plt.subplots()\nax.plot(gm_id2, ft2/1e9)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{T}$ (GHz)')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_fT_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot gm/gds versus gm/ID for all L\n#| label: fig-pmos-gmgds-vs-gmid-vs-l\n#| fig-cap: $g_m/g_{ds}$ vs. $g_m/I_D$ as a function of $L$.\ngm_gds2 = df2['gm'].values/df2['gds'].values\ngm_gds2 = np.reshape(gm_gds2, (len(vgs), -1), order='F')\n\nfig, ax = plt.subplots()\nax.plot(gm_id2, gm_gds2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.ylim(0, 200)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$g_\\mathrm{m}/g_\\mathrm{ds}$ (V/V)')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_gmgds_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot Id/W (Jd) versus gm/ID for all L\n#| label: fig-pmos-jd-vs-gmid-vs-l\n#| fig-cap: $I_D/W$ vs. $g_m/I_D$ as a function of $L$.\njd2 = df2['ids'].values/w[choice]/1e-6\njd2 = np.reshape(jd2, (len(vgs), -1), order='F')\n\nfig, ax = plt.subplots()\nax.semilogy(gm_id2, jd2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nif choice == 0:\n    plt.ylim(1e-2, 1e3)\nelse:\n    plt.ylim(1e-2, 1e3)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$I_\\mathrm{D}/W$ ($\\mu$A/$\\mu$m)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_IDW_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot Vdss versus gm/ID for all L\n#| label: fig-pmos-vdsat-vs-gmid-vs-l\n#| fig-cap: $V_{ds,sat}$ vs. $g_m/I_D$ as a function of $L$.\nvdss2 = df2['vdss']\nvdss2 = np.reshape(vdss2, (len(vgs), -1), order='F')\nfig, ax = plt.subplots()\nax.plot(gm_id2, vdss2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.ylim(0, 1)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$V_\\mathrm{ds,sat}$ (V)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_Vdssat_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot gamma versus gm/ID for all L\n#| label: fig-pmos-gamma-vs-gmid-vs-l\n#| fig-cap: $\\gamma$ vs. $g_m/I_D$ as a function of $L$.\nsid2 = df2['sid'].values\ngm2 = df2['gm'].values\nsid2 = np.reshape(sid2, (len(vgs), -1), order='F')\ngm2 = np.reshape(gm2, (len(vgs), -1), order='F')\ngamma2 = sid2/4/1.38e-23/300/gm2\n\nfig, ax = plt.subplots()\nax.plot(gm_id2, gamma2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nif choice == 0:\n    plt.ylim(0.6,1.2)\nelse:\n    plt.ylim(1,2.5)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'Noise factor $\\gamma$ (1)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_gamma_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot fco versus gm/ID for all L\n#| label: fig-pmos-fco-vs-gmid-vs-l\n#| fig-cap: Flicker-noise corner frequency vs. $g_m/I_D$ as a \nsfl2 = df2['sfl'].values\nsfl2 = np.reshape(sfl2, (len(vgs), -1), order='F')\nfco = sfl2/sid2\nfig, ax = plt.subplots()\nax.semilogy(gm_id2, fco)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.ylim(1e2, 1e8)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{co}$ (Hz)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_pmos_overview/plots/PMOS_fco_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque."
  },
  {
    "objectID": "analog_circuit_design.html#ihps-sg13g2-130nm-cmos-technology",
    "href": "analog_circuit_design.html#ihps-sg13g2-130nm-cmos-technology",
    "title": "Analog Circuit Design",
    "section": "1.1 IHP’s SG13G2 130nm CMOS Technology",
    "text": "1.1 IHP’s SG13G2 130nm CMOS Technology\nSG13G2 is the name of a 130nm CMOS technology (strictly speaking BiCMOS) from IHP Microelectronics. It features low-voltage (thin-oxide) core MOSFET, high-voltage (thick-oxide) I/O MOSFET, various types of linear resistors, and 7 layers of Aluminum metallization (5 thin plus 2 thick metal layers). This PDK is open-source, and the complete process specification can be found at SG13G2 process specification. While we will not do layouts in this course, the layout rules can be found at SG13G2 layout rules.\nFor our circuit design, the most important parameters of the available devices are summarized in the following table:\n\n\n\nTable 1: IHP SG13G2 devices\n\n\n\n\n\n\n\n\n\n\nComponent\nDevice Name\nSpecifications\n\n\n\n\nLow-voltage (LV) NMOS\nsg13_lv_nmos\noperating voltage (nom.) \\(V_\\mathrm{DD}=1.5\\,\\text{V}\\), \\(L_\\mathrm{min}=0.13\\,\\mu\\text{m}\\), \\(V_\\mathrm{th}\\approx 0.5\\,\\text{V}\\); isolated NMOS available\n\n\nLow-voltage (LV) PMOS\nsg13_lv_pmos\noperating voltage (nom.) \\(V_\\mathrm{DD}=1.5\\,\\text{V}\\), \\(L_\\mathrm{min}=0.13\\,\\mu\\text{m}\\), \\(V_\\mathrm{th}\\approx -0.47\\,\\text{V}\\)\n\n\nHigh-voltage (HV) NMOS\nsg13_hv_nmos\noperating voltage (nom.) \\(V_\\mathrm{DD}=3.3\\,\\text{V}\\), \\(L_\\mathrm{min}=0.45\\,\\mu\\text{m}\\), \\(V_\\mathrm{th}\\approx 0.7\\,\\text{V}\\); isolated NMOS available\n\n\nHigh-voltage (HV) PMOS\nsg13_hv_pmos\noperating voltage (nom.) \\(V_\\mathrm{DD}=3.3\\,\\text{V}\\), \\(L_\\mathrm{min}=0.45\\,\\mu\\text{m}\\), \\(V_\\mathrm{th}\\approx -0.65\\,\\text{V}\\)\n\n\nSilicided poly resistor\nrsil\n\\(R_\\square=7\\,\\Omega \\pm 10\\%\\), \\(\\text{TC}_1=3100\\,\\text{ppm/K}\\)\n\n\nPoly resistor\nrppd\n\\(R_\\square=260\\,\\Omega \\pm 10\\%\\), \\(\\text{TC}_1=170\\,\\text{ppm/K}\\)\n\n\nPoly resistor high\nrhigh\n\\(R_\\square=1360\\,\\Omega \\pm 15\\%\\), \\(\\text{TC}_1=-2300\\,\\text{ppm/K}\\)\n\n\nMIM capacitor\ncap_cmim\n\\(C'=1.5\\,\\text{fF}/\\mu\\text{m}^2 \\pm 10\\%\\), \\(\\text{VC}_1=-26\\text{ppm/V}\\), \\(\\text{TC}_1=3.6\\text{ppm/K}\\), breakdown voltage \\(&gt;15\\,\\text{V}\\)\n\n\nMOM capacitor\nn/a\nThe metal stack is well-suited for MOM capacitors due to 5 thin metal layers, but no primitive capacitor device is available at this point."
  },
  {
    "objectID": "analog_circuit_design.html#schematic-entry-using-xschem",
    "href": "analog_circuit_design.html#schematic-entry-using-xschem",
    "title": "Analog Circuit Design",
    "section": "1.2 Schematic Entry Using Xschem",
    "text": "1.2 Schematic Entry Using Xschem\nXschem is an open-source schematic entry tool with emphasis on integrated circuits. For up-to-date information of the many features of Xschem and the basic operation of it please look at the available online documentation. Usage of Xschem will be learned with the first few basic examples, essentially using a single MOSFET. The usage model of Xschem is that the schematic is hierarchically drawn, and the simulation and evaluation statements are contained in the schematics. Further, Xschem offers embedded graphing, which we will mostly use.\nA summary of important Xschem keyboard shortcuts is provided in Section 19."
  },
  {
    "objectID": "analog_circuit_design.html#circuit-simulation-using-ngspice",
    "href": "analog_circuit_design.html#circuit-simulation-using-ngspice",
    "title": "Analog Circuit Design",
    "section": "1.3 Circuit Simulation Using ngspice",
    "text": "1.3 Circuit Simulation Using ngspice\nngspice is an open-source circuit simulator with SPICE dependency (Nagel 1975). Besides the usual simulated types like op (operating point), dc (dc sweeps), tran (time domain), ac (small-signal frequency sweeps), and noise (small-signal noise analysis), ngspice offers a script-like control interface, where many different simulation controls and result evaluations can be done. For detailed information please refer to the latest online manual.\nImportant ngspice simulation commands and options (e.g., how to control convergence settings) are listed in Section 20."
  },
  {
    "objectID": "analog_circuit_design.html#integrated-ic-design-environment-iic-osic-tools",
    "href": "analog_circuit_design.html#integrated-ic-design-environment-iic-osic-tools",
    "title": "Analog Circuit Design",
    "section": "1.4 Integrated IC Design Environment (IIC-OSIC-TOOLS)",
    "text": "1.4 Integrated IC Design Environment (IIC-OSIC-TOOLS)\nIn order to make use of the various required components (tools like Xschem and ngspice, PDKs like SG13G2) easier, we will use the IIC-OSIC-TOOLS. This is a pre-compiled Docker image which allows to do circuit design on a virtual machine on virtually any type of computing equipment (personal PC, Raspberry Pi, cloud server) on various operating systems (Windows, macOS, Linux). For further information like installed tools, how to setup a VM, etc., please look at IIC-OSIC-TOOLS GitHub page.\n\n\n\n\n\n\nPreparation\n\n\n\nPlease make sure to receive information about your personal VM access ahead of the course start.\n\n\nExperienced users can install this image on their personal computer, for JKU students the IIC will host a VM on our compute cluster and provide personal login credentials.\n\n\n\n\n\n\nLinux\n\n\n\nIn this course, we assume that students have a basic knowledge of Linux and how to operate it using the terminal (shell). If you are not yet familiar with Linux (which is basically a must when doing integrated circuit design as many tools are only available on Linux), then please check out a Linux introductory course or tutorial online, there are many resources available.\nA summary of important Linux shell commands is provided in Section 18."
  },
  {
    "objectID": "analog_circuit_design.html#setting-up-the-design-directory",
    "href": "analog_circuit_design.html#setting-up-the-design-directory",
    "title": "Analog Circuit Design",
    "section": "1.5 Setting up the Design Directory",
    "text": "1.5 Setting up the Design Directory\n\nOpen your VM by entering the URL in your browser.\nOpen a terminal (third icon in the taskbar at the bottom). You should get the following prompt: /foss/designs &gt;\nClone the git repository into the current directory: git clone https://github.com/iic-jku/analog-circuit-design.git\nThis GitHub repository includes a file called .designinit, which sets the PDK and certain paths. However, this must be located in /foss/designs/\nTherefore, we first need to copy it there: cp analog-circuit-design/.designinit .\nThen we adjust the variable XSCHEM_USER_LIBRARY_PATH by opening the file in an editor e.g. nano .designinit\n\nChange the last line from export XSCHEM_USER_LIBRARY_PATH=$DESIGNS/xschem to export XSCHEM_USER_LIBRARY_PATH=$DESIGNS/analog-circuit-design/xschem\n\nTo apply the changes, we need to close the current terminal window: exit\nOpen again a terminal\nTest if the correct PDK gets selected: echo $PDK (you should get sg13g2 as the answer)\nChange into the GitHub repository: cd analog-circuit-design\nStart xschem using xschem or directly open a specific schematic using xschem xschem/dc_lv_nmos.sch\n\n\n1.5.1 Creating Backups\nYou can easily create backups of your work by creating a zip archive of the complete directory:\n\nChange to the parent directory: cd /foss/designs\nCreate a zip archive from the complete design folder: zip backup.zip analog-circuit-design -r\n\n\n\n1.5.2 Updating the Repository\n\nCreate a backup!\nGo to directory: e.g. cd /foss/designs/analog-circuit-design\nFetch newest changes from the origin: git fetch origin\nMerge changes from the origin into local branch ‘master’: git merge origin/main\n\n\n\n\n\n\n\nGit Merge Conflicts\n\n\n\nIt is possible that git merge does not complete successfully. Either you are able to resolve the merge conflict manually, or it may be easier to make a fresh clone of the repository and adding your local changes manually from the backup.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nPlease think twice before executing any git command without a backup, as this could lead to permanent loss of data!"
  },
  {
    "objectID": "analog_circuit_design.html#sec-mosfet",
    "href": "analog_circuit_design.html#sec-mosfet",
    "title": "Analog Circuit Design",
    "section": "2.1 The Metal-Oxide-Semiconductor Field-Effect-Transistor (MOSFET)",
    "text": "2.1 The Metal-Oxide-Semiconductor Field-Effect-Transistor (MOSFET)\nIn this course, we will not dive into semiconductor physics and derive the device operation bottom-up starting from a fundamental level governed by quantum mechanics or a simplified solid-state physics based approach resulting in the well-known square-law model. Instead, we will treat the MOSFET behaviorally by assuming a 4-terminal device, and the performance of this device regarding its terminal voltages and currents we will largely derive from the simulation model.\nSince we have an emphasis on integrated circuit design in this course the size of the MOSFET can be adapted by changing its width \\(W\\) and its length \\(L\\). As we will see later, \\(L\\) has a profound impact on the MOSFET performance allowing to trade-off speed versus output conductance versus device-to-device matching. The width \\(W\\) is more of a scaling parameter to adapt the current density (strictly speaking charge density) forming in the MOSFET channel to a desired current. More about this later.\nThe circuit symbol that we will use for the n-channel MOSFET is shown in Figure 1, and for the p-channel MOSFET it is shown in Figure 2. A control voltage between gate (“G”) and source (“S”) controls the current flow between drain (“D”) and source. The MOSFET is a 4-terminal device, so the bulk (“B”) can also control the drain-source current flow. Often, the bulk is connected to source, and then the bulk terminal is not shown to declutter the schematics.\n\n\n\n\n\n\nMOSFET Background\n\n\n\nStrictly speaking is the drain-source current of a MOSFET controlled by the voltage between gate and bulk (\\(V_\\mathrm{GB}\\)) and the voltage between drain and source (\\(V_\\mathrm{DS}\\)). Since bulk is often connected to source anyway, and many circuit designers historically were already familiar with the operation of the bipolar junction transistor (BJT), it is common to consider the gate-source voltage (besides the drain-source voltage) as the controlling voltage.\nThis focus on gate-source suggests that the source is special compared to the drain. In a typical physical MOSFET, however, the drain and source are constructed exactly the same (i.e., the MOSFET is a symmetric device), and which terminal is drain, and which terminal is source, is only determined by the applied voltage potentials, and can change dynamically during operation (think of a MOSFET operating as a switch… which side is the drain, which side is the source?).\nUnfortunately, this focus on a “special” source has made its way into some MOSFET compact models. The model that is used in SG13G2 luckily uses the PSP model, which is formulated symmetrically with regards to drain and source, and is thus very well suited for analog and RF circuit design. For a detailed understanding of the PSP model please refer to the model documentation.\n\n\n\n\n\n\n\n\n\n\nFigure 1: Circuit symbol of n-channel MOSFET.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Circuit symbol of p-channel MOSFET.\n\n\n\n\n\nFor hand calculations and theoretical discussions we will use the following simplified large-signal model, shown in Figure 3. A current source \\(I_\\mathrm{D}\\) models the current flow between drain and source, and it is controlled by the three control voltages \\(V_\\mathrm{GS}\\), \\(V_\\mathrm{DS}\\), and \\(V_\\mathrm{SB}\\). Note that in this way (since \\(I_\\mathrm{D}= f(V_\\mathrm{DS})\\)) also a resistive behavior between D and S can be modelled. In case that B and S are shorted then simply \\(V_\\mathrm{SB} = 0\\) and \\(C_\\mathrm{SB}\\) is shorted.\n\n\n\n\n\n\n\n\nFigure 3: The MOSFET large-signal model. In general, all capacitors are nonlinear, i.e., they depend on their terminal voltages.\n\n\n\n\n\nIn an ideal MOSFET no dc current is flowing into the gate, the behavior is purely capacitive. We model this by two capacitors: \\(C_\\mathrm{GG}= C_\\mathrm{GS}+ C_\\mathrm{GD}+ C_\\mathrm{GB}\\) is the total capacitance when looking into the gate of the MOSFET. \\(C_\\mathrm{GS}\\) is usually the dominant capacitance, and \\(C_\\mathrm{GD}\\) models the capacitive feedback between D and G, usually induced by a topological overlap capacitance in the physical construction of the MOSFET. This capacitance is often small compared to \\(C_\\mathrm{GS}\\), but in situations where we have a large voltage swing at the drain this capacitance will be affected by the Miller effect (see Section 16.1). In hand calculations we will often set \\(C_\\mathrm{GD}= C_\\mathrm{GB}= C_\\mathrm{DB}= C_\\mathrm{SB}= 0\\).\nTo model a physical MOSFET there will be also a requirement for resistors in the model to account for terminal access resistances (\\(R_\\mathrm{G}\\), \\(R_\\mathrm{D}\\), and \\(R_\\mathrm{S}\\)) as well as resistors to model second-order effects like non-quasistatic operation. For lower frequencies and bulk MOSFETs we will not consider these resistors, and just deal with the capacitive behavior.\n\n\n\n\n\n\nMOSFET Bulk Terminal\n\n\n\nIn many situations we will connect the bulk and source terminals of a MOSFET together, which results in a simplified large-signal model. As an exercise, look at Figure 3 and draw this simplified model (hint: look at Figure 5 and Figure 6 for inspiration).\n\n\nNow, as we are skipping the bottom-up approach of deriving the MOSFET large-signal behavior from basic principles, we need to understand the behavior of the elements of the large-signal model in Figure 3 by using a circuit simulator and observing what happens. And generally, a first step in any new IC technology should be to investigate basic MOSFET performance, by doing simple dc sweeps of \\(V_\\mathrm{GS}\\) and \\(V_\\mathrm{DS}\\) and looking at \\(I_\\mathrm{D}\\) and other large- and small-signal parameters.\nAs a side note, the students who want to understand MOSFET behavior from a physical angle should consult the MOSFET chapter from the JKU course “Design of Complex Integrated Circuits” (VL 336.048). A great introduction into MOSFET operation and fabrication is given in (Hu 2010), which is available freely online and is a recommended read. A very detailed description of the MOSFET (leaving usually no question unanswered) is provided in (Tsividis and McAndrew 2011).\nNow, in order to get started, basic Xschem testbenches are prepared, and first simple dc sweeps of various voltages and currents will be done. But before that, please look at the import note below!\n\n\n\n\n\n\nMathematical Notation\n\n\n\nThroughout this material, we will largely stick to the following notation standardized by IEEE:\n\nA dc quantity is shown with an upper-case variable name with upper-case subscripts, like \\(V_\\mathrm{GS}\\).\nDouble-subscripts denote dc sources, like \\(V_\\mathrm{DD}\\) and \\(V_\\mathrm{SS}\\).\nAn ac (small-signal) quantity (incremental quantity) has a lower-case variable name with a lower-case subscript, like \\(g_\\mathrm{m}\\).\nA total quantity (dc plus ac) is shown as a lowercase variable name with upper-case subscript, like \\(i_\\mathrm{DS}\\).\nAn upper-case variable name with a lower-case subscript is used to denote RMS quantities, like \\(I_\\mathrm{ds}\\).\n\n\n\n\n\n\n\n\n\nA Comment on Active and Passive Devices and Linear vs. Nonlinear\n\n\n\nIn contrast to the passive devices resistor \\(R\\), inductor \\(L\\), and capacitor \\(C\\), which can only dissipate energy (and are often treated in a linearized fashion), transistors (like the MOSFET) are called “active”, since they can provide signal power amplification. However, transistors can not create energy out of thin air, but merely convert dc energy (supplied by the power supply) into ac energy. They have to have nonlinear transfer characteristics to do this, but it has been shown that a piecewise-linear characteristic is sufficient (Jakoby 2022). This is very good news for circuit design, as usually we strive for linear behaviour!\n\n\n\n2.1.1 Large-Signal MOSFET Model\nWe start with an investigation into the large-signal MOSFET model shown in Figure 3 by using the simple testbench for the LV NMOS shown in Figure 4.\n\n\n\n\n\n\nFigure 4: Testbench for NMOS dc sweeps.\n\n\n\n\n\n\n\n\n\nMOSFET Simulation Model\n\n\n\nFor modelling the MOSFET behavior in a circuit simulator like ngspice different models are available. Some of these models have been widely adopted, like the BSIM (Berkeley Short-channel IGFET Model) or PSP (Philips Penn State) model. The PSP model version 103.6 is used in the IHP SG13G2 PDK for the LV and HV MOSFET. This model has several advantages:\n\nPhysics-based surface-potential model\nSymmetric formulation with respect to drain and source\nSupport for mobility reduction, velocity saturation, DIBL, gate current, lateral doping gradient effects, STI stress, NQS, etc.\n\nThe PSP 103.6 model documentation can be found here. In chapter 8 the dc operating point output of the model (these parameters can be queried in ngspice) is explained, which is helpful to interpret the simulation output.\n\n\n\n\n\n\n\n\nExercise: MOSFET Investigation\n\n\n\nPlease try to execute the following steps and answer these questions:\n\nGet the LV NMOS testbench (available at https://github.com/iic-jku/analog-circuit-design/blob/main/xschem/dc_lv_nmos.sch) working in your IIC-OSIC-TOOLS environment.\nMake yourself familiar with Xschem (change the schematic in various ways, run a simulation, graph the result).\nMake yourself familiar with ngspice (run various simulations, save nets and parameters, use the embedded Xschem graphing, explore the interactive ngspice shell to look at MOSFET model parameters).\nExplore the LV NMOS sg13_lv_nmos:\n\nHow is \\(I_\\mathrm{D}\\) affected by \\(V_\\mathrm{GS}\\) and \\(V_\\mathrm{DS}\\)?\nChange \\(W\\) and \\(L\\) of the MOSFET. What is the impact on the above parameters? Can you explain the variations?\nLook at the capacitance values for \\(C_\\mathrm{GS}\\), \\(C_\\mathrm{GB}\\), \\(C_\\mathrm{GD}\\), and \\(C_\\mathrm{DB}\\). How are they affected by \\(W\\) and \\(L\\) and by changing the bias conditions (play with \\(V_\\mathrm{GS}\\) and \\(V_\\mathrm{DS}\\))?\nWhen looking at the model parameters in ngspice, you see that there is a \\(C_\\mathrm{GD}\\) and a \\(C_\\mathrm{DG}\\). Why is this, what could be the difference? Sometimes these capacitors show a negative value, why? (Hint: Study Note 1)\n\nBuild testbenches in Xschem for the LV PMOS, the HV NMOS, and the HV PMOS. Explore the different results.\n\nFor a given \\(W\\) and \\(L\\), which device provides more drain current? How are the capacitances related?\nIf you would have to size an inverter, what would be the ideal ratio of \\(W_p/W_n\\)? Will you exactly design this ratio, or are the reasons to deviate?\nThere are LV and HV MOSFETs, and you investigated the difference in performance. What is the rationale when designing circuits for selection either an LV type, and when to choose an HV type?\n\nBuild a test bench to explore the body effect, start with LV NMOS.\n\nWhat happens when \\(V_\\mathrm{SB}\\neq 0\\)?\n\n\n\n\n\n\n2.1.2 Small-Signal MOSFET Model\nAs you have seen in the previous investigations, the large-signal model of Figure 3 describes the behavior of the MOSFET across a wide range of voltages applied at the MOSFET terminals. Unfortunately, for hand analysis dealing with a nonlinear model is close to impossible, at the very least it is quite tedious.\nHowever, for many practical situations, we bias a MOSFET with a set of dc voltages applied to its terminal, and only apply small signal excursions during operation. If we do this, we can linearize the large-signal model in this dc operating point, and resort to a small-signal model which can be very useful for hand calculations. Many experienced designers analyze their circuits by doing these kind of hand calculations and describing the circuit analytically, which is a great way to understand fundamental performance limits and relationships between parameters.\nWe will use the small-signal MOSFET model shown in Figure 5 for this course. The current-source \\(i_\\mathrm{d}= g_\\mathrm{m}v_\\mathrm{gs}\\) models the drain current \\(I_\\mathrm{D}\\) as a function of \\(V_\\mathrm{GS}\\) with\n\\[\ng_\\mathrm{m}= \\frac{\\partial I_\\mathrm{D}(V_\\mathrm{GS}, V_\\mathrm{DS}, V_\\mathrm{SB})}{\\partial V_\\mathrm{GS}},\n\\]\nand the resistor \\(g_\\mathrm{ds}\\) models the dependency of the drain current by \\(V_\\mathrm{DS}\\):\n\\[\ng_\\mathrm{ds}= \\frac{\\partial I_\\mathrm{D}(V_\\mathrm{GS}, V_\\mathrm{DS}, V_\\mathrm{SB})}{\\partial V_\\mathrm{DS}}\n\\]\nThe drain current dependency on the source-bulk voltage (the so-called “body effect”) is introduced by the current source \\(i_\\mathrm{d}= g_\\mathrm{mb} v_\\mathrm{sb}\\):\n\\[\ng_\\mathrm{mb}= \\frac{\\partial I_\\mathrm{D}(V_\\mathrm{GS}, V_\\mathrm{DS}, V_\\mathrm{SB})}{\\partial V_\\mathrm{SB}}\n\\]\n\n\n\n\n\n\n\n\nFigure 5: The MOSFET small-signal model.\n\n\n\n\n\nAs has been mentioned before, in many situations (and whenever we want to use a simplified model) we connect source and bulk of the MOSFET together. This results in the much simplified small-signal model shown in Figure 6.\n\n\n\n\n\n\n\n\nFigure 6: The MOSFET small-signal model when source and bulk are shorted.\n\n\n\n\n\nAs any electronic device the MOSFET introduces noise into the circuit. In this course we will only consider the drain-source current noise of the MOSFET, given by\n\\[\n\\overline{I_\\mathrm{n}^2} = 4 k T \\gamma g_\\mathrm{d0},\n\\tag{1}\\]\nwhere \\(\\overline{I_\\mathrm{n}^2}\\) is the one-sided power-spectral density of the noise in A\\(^2\\)/Hz; \\(k\\) is the Boltzmann constant; \\(T\\) is the absolute temperature; \\(\\gamma\\) is a (fitting) parameter in simplified theory changing between \\(\\gamma = 2/3\\) in saturation and \\(\\gamma =1\\) for triode operation; \\(g_\\mathrm{d0}\\) is equal to \\(g_\\mathrm{m}\\) in saturation and \\(g_\\mathrm{ds}\\) in triode).\n\n\n\n\n\n\nMOSFET Triode and Saturation Region\n\n\n\nSometimes we will refer to different operating modes of the MOSFET like “saturation” or “triode.” Generally speaking, when the drain-source voltage is small, then the MOSFET acts as a voltage-controlled resistor (since the impact of both \\(V_\\mathrm{GS}\\) and \\(V_\\mathrm{DS}\\) on \\(I_\\mathrm{D}\\) is large), and this mode of operation we call “triode” mode.\nWhen the drain-source voltage \\(V_\\mathrm{DS}\\) is increased, at some point the drain-source current saturates and is only a weak function of the drain-source voltage, while still being well controlled by \\(V_\\mathrm{GS}\\). This mode is called “saturation” mode.\nAs you can see in the large-signal investigations, these transitions happen gradually, and it is difficult to define a precise point where one operating mode switches to the other one. In this sense we use terms like “triode” and “saturation” only in an approximate sense.\n\n\nWe can also consider an even more reduced small-signal MOSFET model compared to Figure 6, which is shown in Figure 7. In this, we just consider the transconductance \\(g_\\mathrm{m}\\), the input capacitor \\(C_\\mathrm{gg}\\), as well as the output conductance \\(g_\\mathrm{ds}\\). Note that we can redraw the pi-model of Figure 7 into the \\(\\tau\\)-model of Figure 8. Depending on the circuit configuration, either the first or the second form results in simpler calculations of the circuit equations.\n\n\n\n\n\n\n\n\nFigure 7: The MOSFET small-signal basic pi-model.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: The MOSFET small-signal basic T-model.\n\n\n\n\n\n\n\n\n\n\n\nExercise: MOSFET Model Transformation\n\n\n\nCan you show, with which circuit manipulations you can transform the pi-model of Figure 7 into the T-model of Figure 8?\n\n\nA metric which is useful to assess the speed of a MOSFET is the so-called transit frequency \\(f_\\mathrm{T}\\). It is defined as the frequency where the small-signal current gain (output current divided by the input current) of a MOSFET driven by a voltage-source at the input and loaded by a voltage source at the output drops to unity (reaches one). It can easily be derived using the simplified MOSFET small-signal model of Figure 6 by driving it with a voltage source and shorting the output to (neglecting the feed-forward current introduced by \\(C_\\mathrm{gd}\\)) \\[\n\\omega_\\mathrm{T} = 2 \\pi f_\\mathrm{T} \\approx \\frac{g_\\mathrm{m}}{C_\\mathrm{gg}} = \\frac{g_\\mathrm{m}}{C_\\mathrm{gs}+ C_\\mathrm{gd}+ C_\\mathrm{gb}}.\n\\tag{2}\\] This frequency is an extrapolated frequency where the MOSFET operation is dominated by several second-order effects (hence Equation 2 is not valid any longer). A rule-of-thumb is to use a MOSFET up to approximately \\(f_\\mathrm{T} / 10\\). In any case, \\(f_\\mathrm{T}\\) is a proxy of the speed of a MOSFET; in other words, how much input capacitance \\(C_\\mathrm{gg}\\) is incurred when creating a certain \\(g_\\mathrm{m}\\).\n\n\n\n\n\n\nExercise: MOSFET Transit Frequency\n\n\n\nAs a home exercise, try to derive Equation 2 starting from Figure 6. By showing this transformation you can proof that indeed both circuits are electrically equivalent.\n\n\nNow we need to see how the small-signal parameters seen in Figure 5 can be investigated and estimated using circuit simulation.\n\n\n\n\n\n\nExercise: MOSFET Small-Signal Parameters\n\n\n\nPlease try to execute the following steps and answer the following questions:\n\nReuse the LV NMOS testbench (available at https://github.com/iic-jku/analog-circuit-design/blob/main/xschem/dc_lv_nmos.sch).\nExplore the LV NMOS sg13_lv_nmos:\n\nHow are \\(g_\\mathrm{m}\\) and \\(g_\\mathrm{ds}\\) changing when you change the dc node voltages?\nWhat is the ratio of \\(g_\\mathrm{m}\\) to \\(g_\\mathrm{mb}\\)? What is the physical reason behind this ratio (you might want to revisit MOSFET device physics at this point)?\nTake a look at the device capacitances \\(C_\\mathrm{gs}\\), \\(C_\\mathrm{gd}\\), and \\(C_\\mathrm{gb}\\). Why are they important? What is the \\(f_\\mathrm{T}\\) of the MOSFET?\nLook at the drain noise current according to the MOSFET model and compare with a hand calculation of the noise. In the noise equation there is the factor \\(\\gamma\\), which in triode is \\(\\gamma=1\\) and in saturation is \\(\\gamma=2/3\\) according to basic text books. Which value of \\(\\gamma\\) are you calculating? Why might it be different?\n\nGo back to your testbench for the LVS PMOS sg13_lv_pmos:\n\nWhat is the difference in \\(g_\\mathrm{m}\\), \\(g_\\mathrm{ds}\\), and other parameters between the NMOS and the PMOS? Why could they be different?\n\n\n\n\n\n\n\n\n\n\nNote 1: Maxwell Capacitance Matrix\n\n\n\nA Maxwell capacitance matrix (Maxwell 1873) provides the relation between voltages on a set of conductors and the charges on these conductors. For a given conductor set with \\(N\\) conductors (and thus \\(N\\) terminals) the relation is \\[\n\\mathbf{Q} = \\mathbf{C} \\cdot \\mathbf{V}\n\\] where \\(\\mathbf{Q}\\) is a vector of the charges on the \\(N\\) conductors, \\(\\mathbf{C}\\) is a \\(N \\times N\\) capacitance matrix, and \\(\\mathbf{V}\\) is the potential vector. In the case of two conductors and physical capacitances between them, \\(\\mathbf{C}\\) is given by \\[\n\\mathbf{C} =\n\\begin{pmatrix}\nC_{11} + C_{12} & -C_{12} \\\\\n-C_{21} & C_{21} + C_{22} \\\\\n\\end{pmatrix}\n\\] where \\(C_{xx} = \\partial Q_x / \\partial V_x\\) is the auto capacitance from a conductor \\(x\\) towards infinity (ground), and \\(C_{xy} = \\partial Q_x / \\partial V_y\\) is the mutual capacitance from node/conductor \\(x\\) to node/conductor \\(y\\). For a physical capacitor \\(C_{xy} = C_{yx}\\).\nUsing the above equation to calculate \\(Q_1\\) (the charge on conductor \\(1\\)) results in \\[\nQ_1 = ( C_{11} + C_{12} ) V_1 - C_{12} V_2 = C_{11} (V_1 - 0) + C_{12} (V_1 - V_2)\n\\] which is the expected result.\nSuch a Maxwell capacitance formulation is also used in the MOSFET model to describe the charge at a terminal as a function of potential at another terminal. So, \\[\nC_\\mathrm{GD}= \\frac{\\partial Q_\\mathrm{G}}{\\partial V_\\mathrm{D}}\n\\] or \\[\nC_\\mathrm{GG}= \\frac{\\partial Q_\\mathrm{G}}{\\partial V_\\mathrm{G}}\n\\] with \\(Q_\\mathrm{G}\\) the charge at terminal G in response to either \\(V_\\mathrm{D}\\) or \\(V_\\mathrm{G}\\). Note that in a MOSFET, generally \\(C_{xy} \\ne C_{yx}\\)!"
  },
  {
    "objectID": "analog_circuit_design.html#conclusion",
    "href": "analog_circuit_design.html#conclusion",
    "title": "Analog Circuit Design",
    "section": "2.2 Conclusion",
    "text": "2.2 Conclusion\nCongratulations for making it thus far! By now you should have a solid grasp of the tool handling of Xschem and ngspice, and you should be familiar with the large- and small-signal operation of both NMOS and PMOS, and the parameters describing these behaviors. If you feel you are not sufficiently fluent in these things, please go back to the beginning of Section 2.1 and revisit the relevant sections, or dive into further reading about the MOSFET operation, like in (Hu 2010)."
  },
  {
    "objectID": "analog_circuit_design.html#sec-techsweep-testbench",
    "href": "analog_circuit_design.html#sec-techsweep-testbench",
    "title": "Analog Circuit Design",
    "section": "3.1 MOSFET Characterization Testbench",
    "text": "3.1 MOSFET Characterization Testbench\nIn order to get the required tabulated data we use a testbench in Xschem which sweeps the terminal voltages, and records various large- and small-signal parameters, which are then stored in large tables. The testbench for the LV NMOS is shown in Figure 9, and the TB for the LV PMOS is shown in Figure 10.\n\n\n\n\n\n\nNote on Characterization Testbench\n\n\n\nThe testbenches are relatively straightforward, with one exception: The drain current noise is sensed via the drain voltage source vd and converted to a noise voltage (node n) using a current-controlled voltage source (CCVS). This is necessary as the .noise simulation statement works with voltages.\n\n\n\n\n\n\n\n\nFigure 9: Testbench for LV NMOS \\(g_\\mathrm{m}/I_\\mathrm{D}\\) characterization.\n\n\n\n\n\n\n\n\n\nFigure 10: Testbench for LV PMOS \\(g_\\mathrm{m}/I_\\mathrm{D}\\) characterization.\n\n\n\nWe will use Jupyter notebooks to inspect the resulting data, and interpret some important graphs. This will greatly help to understand the MOSFET behavior."
  },
  {
    "objectID": "analog_circuit_design.html#sec-techsweep-nmos",
    "href": "analog_circuit_design.html#sec-techsweep-nmos",
    "title": "Analog Circuit Design",
    "section": "3.2 NMOS Characterization in Saturation",
    "text": "3.2 NMOS Characterization in Saturation\nFirst, we will start looking at the LV NMOS. In Section 3.3 we have the corresponding graphs for the LV PMOS. In this lecture, we will only use the LV MOSFETs. While there are also the HV types available, they are mainly used for high-voltage circuits, like circuits connecting to the outside world. Here, we only will design low-voltage circuits running at a nominal supply voltage of \\(1.5\\,\\text{V}\\), so only the LV types are of interest to us.\nIn the plots that follow we will set \\(V_\\mathrm{ds}= V_\\mathrm{DD}/2\\) to keep the MOSFET in saturation (as this is the region of operation where most MOSFET are operated when working in class-A). We will later also look at the MOSFET performance in triode operation, as this is the operation mode where the MOSFET is used as a switch. While the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) method is primarily intended to be used for circuits where the MOSFETs are held in saturation and are biased by a certain bias current (usually referred to class-A), the generated tables using the testbenches of Section 3.1 contain the data for all MOSFET bias points.\nThe first import graph is the plot of \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(f_\\mathrm{T}\\) versus the gate-source voltage \\(V_\\mathrm{GS}\\). First let us answer the question why \\(g_\\mathrm{m}/I_\\mathrm{D}\\) is a good parameter to look at, and actually this is also the central parameter in the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) methodology. In many circuits we want to get a large amplification from a MOSFET, which corresponds to a large \\(g_\\mathrm{m}\\). We want to achieve this by spending the minimum biasing current possible (ideally zero), as we almost always design for lowest power consumption. Thus, a high \\(g_\\mathrm{m}/I_\\mathrm{D}\\) ratio is good.\n\n\n\n\n\n\nPower Consumption\n\n\n\nDesigning for minimum power consumption is pretty much always mandated. For battery-operated equipment it is a paramount requirement, but also in other equipment electrical energy consumption is a concern, and often severely limited by the cooling capabilities of the electrical system.\n\n\nHowever, as can be seen in the below plot, there exists a strong and unfortunate trade-off with device speed, characterized here by the transit frequency \\(f_\\mathrm{T}\\). It would be ideal if there exists a design point where we get high transconductance per bias current concurrently to having the fastest operation, but unfortunately, this is clearly not the case. The \\(g_\\mathrm{m}/I_\\mathrm{D}\\) peaks for \\(V_\\mathrm{GS}&lt; 0.3\\,\\text{V}\\), and the highest speed we get at \\(V_\\mathrm{GS}\\approx 1.2\\,\\text{V}\\). The dashed vertical line plots the nominal threshold voltage, as you can see in this continuum of parameter space, it marks not a particularly special point.\nNote that \\[\n\\frac{g_\\mathrm{m}}{I_\\mathrm{D}} = \\frac{1}{n V_\\mathrm{T}}\n\\tag{3}\\] for a MOSFET in weak inversion (i.e., small gate-source voltage). \\(n\\) is the subthreshold slope, and \\(V_\\mathrm{T} = k T / q\\) which is \\(25.8\\,\\text{mV}\\) at \\(300\\,\\text{K}\\). We thus have \\(n \\approx 1.38\\) for this LV NMOS, which falls nicely into the usual range for \\(n\\) of \\(1.3\\) to \\(1.5\\) for bulk CMOS (FinFET have \\(n\\) very close to \\(1\\)).\nFor the classical square-law model of the MOSFET in strong inversion, \\(g_\\mathrm{m}/I_\\mathrm{D}\\) is given as \\[\n\\frac{g_\\mathrm{m}}{I_\\mathrm{D}} = \\frac{2}{V_\\mathrm{GS}- V_\\mathrm{th}} = \\frac{2}{V_\\mathrm{od}}\n\\tag{4}\\] with \\(V_\\mathrm{th}\\) the threshold voltage and \\(V_\\mathrm{od}\\) the so-called “overdrive voltage.” The latter is sometimes also dubbed the effective gate-source voltage \\(V_\\mathrm{eff}\\) (Carusone, Johns, and Martin 2011).\n\n\n\n\n\n\nWhy 300K?\n\n\n\nWhy are we so often using a temperature of \\(300\\,\\text{K}\\) for a typical condition? As this corresponds to roughly \\(27^{\\circ}\\text{C}\\), this accounts for some self heating compared to otherwise cooler usual room temperatures. Further, engineers like round numbers which are easy to remember, so \\(300\\,\\text{K}\\) is used as a proxy for room temperature.\n\n\nAs we can also see from belows plot, the peak transit frequency of the LV NMOS is about \\(75\\,\\text{GHz}\\), which allows building radio-frequency circuits up to ca. \\(f_\\mathrm{T} / 10 = 7.5\\,\\text{GHz}\\), which is a respectable number. It is no coincidence, that the transition for RF design in the GHz-range switched from BJT-based technologies to CMOS roughly in the time frame when 130nm CMOS became available (ca. 2000).\nNote that \\(f_\\mathrm{T}\\) saturates and even decreases again at around \\(V_\\mathrm{GS}= 1.2\\,\\text{V}\\) due to second-order effects of the transistor like velocity saturation and DIBL. Velocity saturation describes the saturation of the velocity of the electrons at a certain \\(V_\\mathrm{GS}\\). As a consequence, also \\(g_\\mathrm{m}\\) saturates. Since \\(f_\\mathrm{T} \\propto g_\\mathrm{m}/ C_\\mathrm{gs}\\), \\(f_\\mathrm{T}\\) can not further increase. DIBL explains the effect when a too high \\(V_\\mathrm{GS}\\) is applied and therefore the channel is confined to a narrow region at the surface, leading to more carrier scattering and thus lower mobility.\n\n\n\n\n\n\n\n\n\n\nSource: MOSFET gm/ID Evaluation Script for IHP SG13G2\nThe following figure plots \\(f_\\mathrm{T}\\) against \\(g_\\mathrm{m}/I_\\mathrm{D}\\) for several different \\(L\\). As you can see, device speed maximizes for a low \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and a short \\(L\\). Note, that the drain-source voltage is kept at \\(V_\\mathrm{DS}= 0.75\\,\\text{V} = V_\\mathrm{DD}/ 2\\), which is a typical value keeping the MOSFET in saturation across the characterization sweeps. Further, the source-bulk voltage is kept at \\(V_\\mathrm{SB}= V_\\mathrm{S} - V_\\mathrm{B} = 0\\,\\text{V}\\), which means bulk and source terminals are connected. If \\(V_\\mathrm{SB}\\neq 0\\,\\text{V}\\), then the so-called body effect, bulk effect or back-gate effect occurs.\nIf \\(V_\\mathrm{SB}&gt; 0\\,\\text{V}\\), then \\(V_\\mathrm{th}\\) increases. If \\(V_\\mathrm{SB}&lt; 0\\,\\text{V}\\), then \\(V_\\mathrm{th}\\) decreases. At first glance, this effect may sound unwanted (and often also is), however, improved circuit designs by changing the bulk potential can be realized. For example, circuit 16 in (Pretl and Eberlein 2021) shows an implementation of a current mirror by exploiting the body effect. However, keep in mind that a deep-n-well (DNW), also called triple-well, is needed for NMOS transistors when the bulk is not tied to GND. This DNW may not be supported by the used PDK or can add additional costs to the wafer processing.\n\n\n\n\n\n\n\n\n\n\n\nThe next plot shows the ratio of \\(g_\\mathrm{m}/ g_\\mathrm{ds}\\) versus \\(g_\\mathrm{m}/I_\\mathrm{D}\\). The ratio \\(g_\\mathrm{m}/ g_\\mathrm{ds}\\) is the so-called “self-gain” of the MOSFET, and shows the maximum voltage gain we can achieve in a single transistor configuration. As one can see the self gain increases for increasing \\(L\\), but this also gives a slower transistor, so again there is a trade-off. This plot allows us to select the proper \\(L\\) of a MOSFET if we know which amount of self gain we need.\n\n\n\n\n\n\n\n\n\n\n\nThe following figure plots the drain current density \\(I_\\mathrm{D}/W\\) as a function of \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(L\\). With this plot we can find out how to set the \\(W\\) of a MOSFET once we know the biasing current \\(I_\\mathrm{D}\\), the \\(L\\) (selected according to self gain, \\(f_\\mathrm{T}\\), and other considerations) and the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) design point we selected. The drain current density \\(I_\\mathrm{D}/W\\) is a very useful normalized metric to use, because the physical action in the MOSFET establishes a charge density in the channel below the gate, and the changing of the \\(W\\) of the device merely transforms this charge density into an absolute parameter (together with \\(L\\)).\n\n\n\n\n\n\n\n\n\n\n\nThe following plot shows the minimum drain-source voltage \\(V_\\mathrm{ds,sat}\\) that we need to establish in order to keep the MOSFET in saturation. As you can see, this value is almost independent of \\(L\\), and increases for small \\(g_\\mathrm{m}/I_\\mathrm{D}\\). So for low-voltage circuits, where headroom is precious, we tend to bias at \\(g_\\mathrm{m}/I_\\mathrm{D}\\ge 10\\), wheres for fast circuits we need to go to small \\(g_\\mathrm{m}/I_\\mathrm{D}\\le 5\\) requiring substantial voltage headroom per MOSFET stage that we stack on top of each other.\n\n\n\n\n\n\n\n\n\n\n\nFor analog circuits the noise performance is usually quite important. Thermal noise of a resistor (the Johnson-Nyquist noise) has a flat power-spectral density (PSD) given by \\(\\overline{V_\\mathrm{n}^2}/\\Delta f = 4 k T R\\), where \\(k\\) is Boltzmann’s constant, \\(T\\) absolute temperature, and \\(R\\) the value of the resistor (the unit of \\(\\overline{V_\\mathrm{n}^2}/\\Delta f\\) is \\(\\text{V}^2/\\text{Hz}\\)). This PSD is essentially flat until very high frequencies where quantum effects start to kick in.\n\n\n\n\n\n\nNoise Notation\n\n\n\nWe usually leave the \\(\\Delta f\\) away for a shorter notation, so we write \\(\\overline{V_\\mathrm{n}^2}\\) when we actually mean \\(\\overline{V_\\mathrm{n}^2}/\\Delta f\\). In case of doubt look at the unit of a quantity, whether is shows \\(\\text{V}^2\\) or \\(\\text{V}^2/\\text{Hz}\\) or \\(\\text{V}/\\sqrt{\\text{Hz}}\\) (or \\(\\text{I}^2\\) or \\(\\text{I}^2/\\text{Hz}\\) or \\(\\text{I}/\\sqrt{\\text{Hz}}\\)).\nPlease also note that the pair of \\(k T\\) pretty much always shows up together, so when you do a calculation and you miss the one or the other, that is often a sign for miscalculation. Boltzmann’s constant \\(k = 1.38 \\cdot 10^{-23}\\,\\text{J/K}\\) is just a scaling factor from thermal energy expressed as a temperature \\(T\\) to energy \\(E = k T\\) expressed in Joule.\nFurther, when working with PSD there is the usage of a one-sided (\\(0 \\ge f &lt; \\infty\\)) or two-sided power spectral density (PSD) (\\(-\\infty &lt; f &lt; \\infty\\)). The default in this lecture is the usage of the one-sided PSD.\n\n\nIn this lecture the only MOSFET noise we consider is the drain noise (as discussed in Section 2.1.2), showing up as a current noise between drain and source. For a realistic MOSFET noise model, also a (correlated) gate noise component and the thermal noise of the gate resistance needs to be considered.\nThe factor \\(\\gamma\\) (Equation 1) is a function of many things (in classical theory, \\(\\gamma = 2/3\\) in saturation and \\(\\gamma = 1\\) in triode), and it is characterized in the following plot as a function of \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(L\\). So when calculating MOSFET noise we can lookup \\(\\gamma\\) in the below plot, and use Equation 1 to calculate the effective drain current noise.\n\n\n\n\n\n\n\n\n\n\n\nIn a MOSFET, unfortunately, besides the thermal noise according to Equation 1, there is also a substantial low-frequency excess noise, called “flicker noise” due to its characteristic \\(\\overline{I_\\mathrm{d,nf}^2} = K_\\mathrm{f}/f\\) behavior (this means that this noise PSD decreases versus frequency). In order to characterize this flicker noise the following plot shows the cross-over frequency \\(f_\\mathrm{co}\\), where the flicker noise is as large as the thermal noise. As can be seen in the below plot, this frequency is a strong function of \\(L\\) and \\(g_\\mathrm{m}/I_\\mathrm{D}\\). Generally, the flicker noise is proportional to \\((W L)^{-1}\\), so the larger the device is, the lower the flicker noise. The parameter \\(g_\\mathrm{m}/I_\\mathrm{D}\\) largely stays constant when we keep \\(W/L\\) constant, so for a given \\(g_\\mathrm{m}/I_\\mathrm{D}\\) flicker noise is proportional to \\(1/L^2\\). However, increasing \\(L\\) lowers device speed dramatically, so here we have a trade-off between flicker-noise performance and MOSFET speed, and this can have dramatic consequences for high-speed circuits.\n\n\n\n\n\n\nMOSFET Flicker Noise\n\n\n\nThe physical origin of flicker noise is the crystal interface between silicon (Si) and the silicon dioxide (SiO2). Since these are different materials, there are dangling bonds, which can capture charge carriers traveling in the channel. After a random time, these carriers are released, and flicker noise is the result. The amount of flicker noise is a function of the manufacturing process, and will generally be different between device types and wafer foundries.\n\n\nAs you can see in the following plot, \\(f_\\mathrm{co}\\) can reach well into the 10’s of MHz for short MOSFETs, significantly degrading the noise performance of a circuit.\n\n\n\n\n\n\n\n\n\n\n\nDuring the design phase, it might be convenient to have an overview of the most relevant sizing plots of the NMOST on one page. This overview can be downloaded here."
  },
  {
    "objectID": "analog_circuit_design.html#sec-techsweep-pmos",
    "href": "analog_circuit_design.html#sec-techsweep-pmos",
    "title": "Analog Circuit Design",
    "section": "3.3 PMOS Characterization in Saturation",
    "text": "3.3 PMOS Characterization in Saturation\nIn the following, we have the same plots as discussed in Section 3.2, but now for the PMOS.\n\n\n\n\n\n\nPMOS Sign Convention\n\n\n\nIn all PMOS plots we plot positive values for voltages and currents, to have compatible plots to the NMOS. Of course, in a PMOS, voltages and currents have different polarity compared to the NMOS.\n\n\n\\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(f_\\mathrm{T}\\) versus the gate-source voltage \\(V_\\mathrm{GS}\\):\n\n\n\n\n\n\n\n\n\n\nSource: MOSFET gm/ID Evaluation Script for IHP SG13G2\n\\(f_\\mathrm{T}\\) against \\(g_\\mathrm{m}/I_\\mathrm{D}\\) for several different \\(L\\). One can see a significantly lower top speed for the PMOS compared to the NMOS, which means for high-speed circuits the NMOS should be used. The reason for this is the approximately two to three times higher mobility of electrons compared to the mobility of holes.\n\n\n\n\n\n\n\n\n\n\n\n\\(g_\\mathrm{m}/ g_\\mathrm{ds}\\) versus \\(g_\\mathrm{m}/I_\\mathrm{D}\\). Unfortunately, one can see a modelling error for the PMOS in this plot. The self gain \\(g_\\mathrm{m}/ g_\\mathrm{ds}\\) reaches non-physical values, which indicates an issue with the \\(g_\\mathrm{ds}\\) modelling for the PMOS. We can not use these values for our circuit sizing, so we will use the respective NMOS plots also for the PMOS.\n\n\n\n\n\n\nBeware of Modelling Issues\n\n\n\nThis example shows how important it is to benchmark the device models when starting to use a new technology. Modelling artifacts like the one shown are quite often happening, as setting up the device compact models and parametrize them according to measurement data is a very complex task. In any case, just be aware that modelling issues could exist in whatever PDK you are going to use!\n\n\n\n\n\n\n\n\n\n\n\n\n\nDrain current density \\(I_\\mathrm{D}/W\\) as a function of \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(L\\):\n\n\n\n\n\n\n\n\n\n\n\nMinimum drain-source voltage \\(V_\\mathrm{ds,sat}\\) versus \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(L\\):\n\n\n\n\n\n\n\n\n\n\n\nNoise factor \\(\\gamma\\) versus \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(L\\):\n\n\n\n\n\n\n\n\n\n\n\nFlicker noise corner frequency \\(f_\\mathrm{co}\\) versus \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(L\\). If you compare this figure carefully with the NMOS figure you can see that for some operating points the flicker noise for the PMOS is lower than for the NMOS. This is often true for CMOS technologies, so it can be an advantage to use a PMOS transistor in places where flicker noise is critical, like an OTA input stage. Using PMOS has the further advantage that the bulk node can be tied to source (which for NMOS is only possible in a triple-well technology, which is often not available), which gets rid of the body effect.\n\n\n\n\n\n\n\n\n\n\n\nDuring the design phase, it might be convenient to have an overview of the most relevant sizing plots of the PMOST on one page. This overview can be downloaded here."
  },
  {
    "objectID": "analog_circuit_design.html#nmos-and-pmos-characterization-in-triode",
    "href": "analog_circuit_design.html#nmos-and-pmos-characterization-in-triode",
    "title": "Analog Circuit Design",
    "section": "3.4 NMOS and PMOS Characterization in Triode",
    "text": "3.4 NMOS and PMOS Characterization in Triode\nBesides using the MOSFET as a transconductor in saturation we often use the MOSFET as a switch in triode mode (to either switch voltages or currents). In this triode/switch mode of operation we are mainly interested in two parameters:\n\nThe resistance of the switch/MOSFET when it is turned on (\\(R_\\mathrm{on} = 1 / g_\\mathrm{ds}\\)).\nThe shunt capacitance of the switch when it is turned off (\\(C_\\mathrm{off}\\) is defined by the coupling capacitances between drain and source).\n\nIn the operation of the NMOS as a switch the gate is usually pulled to \\(V_\\mathrm{DD}\\) and the bulk is permanently connected to \\(V_\\mathrm{SS}\\) to achieve the lowest \\(R_\\mathrm{on}\\) (to turn the switch off the gate is pulled towards \\(V_\\mathrm{SS}\\)). Likewise, to turn on a PMOS, the gate is usually pulled to \\(V_\\mathrm{SS}\\) and the bulk is connected to \\(V_\\mathrm{DD}\\). In this situation the drain/source potential is somewhere between \\(V_\\mathrm{DD}\\) and \\(V_\\mathrm{SS}\\), so the MOSFET will experience a \\(V_\\mathrm{SB}\\neq 0\\), leading to a quite noticeable bulk effect. Once the drain/source potential is sufficiently high for NMOS (low PMOS) the switch resistance will drastically degrade.\nIn order to get a feeling for the behavior of the MOSFET as a switch the following characterization plots show \\(R_\\mathrm{on}\\) and \\(C_\\mathrm{off}\\) for the NMOS and the PMOS, respectively. Both plots are for \\(L = L_\\mathrm{min} = 0.13\\mu m\\), as for switches usually minimum length devices are used. Only for special applications (e.g., the drain-source leakage current in off-mode is a concern) MOSFETs with increased \\(L\\) are used.\n\n\n\n\n\n\n\n\n\n\nSource: MOSFET gm/ID Lookup for IHP SG13G2 in Triode Region\nAs can be seen in the previous plot, an NMOS can be used to switch at potentials close to \\(V_\\mathrm{SS}\\), while a PMOS is the better choice when switching at potentials close to \\(V_\\mathrm{DD}\\). To construct a switch which can work for all voltage levels between \\(V_\\mathrm{DD}\\) and \\(V_\\mathrm{SS}\\) an NMOS is put in parallel to a PMOS, resulting in the well-known transmission gate.\n\n\n\n\n\n\n\n\n\n\n\nAs the switch on-resistance gets lower when increasing \\(W\\), the off-capacitance gets larger. Thus, a good performance indicator for comparing switches in a given technology is the \\(R_\\mathrm{on} C_\\mathrm{off}\\) product.\nWhen designing switches, often the unwanted effects of charge injection and clock feed-through have to be considered and, as always, a trade-off has to be chosen. More details can be found in literature, e.g, (Carusone, Johns, and Martin 2011) or (Razavi 2017)."
  },
  {
    "objectID": "analog_circuit_design.html#mosfet-diode-sizing",
    "href": "analog_circuit_design.html#mosfet-diode-sizing",
    "title": "Analog Circuit Design",
    "section": "4.1 MOSFET Diode Sizing",
    "text": "4.1 MOSFET Diode Sizing\nWe will now build this circuit in Xschem. For sizing the MOSFET we will use the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) methodology introduced in Section 3.\n\n\n\n\n\n\nExercise: MOSFET Diode Sizing\n\n\n\nPlease build a MOSFET diode circuit in Xschem where you use an LV NMOS, set \\(I_\\mathrm{bias} = 20\\,\\mu\\text{A}\\), \\(L = 0.13\\,\\mu\\text{m}\\), and we want to use \\(g_\\mathrm{m}/I_\\mathrm{D}= 10\\) (often a suitable compromise between transistor speed and \\(g_\\mathrm{m}\\) efficiency).\n\nUse the figures in Section 3.2 to find out the proper value for \\(W\\).\nWhat is the \\(f_\\mathrm{T}\\) for this MOSFET? What is the value for \\(g_\\mathrm{m}\\) and \\(g_\\mathrm{ds}\\)?\nDraw the circuit in Xschem, and simulate the operating point. Do the values match to the values found out before during circuit sizing?\n\n\n\nBefore continuing, please finish the previous exercise. Once you are done, compare with the below provided solution.\n\n\n\n\n\n\nSolution: MOSFET Diode Sizing\n\n\n\n\n\n\nUsing the fact that \\(I_\\mathrm{bias} = I_\\mathrm{D} = 20\\,\\mu\\text{A}\\) and \\(g_\\mathrm{m}/I_\\mathrm{D}= 10\\) directly provides \\(g_\\mathrm{m}= 0.2\\,\\text{mS}\\).\nUsing the self-gain plot, we see that \\(g_\\mathrm{m}/g_\\mathrm{ds}\\approx 21\\), so \\(g_\\mathrm{ds}\\approx 9.5\\,\\mu\\text{S}\\). The \\(f_\\mathrm{T}\\) can easily be found in the respective plot to be \\(f_\\mathrm{T} = 23\\,\\text{GHz}\\).\nThe \\(W\\) of the MOSFET we find using the drain current density plot and the given bias current. Rounding to half-microns results in \\(W = 1\\,\\mu\\text{m}\\).\nSince we are looking at the graphs, we further find \\(\\gamma = 0.84\\), \\(V_\\mathrm{ds,sat} = 0.18\\,\\text{V}\\), and \\(f_\\mathrm{co} \\approx 15\\,\\text{MHz}\\).\nIn addition, we expect \\(V_\\mathrm{GS}\\approx 0.6\\,\\text{V}\\).\n\nAn example Jupyter notebook to extract these values accurately you can find here. An Xschem schematic for this exercise is provide as well."
  },
  {
    "objectID": "analog_circuit_design.html#mosfet-diode-large-signal-behavior",
    "href": "analog_circuit_design.html#mosfet-diode-large-signal-behavior",
    "title": "Analog Circuit Design",
    "section": "4.2 MOSFET Diode Large-Signal Behavior",
    "text": "4.2 MOSFET Diode Large-Signal Behavior\nAs discussed above, the MOSFET diode configuration is essentially a feedback loop. Before we will analyze this loop in small-signal, we want to investigate how this loop settles in the time domain, and by doing this we can observe the large-signal settling behavior. To simulate this, we change the dc bias source from the previous example to a transient current source, which we will turn on after some picoseconds. The resulting Xschem testbench is shown in Figure 12.\n\n\n\n\n\n\nFigure 12: Testbench for MOSFET diode transient settling.\n\n\n\nWhen simulating the circuit in Figure 12 another interesting effect can be observed: While the turn-on happens quite rapidly (essentially the bias current source charges the gate capacitance, until the gate-source voltage is large enough that the drain current counteracts the bias current), the turn-off shows a very long settling tail. This is due to the fact that as the gate capacitance is discharged by the drain current, the \\(V_\\mathrm{GS}\\) drops, which in turn reduces the drain current, which will make the discharge even slower. We have an effect similar to a capacitor discharge by a diode (Hellen 2003).\n\n\n\n\n\n\nPower-Down Switches\n\n\n\nIt is thus generally a good idea to add power-down switches to the circuits to disable the circuit quickly by pulling floating nodes to a defined potential (usually \\(V_\\mathrm{DD}\\) or \\(V_\\mathrm{SS}\\)) and to avoid long intermediate states during power down. This will also allow a turn-on from a well-defined off-state.\n\n\nExemplary implementations of power-down switches are shown in the Xschem implementation of the improved OTA in Figure 42. Which \\(W/L\\) ratio should these transistors have? Well, in general, switches often have minimum length to be fast and to have low \\(R_\\mathrm{on}\\). However, if there are no critical specifications (e.g., like power-down time), then these transistors are often used as dummy transistors for other circuit parts and are sized to fit the layout best."
  },
  {
    "objectID": "analog_circuit_design.html#mosfet-diode-small-signal-analysis",
    "href": "analog_circuit_design.html#mosfet-diode-small-signal-analysis",
    "title": "Analog Circuit Design",
    "section": "4.3 MOSFET Diode Small-Signal Analysis",
    "text": "4.3 MOSFET Diode Small-Signal Analysis\nWe now want to investigate the small-signal behavior of the MOSFET diode. Based on the small-signal model of the MOSFET in Figure 5 we realize that gate and drain are shorted, and we also connect bulk to source. We can thus simplify the circuit to the one shown in Figure 13.\n\n\n\n\n\n\n\n\nFigure 13: The MOSFET diode small-signal model (drain and gate are shorted, as well as source and bulk).\n\n\n\n\n\n\n\n\n\n\n\nGround Node Selection\n\n\n\nFor small-signal analysis we would not need to declare one node as the ground potential. However, when doing so, and selecting the ground node strategically, we can simplify the analysis, as we usually do not formulate KCL for the ground node (as we have only \\(N-1\\) independent KCL equations, \\(N\\) being the number of nodes in the circuit), and the potential difference equations are simpler if one node is at \\(0\\,V\\).\n\n\nFor calculating the small-signal impedance of the MOSFET diode we formulate Kirchhoff’s current law (KCL, also Kirchhoff’s first law or Kirchhoff’s junction rule) at the top node to get \\[\ni_\\mathrm{bias} - s C_\\mathrm{gs}v_\\mathrm{gs}- g_\\mathrm{m}v_\\mathrm{gs}- g_\\mathrm{ds}v_\\mathrm{gs}= 0.\n\\]\nIt follows that \\[\nZ_\\mathrm{diode}(s) = \\frac{v_\\mathrm{gs}}{i_\\mathrm{bias}} = \\frac{1}{g_\\mathrm{m}+ g_\\mathrm{ds}+ s C_\\mathrm{gs}}.\n\\tag{5}\\]\nWhen neglecting \\(g_\\mathrm{ds}\\), at dc we get \\(Z_\\mathrm{diode} = 1 / g_\\mathrm{m}\\), which is an important result and should be memorized.\n\n\n\n\n\n\nThe Admittance is Your Friend\n\n\n\nIn circuit analysis it is often algebraically easier to work with admittance instead of impedance, so please remember that Ohm’s law for a conductance is \\(I = G \\cdot V\\), and for a capacitance is \\(I = s C \\cdot V\\). When writing equations, it is also practical to keep \\(s C\\) together, so we will strive to sort terms accordingly.\n\n\nLooking at Equation 5 we see that for low frequencies, the diode impedance is resistive, and for high frequencies it becomes capacitive as the gate-source capacitance starts to dominate. The corner frequency of this low-pass can be calculated as \\[\n\\omega_\\mathrm{c} = \\frac{g_\\mathrm{m}+ g_\\mathrm{ds}}{C_\\mathrm{gs}} \\approx \\omega_\\mathrm{T}\n\\] which is pretty much the transit frequency of the MOSFET!"
  },
  {
    "objectID": "analog_circuit_design.html#mosfet-diode-stability-analysis",
    "href": "analog_circuit_design.html#mosfet-diode-stability-analysis",
    "title": "Analog Circuit Design",
    "section": "4.4 MOSFET Diode Stability Analysis",
    "text": "4.4 MOSFET Diode Stability Analysis\n\n\n\n\n\n\nOpen-Loop Gain, Closed-Loop Gain, and Loop-Gain—A Short Recap\n\n\n\nFigure 14 shows a negative feedback system with input \\(X(s)\\) and output \\(Y(s)\\), where \\(H_\\mathrm{ol}(s)\\) is the transfer function of the feed-forward path (also called open-loop gain) and \\(G(s)\\) is the transfer function of the feedback network. The loop-gain is the product of both transfer functions \\(T(s) = H_\\mathrm{ol}(s) G(s)\\) and is used for the stability analysis. The closed-loop gain is defined as \\(H_\\mathrm{cl}(s) = Y(s) / X(s)\\) can be derived with \\(Y(s) = H_\\mathrm{ol}(s) [X(s) - Y(s) G(s)]\\) to be \\[\nH_\\mathrm{cl}(s) = \\frac{Y(s)}{X(s)} = \\frac{H_\\mathrm{ol}(s)}{1 + H_\\mathrm{ol}(s) G(s)} = \\frac{H_\\mathrm{ol}(s)}{1 + T(s)}\n\\tag{6}\\]\nIf the open-loop gain is sufficiently large \\(H_\\mathrm{ol}(s) \\gg 1\\), then the closed-loop gain simplifies to \\(H_\\mathrm{cl}(s) \\approx 1 / G(s)\\). This result is convenient, since it is independent of \\(H_\\mathrm{ol}(s)\\). Therefore, the overall gain is only set with the feedback gain \\(G(s)\\) in operational amplifier circuits.\nIn the case of the MOSFET diode, \\(G(s) = 1\\) and therefore \\(T(s) = H_\\mathrm{ol}(s)\\) and \\(H_\\mathrm{cl}(s) \\approx 1\\). Therefore, this chapter uses open-loop gain and loop-gain as synonyms.\n\n\n\n\n\n\n\n\nFigure 14: The block diagram of a negative feedback system.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGain-Bandwidth Product in Feedback Systems\n\n\n\nThe gain-bandwidth product (GBP or GBWP) or transit frequency \\(f_\\mathrm{T}\\) of a first-order open-loop system is the product of the open-loop dc gain \\(H_\\mathrm{ol,dc} = H_\\mathrm{ol}(f = 0\\,\\text{Hz})\\) and the open-loop \\(-3\\,\\text{dB}\\) cut-off frequency \\(f_\\mathrm{c,ol}\\) of \\(H_\\mathrm{ol}(s)\\). \\[\n\\text{GBWP} = f_\\mathrm{T,ol} = H_\\mathrm{ol,dc} f_\\mathrm{c,ol}\n\\]\nIf a frequency-independent negative feedback \\(G\\) (e.g., a resistive divider) is applied to this open-loop system, the transit frequency changes to \\[\nf_\\mathrm{T,cl} = f_\\mathrm{T,ol} \\sqrt{1 - G^2}\n\\] Hence, the closed-loop transit frequency is slightly lower than the open-loop transit frequency \\(f_\\mathrm{T,cl} &lt; f_\\mathrm{T,ol}\\).\nThe closed-loop \\(-3\\,\\text{dB}\\) cut-off frequency \\(f_\\mathrm{c,cl}\\) can then be calculated from the open-loop transit frequency and the feedback gain. \\[\nf_\\mathrm{c,cl} = H_\\mathrm{ol,DC} f_\\mathrm{c,ol} G = f_\\mathrm{T,ol} G\n\\]\nThis theory might be interesting when Middlebrook’s and Tian’s methods for loop gain analysis are later compared in the MOSFET diode testbench (see Figure 16).\n\n\nThe diode-connected MOSFET forms a feedback loop. What is the open-loop gain? For calculating it, we are breaking the loop, and apply a dummy \\(C_\\mathrm{gs}^{*}\\) at the right side to keep the impedances correct. A circuit diagram is shown in Figure 15, we break the loop at the dotted connection. As we can see in this example, it is critically important when breaking up a loop for analysis (also for simulation!) to keep the terminal impedances the same. Only in special cases where the load impedance is very high or the driving impedance is very low is it acceptable to disregard loading effects!\n\n\n\n\n\n\n\n\nFigure 15: The MOSFET diode small-signal circuit for open-loop analysis.\n\n\n\n\n\nWe are now driving (with a voltage source) \\(v_\\mathrm{in}\\) and record the output voltage \\(v_\\mathrm{out}\\) to find the open-loop response \\(H_\\mathrm{ol}(s)\\). By inspecting Figure 15 we see that \\[\nv_\\mathrm{out} = - g_\\mathrm{m}v_\\mathrm{in} \\frac{1}{g_\\mathrm{ds}+ s C_\\mathrm{gs}}.\n\\]\nThe open-loop gain \\(H_\\mathrm{ol}(s)\\) is thus \\[\nH_\\mathrm{ol}(s) = \\frac{v_\\mathrm{out}}{v_\\mathrm{in}} = -\\frac{g_\\mathrm{m}}{g_\\mathrm{ds}+ s C_\\mathrm{gs}} = - \\frac{g_\\mathrm{m}}{g_\\mathrm{ds}} \\frac{1}{1 + s \\frac{C_\\mathrm{gs}}{g_\\mathrm{ds}}}.\n\\tag{7}\\]\nInspecting Equation 7 we realize that:\n\nThe dc gain \\(g_\\mathrm{m}/ g_\\mathrm{ds}\\) is the self-gain of the MOSFET, so \\(20 \\log_{10}(0.2 \\cdot 10^{-3} / 9.6 \\cdot 10 ^{-6}) = 26.4\\,\\text{dB}\\).\nThere is a pole at \\(\\omega_\\mathrm{p} = -g_\\mathrm{ds}/ C_\\mathrm{gs}\\), which is at \\(9.6 \\cdot 10 ^{-6} / (2 \\pi \\cdot 1.4 \\cdot 10^{-15}) = 1.1\\,\\text{GHz}\\).\n\nWith this single pole location in \\(H_\\mathrm{ol}(s)\\) this loop is perfectly stable at under all conditions (remember that a single pole results in a maximum phase shift of –90\\(^\\circ\\)).\nThe question is now how to simulate this open-loop gain, i.e., how to break the loop open in simulation? In general there are various methods, as we can use artificially large (ideal) inductors and capacitors to break loops open and still establish the correct dc operating points for the ac loop analysis. This is called Rosenstark’s method (Rosenstark 1984). However, mimicking the correct loading can be an issue, and requires a lot of careful consideration.\nThere is an alternative method which breaks the loop open only by adding an ac voltage source in series (thus keeps the dc operating point intact), or injects current using an ac current source. Based on both measurements the open-loop gain can be calculated. This is called Middlebrook’s method (Middlebrook 1975) and is based on double injection, and we will use it for our loop simulations. This method is detailed in Section 15.\nThere are several other methods like Tian’s method (Tian et al. 2001), for example. A comprehensive overview can be found in (Neag et al. 2015) which describes ten different simulation-based loop gain analysis methods.\nWe now want to simulate the open-loop transfer function \\(H_\\mathrm{ol}(s)\\) by using Middlebrook’s method and confirm our analysis above.\n\n\n\n\n\n\nExercise: MOSFET Diode Loop Analysis\n\n\n\nPlease build a simulation testbench in Xschem to simulate the open-loop transfer function of the MOSFET diode. Confirm the dc gain and pole location as given by Equation 7.\nIf you are getting stuck you can look at this Xschem testbench, shown in Figure 16.\n\n\n\n\n\n\nFigure 16: Testbench for MOSFET diode stability analysis.\n\n\n\n\n\nFrom simulation we see that the open-loop gain is \\(24.9\\,\\text{dB}\\) at low frequencies, which matches quite well our prediction of \\(26.4\\,\\text{dB}\\). In the Bode plot we see a low-pass with a \\(-3\\,\\text{dB}\\) corner frequency of \\(1.4\\,\\text{GHz}\\), which again is fairly close to our prediction of \\(1.1\\,\\text{GHz}\\).\n\n\n\n\n\n\nWhat About Large-Signal Stability?\n\n\n\nKeep in mind that the above simulation only verifies the small-signal stability in one certain operating point. If we later look at the stability of an OTA it might be a good idea to verify the small-signal stability in different operating points.\nFurthermore, one can apply a step response to the closed-loop system input and estimate the phase margin from the overshoot at the output (see “Automatic Control” lecture). One could also use a step-wise step response to simulate different operating points for a certain time (see “Introduction in Integrated Circuit Design” lecture)."
  },
  {
    "objectID": "analog_circuit_design.html#mosfet-diode-noise-calculation",
    "href": "analog_circuit_design.html#mosfet-diode-noise-calculation",
    "title": "Analog Circuit Design",
    "section": "4.5 MOSFET Diode Noise Calculation",
    "text": "4.5 MOSFET Diode Noise Calculation\nAs a final exercise on the MOSFET diode circuit we want to calculate the output noise when we consider \\(V_\\mathrm{GS}\\) the output reference voltage which is created when passing a bias current through the MOSFET diode. The bias current we will assume noiseless.\nWe are going to use the small-signal circuit shown in Figure 17.\n\n\n\n\n\n\n\n\nFigure 17: The MOSFET diode small-signal model with drain noise source.\n\n\n\n\n\nAs we have already calculated the small-signal diode impedance in Equation 5 we will use this result, and just note that the drain current noise of the MOSFET flows through this impedance. The noise voltage at \\(v_\\mathrm{gs}\\) is thus given as \\[\n\\overline{V_\\mathrm{n}^2} = |Z_\\mathrm{diode}|^2 \\overline{I_\\mathrm{n,d}^2}.\n\\]\nThe drain current noise of the MOSFET is given as (introduced in Section 2.1.2) \\[\n\\overline{I_\\mathrm{n,d}^2} = 4 k T \\gamma g_\\mathrm{m}.\n\\]\nFor low frequencies (ignoring \\(g_\\mathrm{ds}\\) and \\(C_\\mathrm{gs}\\)) we get \\[\n\\overline{V_\\mathrm{n}^2} = |Z_\\mathrm{diode}|^2 \\overline{I_\\mathrm{n,d}^2} = \\frac{1}{g_\\mathrm{m}^2} 4 k T \\gamma g_\\mathrm{m}= \\frac{4 k T \\gamma}{g_\\mathrm{m}}\n\\] which is the thermal noise of a resistor of value \\(1 / g_\\mathrm{m}\\) enhanced by the factor \\(\\gamma\\).\nWe now calculate the full equation, and after a bit of algebra arrive at \\[\n\\overline{V_\\mathrm{n}^2}(f) = \\frac{4 k T \\gamma g_\\mathrm{m}}{(g_\\mathrm{m}+ g_\\mathrm{ds})^2 + (2 \\pi f C_\\mathrm{gs})^2}.\n\\tag{8}\\]\nIf we are interested in the PSD of the noise then Equation 8 gives us the result. If we are interested in the rms value (the total noise) we need to integrate this equation, using the following identity:\n\n\n\n\n\n\nUseful Integral for Noise Calculations\n\n\n\n\\[\n\\int_0^\\infty {\\frac{a}{b^2 + c^2 f^2} df} = \\frac{\\pi}{2} \\frac{a}{b \\cdot c}\n\\tag{9}\\]\n\n\nUsing the integral help in Equation 9, we can easily transform Equation 8 to \\[\nV_\\mathrm{n,rms}^2 = \\int_0^\\infty \\overline{V_\\mathrm{n}^2}(f) df = \\frac{k T \\gamma g_\\mathrm{m}}{(g_\\mathrm{m}+ g_\\mathrm{ds}) C_\\mathrm{gs}}.\n\\tag{10}\\]\nThe form of Equation 10 is the exact solution, but we gain additional insight if we assume that \\(g_\\mathrm{m}+ g_\\mathrm{ds}\\approx g_\\mathrm{m}\\) and then \\[\nV_\\mathrm{n,rms}^2 = \\frac{k T \\gamma}{C_\\mathrm{gs}}.\n\\tag{11}\\]\nInspecting Equation 11 we see our familiar \\(kT/C\\) noise multiplied by the factor \\(\\gamma\\)!\n\n\n\n\n\n\nExercise: Total Output Noise of RC-Lowpass\n\n\n\nIf you have never calculated this before then you should work through the following: Calculate the total output noise of an \\(RC\\)-lowpass filter. Formulate the transfer function in the Laplace domain, and put the eqivalent resistor noise voltage source at the input, calculate the transfer to the output, and then integrate the output PSD (like we did for the MOSFET diode noise).\nYou fill find that the output noise is \\[\nV_\\mathrm{n,rms}^2 = \\frac{k T}{C}\n\\] which is independent of \\(R\\)! This is a surprising result, and is the well-known \\(kT/C\\) noise. Intuitively, we could argue that the noise increases with larger \\(R\\), but at the same time, the bandwidth decreases and therefore \\(R\\) does not add additional noise.\nSide note: The shortest derivation of this formula involves the equipartition theorem: Any system in thermal equilibrium has an energy of \\(kT/2\\) per degree of freedom. This \\(RC\\) system has one degree of freedom in the capacitor, and the stored energy in the capacitor is \\(CV_\\mathrm{rms}^2/2\\). Equating both energies we find that \\(V_\\mathrm{rms}^2 = kT/C\\).\nTo calculate the total output noise of a generalized passive network Bode’s noise theorem is quite practical (see Section 16.2).\n\n\nCalculating the rms noise voltage for our MOSFET diode we get \\[\n\\sqrt{V_\\mathrm{n,rms}^2} = \\sqrt{1.38 \\cdot 10^{-23} \\cdot 300 \\cdot 0.84 / 1.4 \\cdot 10^{-15}} = 1.58\\,\\text{mV},\n\\] which is a sizeable value! Think about it, can this rms noise voltage be measured with an oscilloscope? If not, why? We run circuits in this technology at \\(V_\\mathrm{DD}= 1.5\\,\\mathrm{V}\\), which leaves us with a signal swing of ca. \\(1.1\\,\\mathrm{V_{pp}}\\) (single-ended), resulting in a dynamic range in this case of \\(20 \\log_{10} (0.39 / 1.58 \\cdot 10^{-3}) \\approx 48\\,\\text{dB}\\) assuming a sinusoidal signal. In order to get a feeling which dynamic range is “good”, we can calculate the required dynamic range of a 16-bit audio ADC to be \\(6.02 \\cdot 16 + 1.76\\,\\text{dB} = 98.08\\,\\text{dB} \\approx 100\\,\\text{dB}\\). This calculation should make clear that, for example, the correct sizing of the sample&hold capacitor is crucial for low rms noise voltage.\n\n\n\n\n\n\nBe Careful with Parasitic Capacitances in IC Design\n\n\n\nIn general, in integrated circuit design, we often have only small parasitic capacitances on many nodes that could sum up to unwanted high noise according to Equation 11. If one wants to lower the noise an increased capacitance could limit the bandwidth (and thus the \\(kT/C\\) noise).\n\n\n\n\n\n\n\n\nLarge Bandwidth and Noise\n\n\n\nRemember: Large bandwidth circuits integrate noise over a wide bandwidth resulting in (potentially) considerable rms noise. The way to lower the total noise is to lower the PSD of the noise contributions, which usually requires increased power consumption. So in a nutshell:\nLarge bandwidth plus small noise equals large power consumption.\n\n\n\n\n\n\n\n\nExercise: MOSFET Diode Noise\n\n\n\nPlease build a simulation testbench in Xschem to simulate the noise performance of the MOSFET diode, and confirm the rms noise value that we just calculated. Look at the rms value and the PSD of the noise, and play around with the integration limits. What is the effect? Can you see the flicker noise in the PSD? How much is its contribution to the rms noise? What is the value of \\(f_\\mathrm{co}\\), and does it correspond to the above calculated one?\nIf you are getting stuck you can look at this Xschem testbench, shown in Figure 18.\n\n\n\n\n\n\nFigure 18: Testbench for MOSFET diode noise analysis."
  },
  {
    "objectID": "analog_circuit_design.html#conclusion-1",
    "href": "analog_circuit_design.html#conclusion-1",
    "title": "Analog Circuit Design",
    "section": "4.6 Conclusion",
    "text": "4.6 Conclusion\nIn this section we investigated the simple MOSFET-diode circuit. We learned important skills like how to derive a small-signal model and how to calculate important features like noise and open-loop gain for stability analysis. We introduced Middlebrook’s method to have a mechanism to open up loops in simulation (and calculation) without disturbing dc operating points or introduce errors by changing loading conditions.\nIf you feel that you have not yet mastered these topics or are uncertain in the operation of Xschem or ngspice, please go back to the beginning of the section and read through the theory and redo the exercises."
  },
  {
    "objectID": "analog_circuit_design.html#sense-amplifier-driving-50-ohm-matched-load",
    "href": "analog_circuit_design.html#sense-amplifier-driving-50-ohm-matched-load",
    "title": "Analog Circuit Design",
    "section": "5.1 Sense Amplifier Driving 50 Ohm Matched Load",
    "text": "5.1 Sense Amplifier Driving 50 Ohm Matched Load\nLet us now size and design an exemplary implementation of this amplifier (of course using the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) method). In order to have useful real-life specifications, we want to build an amplifier which can be used to sense an on-chip voltage and drive off-chip measurement equipment. Often, this equipment has an input impedance of 50\\(\\Omega\\), and we want to have an impedance-matched output. The voltage gain shall be set to 1 (essentially, we want to sense a voltage and drive the measurement equipment).\nThe resulting circuit is shown in Figure 20. As the load is usually ground-referred, and we want to avoid a dc-block at the output, we use a PMOS amplifier stage (compare with Figure 19).\n\n\n\n\n\n\n\n\nFigure 20: A MOSFET common-source amplifier with 50 Ohm load.\n\n\n\n\n\n\n\n\n\n\n\nExercise: PMOS-Based Measurement Amplifier\n\n\n\nPlease think about why exactly we want this measurement amplifier be based on a PMOS instead of an NMOS.\n\n\nThe power matching requirement at the output mandates that \\(R_1 = R_\\mathrm{load}\\), so \\(R'_1 = R_\\mathrm{load} \\parallel R_1 = 25\\,\\Omega\\). The voltage gain requirement of \\(|A_\\mathrm{v}| = 1\\) results in \\(g_\\mathrm{m}= 1 / R'_1 = 40\\,\\text{mS}\\).\nWe now need to find \\(W\\) and \\(L\\) of \\(M_1\\) and calculate the required bias current \\(I_\\mathrm{D}\\). We also need to find the proper \\(V_\\mathrm{GS}\\) to set this current. As usual, we use a Jupyter notebook to calculate these values. Since we require modest speed of this buffer we use a \\(g_\\mathrm{m}/I_\\mathrm{D}=8\\) and set \\(L = 0.13\\,\\mu\\text{m}\\). The notebook is available here. The resulting circuit including all component values is shown at the end of the notebook (the red input capacitor shows the \\(C_\\mathrm{gg}\\) of the MOSFET).\n\n\n\n\n\n\nImportant 1: MOSFET Parameters NG and M\n\n\n\nWhen sizing the MOSFET for this example we found that we need a fairly large \\(W\\), resulting in a MOSFET aspect ratio of \\(W/L \\gg 1000\\). When constructing an integrated circuit out of individual MOSFET we strive for an overall IC dimension that is roughly quadratic. For MOSFET with large aspect ratios we need to get them into a comfortable shape.\nIn order to achieve this, we construct the MOSFET out of smaller pieces, and the size of this pieces (called “gate fingers”) are controlled by the parameter ng. These MOSFET gate fingers all have the same \\(L\\), but their width is \\(W_\\mathrm{finger} = W / \\text{ng}\\). All this individual smaller MOSFET are connected in parallel.\nIn order to increase the MOSFET model accuracy, often the maximum value of \\(W_\\mathrm{finger}\\) is limited. In the case of SG13G2 \\(W_\\mathrm{finger} \\le 10\\,\\mu\\text{m}\\).\nIn order to construct even larger MOSFET, we can connect multiple MOSFET in parallel. We can do this in the circuit editor by placing and connected these MOSFET; but since this is often used there is a more convenient way: By using the parameter m (“multiplier” or “multiplicity”) we instantiate \\(m\\) MOSFET connected in parallel.\nWhen to use ng and when to use m? The use of ng results in a more compact IC layout, and is thus generally preferable. Only in certain instances (e.g., when using a really large \\(W\\)) m should be used. Further, the thoughtful use of ng allows to construct all the NMOS and PMOS of a circuit out of the same gate finger elements. This will result in a very compact layout!\n\n\n\n\n\n\n\n\nExercise: Measurement Amplifier Simulation\n\n\n\nPlease go through the sizing notebook of the measurement amplifier and double-check the calculations. Do you agree that the calculations are correct?\nOnce you agree with the circuit sizing please build an Xschem simulation testbench where you simulate the small-signal voltage gain \\(A_\\mathrm{v}\\) of this measurement amplifier if it is driven with an ideal voltage source. Keep in mind that the maximum MOSFET finger width is 10µm in this technology, so you need to set the parameter ng accordingly (see Important 1).\n\nWhat is the dc gain of this amplifier when loaded with 50\\(\\Omega\\)?\nThe dc gain is likely not exactly 0dB. Why is this so?\nIncrease the width \\(W\\) of the PMOS until the gain is correct. What is the \\(W\\) that you had to set, and how much is \\(I_\\mathrm{D}\\) now?\nWhat is the bandwidth (i.e., the -3dB corner frequency) of the output voltage, when the voltage source has a source resistance of 1k\\(\\Omega\\)?\n\nIf you get stuck, here is the solution to this exercise, and it is also shown in Figure 21.\n\n\n\n\n\n\nFigure 21: Simulation schematic of the common-source measurement amplifier.\n\n\n\n\n\nBy now we have designed a measurement amplifier based on a common-source stage. One problem with this stage is the relatively large input capacitance \\(C_\\mathrm{GG}\\) of approx. 0.3pF, which loads the input source. Another issue even more severe is that the fact that the bias point in this circuit is set by the dc voltage level at the input. In general, we want a setup where the bias points of the circuit are largely independent of the dc input voltages. This is why in integrated circuit design we often design differential circuits where the input and output signals are given by the differential voltages, and are largely independent from the common-mode voltages. This is usually an advantage."
  },
  {
    "objectID": "analog_circuit_design.html#differential-operation-of-the-diffpair",
    "href": "analog_circuit_design.html#differential-operation-of-the-diffpair",
    "title": "Analog Circuit Design",
    "section": "7.1 Differential Operation of the Diffpair",
    "text": "7.1 Differential Operation of the Diffpair\nFor a differential mode of operation we assume that the input common mode voltage is constant, i.e., \\((V_\\mathrm{in,p} + V_\\mathrm{in,n})/2 = V_\\mathrm{CM}\\). The differential input voltage \\(v_\\mathrm{in} = V_\\mathrm{in,p} - V_\\mathrm{in,n}\\), so that \\[\nV_\\mathrm{in,p} = V_\\mathrm{CM} + \\frac{v_\\mathrm{in}}{2}\n\\] and \\[\nV_\\mathrm{in,n} = V_\\mathrm{CM} - \\frac{v_\\mathrm{in}}{2}.\n\\]\nFor a small-signal differential drive the potential at the tail point stays constant and we can treat it as a virtual ground. The output current on each side is then given by (neglecting \\(g_\\mathrm{ds}\\) and \\(g_\\mathrm{mb}\\) of \\(M_1\\) and \\(M_2\\)) \\[\ni_\\mathrm{out,p} = g_\\mathrm{m1} \\left( \\frac{v_\\mathrm{in}}{2} \\right)\n\\] and \\[\ni_\\mathrm{out,n} = g_\\mathrm{m2} \\left( -\\frac{v_\\mathrm{in}}{2} \\right).\n\\]\nUsually we assume symmetry in the differential pair, so \\(g_\\mathrm{m1} = g_\\mathrm{m2} = g_\\mathrm{m}\\). The differential output current \\(i_\\mathrm{out}\\) is then given by \\[\ni_\\mathrm{out} = i_\\mathrm{out,p} - i_\\mathrm{out,n} = g_\\mathrm{m}v_\\mathrm{in}\n\\tag{12}\\]\nWe see in Equation 12 that the differential output current is simply the differential input voltage multiplied by the \\(g_\\mathrm{m}\\) of the individual transistor. We also note that the bottom conductance \\(g_\\mathrm{tail}\\) plays no role for the small-signal differential operation."
  },
  {
    "objectID": "analog_circuit_design.html#common-mode-operation-of-the-diffpair",
    "href": "analog_circuit_design.html#common-mode-operation-of-the-diffpair",
    "title": "Analog Circuit Design",
    "section": "7.2 Common-Mode Operation of the Diffpair",
    "text": "7.2 Common-Mode Operation of the Diffpair\nUsually, the source conductance \\(g_\\mathrm{tail}\\) is realized by a current source and ideally should be \\(g_\\mathrm{tail} = 0\\). If this is the case, then the output currents are not a function of the common-mode input voltage (\\(I_\\mathrm{tail}\\) is set by the tail current source), and \\[\nI_\\mathrm{out,p} = I_\\mathrm{out,n} = \\frac{I_\\mathrm{tail}}{2}.\n\\]\nHowever, if we assume a realistic tail current source then \\(g_\\mathrm{tail} &gt; 0\\). For analysis we can simply look at a half circuit since the circuit operation is symmetric. In order to simplify the analysis a bit we remove all capacitors from the MOSFET small-signal model and set \\(g_\\mathrm{ds}= g_\\mathrm{mb}= 0\\). We then arrive at the small-signal equivalent circuit shown in Figure 24 (note that we set \\(v_\\mathrm{in,p} = v_\\mathrm{in,n} = v_\\mathrm{in}\\) and \\(i_\\mathrm{out,p} = i_\\mathrm{out,n} = i_\\mathrm{out}\\) under symmetry considerations).\n\n\n\n\n\n\n\n\nFigure 24: Small-signal model of the differential pair half-circuit in common-mode operation.\n\n\n\n\n\nFormulating KVL for the input-side loop we get \\[\nv_\\mathrm{in} = v_\\mathrm{gs}+ \\frac{i_\\mathrm{d}}{g_\\mathrm{tail}}.\n\\]\nWith \\(i_\\mathrm{out} = i_\\mathrm{d}= g_\\mathrm{m}v_\\mathrm{gs}\\) we arrive at \\[\ni_\\mathrm{out} = \\frac{g_\\mathrm{m}g_\\mathrm{tail}}{g_\\mathrm{m}+ g_\\mathrm{tail}} v_\\mathrm{in}\n\\tag{13}\\]\nInterpreting Equation 13 we can distinguish the following extreme cases:\n\nIf \\(g_\\mathrm{tail} = 0\\) (ideal tail current source) then \\(i_\\mathrm{out} = 0\\), the common-mode voltage variation from the input is suppressed and does not show up at the common-mode output current (which is constant due to the ideal tail current source). This is usually the case that we want to achieve.\nIf \\(g_\\mathrm{tail} \\rightarrow \\infty\\) then \\(i_\\mathrm{out} = g_\\mathrm{m}v_\\mathrm{in}\\), which means the output current is a function of the MOSFET \\(g_\\mathrm{m}\\). If everything is perfectly matched, then the differential output current is zero, but the common-mode output current changes according to the common-mode input voltage. In special cases this can be a wanted behavior, this configuration is called a “pseudo-differential pair.”\n\nNote that the result of Equation 13 is also valid for the general case of a degenerated common-source transistor stage (see Figure 25). The effective transconductange \\(g_\\mathrm{m}'\\) is given by (\\(R_\\mathrm{degen} = g_\\mathrm{tail}^{-1}\\))\n\\[\ng_\\mathrm{m}' = \\frac{i_\\mathrm{out}}{v_\\mathrm{in}} = \\frac{g_\\mathrm{m}g_\\mathrm{tail}}{g_\\mathrm{m}+ g_\\mathrm{tail}} = \\frac{1}{g_\\mathrm{m}^{-1} + R_\\mathrm{degen}}.\n\\]\nWhen no degeneration resistor is used, then \\(g_\\mathrm{m}' = g_\\mathrm{m}\\). If a degeneration of \\(R_\\mathrm{degen} \\gg g_\\mathrm{m}^{-1}\\) is used then \\(g_\\mathrm{m}' = 1 / R_\\mathrm{degen}\\). This result is worth memorizing.\n\n\n\n\n\n\n\n\nFigure 25: A MOSFET common-source amplifier with resistive degeneration."
  },
  {
    "objectID": "analog_circuit_design.html#sec-voltage-buffer-with-ota",
    "href": "analog_circuit_design.html#sec-voltage-buffer-with-ota",
    "title": "Analog Circuit Design",
    "section": "8.1 Voltage Buffer with OTA",
    "text": "8.1 Voltage Buffer with OTA\nIn order to design an OTA we need an application, and from this we need to derive the circuit specifications. We want to use this OTA to realize a voltage buffer which lightly loads an input voltage source and can drive a large capacitive load. Such a configuration is often used to, e.g., buffer a reference voltage that is needed (and thus loaded) by another circuit. The block diagram of this configuration is shown in Figure 27.\n\n\n\n\n\n\n\n\nFigure 27: A voltage buffer (based on OTA) driving a capacitive load.\n\n\n\n\n\nIf the voltage gain of the OTA in Figure 27 is high, then \\(V_\\mathrm{out} \\approx V_\\mathrm{in}\\). We now want to design an OTA for this application fitting the following specification values (see Table 2). These values are rather typical of what could be expected for such a buffer design.\n\n\n\nTable 2: Voltage buffer specification\n\n\n\n\n\n\n\n\n\n\nSpecification\nValue\nUnit\n\n\n\n\nSupply voltage\n\\(1.45 &lt; \\underline{1.5} &lt; 1.55\\)\nV\n\n\nTemperature range (industrial)\n\\(-40 &lt; \\underline{27} &lt; 125\\)\ndegC\n\n\nLoad capacitance \\(C_\\mathrm{load}\\)\n\\(50\\)\nfF\n\n\nInput voltage range (for buffering 2/3 bandgap voltage)\n\\(0.7 &lt; \\underline{0.8} &lt; 0.9\\)\nV\n\n\nSignal bandwidth (3dB)\n\\(&gt;10\\)\nMHz\n\n\nOutput voltage error\n\\(&lt;3\\)\n%\n\n\nTotal output noise (rms)\n\\(&lt;1\\)\nmVrms\n\n\nSupply current (as low as possible)\n\\(&lt;10\\)\nµA\n\n\nStability\nstable for rated \\(C_\\mathrm{load}\\)\n\n\n\nTurn-on time (settled to with 1%)\n\\(&lt;10\\)\nµs\n\n\nExternally provided bias current (nominal)\n\\(20\\)\nµA"
  },
  {
    "objectID": "analog_circuit_design.html#sec-basic-ota-large-signal",
    "href": "analog_circuit_design.html#sec-basic-ota-large-signal",
    "title": "Analog Circuit Design",
    "section": "8.2 Large-Signal Analysis of the OTA",
    "text": "8.2 Large-Signal Analysis of the OTA\nThe first step when receiving a design task is to look at the specifications, and see whether they make sense. The detailed performance of the design will be the result of the circuit simulation, but before we step into sizing we need to do a few simple calculations to (a) do back-of-the-envelope gauging if the specification makes sense, and (b) use the derived analytical equations as guide for the sizing procedure.\nIn terms of large-signal operation, we will now check whether the input and output voltage range, as well as the settling time can be roughly met. Since we do not know yet the resulting \\(V_\\mathrm{GS}\\) of the transistors we use \\(0.6\\,\\text{V}\\) as an initial guess. If we run into issues with that guess we know how to later steer the sizing procedure.\n\nWhen the input is at its maximum of \\(0.9\\,\\text{V}\\), we see that we need to keep \\(M_1\\) in saturation. We can calculate that \\(V_\\mathrm{DS1} = V_\\mathrm{DD}- |V_\\mathrm{GS3}| + V_\\mathrm{GS1} - V_\\mathrm{in} = 1.45 - 0.6 + 0.6 - 0.9 = 0.55\\,\\text{V}\\), which leaves enough margin.\nWhen the input is at its minimum of \\(0.7\\,\\text{V}\\), we see that the \\(V_\\mathrm{DS5}\\) of \\(M_5\\) is calculated as \\(V_\\mathrm{DS5} = V_\\mathrm{in} - V_\\mathrm{GS1} = 0.7 - 0.6 = 0.1\\,\\text{V}\\), so this leaves little margin, but we can make \\(V_\\mathrm{GS1}\\) smaller, so it should work out.\nFor the output voltage, when the output voltage is on the high side, it leaves \\(|V_\\mathrm{DS4}| = V_\\mathrm{DD}- V_\\mathrm{out} = 1.45 - 0.9 = 0.55\\,\\text{V}\\), which is enough margin.\n\nIn summary, we think that we can make an NMOS-input OTA like the one in Figure 26 work for the required supply and input- and output-voltages. If this would not work out, we need to look for further options, like a PMOS-input OTA, or a NMOS/PMOS-input OTA.\nAnother large-signal specification item that we can quickly check is the settling time. Under slewing conditions, the complete bias current in the OTA is steered towards the output (try to understand why this is the case), so when the output capacitor is fully discharged, and we assume just a linear ramp due to constant-current charging of the output capacitor, the settling time is \\[\nT_\\mathrm{slew} \\approx \\frac{C_\\mathrm{load} V_\\mathrm{out}}{I_\\mathrm{tail}} = \\frac{50 \\cdot 10^{-15} \\cdot 1.3}{10 \\cdot 10^{-6}} = 6.5\\,\\text{ns}\n\\] so this leaves plenty of margin for additional slow-signal settling due to the limited bandwidth, as well as reducing the supply current.\nThe small-signal settling (assuming one pole at the bandwidth corner frequency) leads to an approximate settling time (1% error corresponds to \\(\\approx 5 \\tau\\)) of \\[\nT_\\mathrm{settle} \\approx \\frac{5}{2 \\pi f_\\mathrm{c}} = \\frac{5}{2 \\pi \\cdot 1 \\cdot 10^{6}} = 0.8\\,\\mu\\text{s}.\n\\] which also checks out."
  },
  {
    "objectID": "analog_circuit_design.html#sec-basic-ota-small-signal",
    "href": "analog_circuit_design.html#sec-basic-ota-small-signal",
    "title": "Analog Circuit Design",
    "section": "8.3 Small-Signal Analysis of the OTA",
    "text": "8.3 Small-Signal Analysis of the OTA\nIn order to size the OTA components we need to derive how the MOSFET parameters define the performance. The important small-signal metrics are\n\ndc voltage gain \\(A_0\\)\ngain-bandwidth product (GBW)\noutput noise\n\nThe specification for GBW is directly given in Table 2, while the dc gain we have to calculate from the voltage accuracy specification. For a voltage follower in the configuration shown in Figure 27 the voltage gain is given by \\[\n\\frac{V_\\mathrm{out}}{V_\\mathrm{in}} = \\frac{A_0}{1 + A_0}.\n\\tag{14}\\]\nSo in order to reach an output voltage accuracy of at least 3% we need a dc gain of \\(A_0 &gt; 30.2\\,\\text{dB}\\). To allow for process and temperature variation we need to add a bit of extra gain as margin.\n\n\n\n\n\n\nSmall-Signal vs. Large-Signal Operation\n\n\n\nIn order to get the correct dc voltage per the specification we require the large-signal gain calculated with Equation 14. However, calculating the large-signal gain of a circuit is quite involved (usually mandating the use of a large-signal nonlinear model for the used components), so we typically resort to do a simpler small-signal calculation instead, like in Section 8.3. We deliberately introduce this error, but we should not get confused about the difference between large- and small-signal operation!\n\n\n\n8.3.1 OTA Small-Signal Transfer Function\nIn order to derive the governing small-signal equations for the OTA we will make a few simplifications:\n\nWe will set \\(g_\\mathrm{mb}= 0\\) for all MOSFETs.\nWe will further set \\(C_\\mathrm{gd}= 0\\) for all MOSFETs except for \\(M_4\\) where we expect a Miller effect on this capacitor, and we could add its effect by increasing the capacitance at the gate node of \\(M_{3,4}\\) (for background please see Section 16.1). However, as this does not create a dominant pole in this circuit, we consider this a minor effect (see Equation 17). Thus, only \\(C_\\mathrm{gs34}\\) is considered at the gate node of the current mirror load.\nWe assume \\(g_\\mathrm{m}\\gg g_\\mathrm{ds}\\), so we set \\(g_\\mathrm{ds1} = g_\\mathrm{ds3} = 0\\).\nThe drain capacitance of \\(M_2\\) and \\(M_4\\), as well as the gate capacitance of \\(M_2\\) we can add to the load capacitance \\(C_\\mathrm{load}\\). Note that \\(C_\\mathrm{gs2}\\) can be added because of the feedback connection between the inverting input and the output. However, this is not shown in the small-signal equivalent circuits below, because we are interested in the open-loop transfer function.\n\nThe resulting small-signal equivalent circuit is shown in Figure 28.\n\n\n\n\n\n\nRefresh MOSFET Small-Signal Model\n\n\n\nPlease review the MOSFET small-signal equivalent model in Figure 5 at this point. For the PMOS just flip the model upside-down.\n\n\n\n\n\n\n\n\n\n\nFigure 28: 5-transistor OTA small-signal model.\n\n\n\n\n\nWe can further simplify the output side by recognizing that the impedance (when looking from the output down) is \\(g_\\mathrm{ds2}\\) in series with \\(g_\\mathrm{ds5} + g_\\mathrm{m12}\\). This is a valid simplification as we treat \\(M_1\\) as a common-gate stage when looking from the output, and since it is loaded by a low impedance of \\(g_\\mathrm{m34}^{-1}\\), we can approximate the impedance looking into the source of \\(M_1\\) with \\(g_\\mathrm{m12}^{-1}\\). With the approximation that \\(g_\\mathrm{m}\\gg g_\\mathrm{ds}\\) the parallel connection of \\(g_\\mathrm{m12}\\) and \\(g_\\mathrm{ds5}\\) is dominated by \\(g_\\mathrm{m12}\\) (\\(g_\\mathrm{m12} + g_\\mathrm{ds5} \\approx g_\\mathrm{m12}\\)) and its series connection with \\(g_\\mathrm{ds2}\\) (\\(g_\\mathrm{m12}^{-1} + g_\\mathrm{ds2}^{-1} \\approx g_\\mathrm{ds2}^{-1}\\)), resulting in the fact that we can ground the lower end of \\(g_\\mathrm{ds2}\\). You should probably stop here and read this paragraph again, slowly.\nTherefore, we can move \\(g_\\mathrm{ds2} + g_\\mathrm{ds4}\\) in parallel to \\(C_\\mathrm{load}\\). Further, assuming a differential drive with a virtual ground at the tailpoint we can remove \\(g_\\mathrm{ds5}\\). The current source \\(g_\\mathrm{m34} v_\\mathrm{gs34}\\) is replaced with the equivalent conductance \\(g_\\mathrm{m34}\\). All the previous steps result in the further simplified equivalent circuit shown in Figure 29.\n\n\n\n\n\n\n\n\nFigure 29: 5-transistor OTA small-signal model with further simplifications.\n\n\n\n\n\nIn the simplified circuit model in Figure 29 we can see that we have two poles in the circuit, one at the gate note of \\(M_{3,4}\\), and one at the output. Realizing that \\(v_\\mathrm{in,p} = v_\\mathrm{in}/2\\) and \\(v_\\mathrm{in,n} = - v_\\mathrm{in}/2\\) we can formulate KCL at the output node to \\[\n-g_\\mathrm{m34} V_\\mathrm{gs34} - \\left( -g_\\mathrm{m12} \\frac{V_\\mathrm{in}}{2} \\right) - V_\\mathrm{out} (g_\\mathrm{ds2} + g_\\mathrm{ds4} + s C_\\mathrm{load}) = 0.\n\\tag{15}\\] We further realize that \\[\nV_\\mathrm{gs34} = -g_\\mathrm{m12} \\frac{V_\\mathrm{in}}{2} \\frac{1}{g_\\mathrm{m34} + s C_\\mathrm{gs34}}.\n  \\tag{16}\\]\nBy combining Equation 15 and Equation 16 and after a bit of algebraic manipulation we arrive at \\[\nA(s) = \\frac{V_\\mathrm{out}(s)}{V_\\mathrm{in}(s)} = \\frac{g_\\mathrm{m12}}{2} \\frac{2 g_\\mathrm{m34} + s C_\\mathrm{gs34}}{(g_\\mathrm{m34} + s C_\\mathrm{gs34}) (g_\\mathrm{ds2} + g_\\mathrm{ds4} + s C_\\mathrm{load})}.\n\\tag{17}\\]\nWhen we now inspect Equation 17 we can see that for low frequencies the (open-loop) gain is \\[\nA(s \\rightarrow 0) = A_0 = \\frac{g_\\mathrm{m12}}{g_\\mathrm{ds2} + g_\\mathrm{ds4}}\n\\tag{18}\\] which is plausible, and confirms the requirement of a high impedance at the output node. For very large frequencies we get \\[\nA (s \\gg) = \\frac{g_\\mathrm{m12}}{2 s C_\\mathrm{load}}\n\\tag{19}\\] which is essentially the behavior of an integrator, and we can use Equation 19 to calculate the frequency where the gain drops to \\(|A(s_\\mathrm{ug})| = 1 = g_\\mathrm{m12}/|2 j \\omega_\\mathrm{ug} C_\\mathrm{load}|\\): \\[\nf_\\mathrm{ug} = \\frac{g_\\mathrm{m12}}{4 \\pi C_\\mathrm{load}}\n\\]\nWhen looking at Equation 17 we see that we have a dominant pole at \\(s_\\mathrm{p}\\) and a pole-zero doublet with \\(s_\\mathrm{pd}\\)/\\(s_\\mathrm{zd}\\): \\[\ns_\\mathrm{p} = -\\frac{g_\\mathrm{ds2} + g_\\mathrm{ds4}}{C_\\mathrm{load}}\n\\tag{20}\\] \\[\ns_\\mathrm{pd} = -\\frac{g_\\mathrm{m34}}{C_\\mathrm{gs34}}\n\\tag{21}\\] \\[\ns_\\mathrm{zd} = -\\frac{2 g_\\mathrm{m34}}{C_\\mathrm{gs34}}\n\\tag{22}\\]\n\n\n\n\n\n\nWhy a Pole-Zero Doublet?\n\n\n\nLooking at Equation 21 and Equation 22 we see that this pair is intimately linked by the same parameters and can only move together. Hence we call it a “doublet”. The effects of pole-zero doublets on the frequency response and settling time of OTAs can be found in (Kamath, Meyer, and Gray 1974). This paper shows that doublets may cause severe degradation of settling time while only causing minor changes in the frequency response of the amplifier.\n\n\n\n\n8.3.2 OTA Noise\nFor the noise analysis we ignore the pole-zero doublet due to \\(C_\\mathrm{gs34}\\) (we assume minor impact due to this) and just consider the dominant pole given by Equation 20. For the noise analysis at the output we set the input signal to zero, and thus we arrive at the simplified small-signal circuit shown in Figure 30.\n\n\n\n\n\n\n\n\nFigure 30: 5-transistor OTA small-signal model for noise calculation.\n\n\n\n\n\nWe see that \\[\n\\overline{V_\\mathrm{gs34}^2} = \\frac{1}{g_\\mathrm{m34}^2} \\left( \\overline{I_\\mathrm{n1}^2} + \\overline{I_\\mathrm{n3}^2} \\right).\n\\]\n\n\n\n\n\n\nNoise Addition\n\n\n\nRemember that uncorrelated noise quantities need to be power-summed (i.e., \\(I^2 = I_1^2 + I_2^2\\))!\n\n\nWe can then sum the output noise current \\(\\overline{I_\\mathrm{n}}\\) as \\[\n\\overline{I_\\mathrm{n}^2} = \\overline{I_\\mathrm{n2}^2} + \\overline{I_\\mathrm{n4}^2} + g_\\mathrm{m34}^2 \\frac{1}{g_\\mathrm{m34}^2} \\left( \\overline{I_\\mathrm{n1}^2} + \\overline{I_\\mathrm{n3}^2} \\right) = 2 \\left( \\overline{I_\\mathrm{n12}^2} + \\overline{I_\\mathrm{n34}^2} \\right).\n\\]\nAs a next step, let us rewrite the OTA transfer function \\(A(s)\\) (see Equation 17) by getting rid of the pole-zero doublet as a simplifying assumption to get \\[\nA'(s) = \\frac{g_\\mathrm{m12}}{g_\\mathrm{ds2} + g_\\mathrm{ds4} + s C_\\mathrm{load}}.\n\\tag{23}\\]\nInspecting Equation 23 we can interpret the OTA transfer function as a transconductor \\(g_\\mathrm{m12}\\) driving a load of \\(Y_\\mathrm{load} = g_\\mathrm{ds2} + g_\\mathrm{ds4} + s C_\\mathrm{load}\\). We can thus redraw Figure 27 in the following way, injecting the previously calculated noise current into the output node. The result is shown in Figure 32.\n\n\n\n\n\n\n\n\nFigure 31: Output impedance calculation of a voltage buffer.\n\n\n\n\n\n\n\n\n\n\n\nOutput Impedance of the Voltage Buffer\n\n\n\nFirst we short the input terminal to ground and then we connect a current source \\(I_\\mathrm{out}\\) at the output terminal, see Figure 31. Since we can neglect the gate leakage current into the inverting input terminal of the OTA, KCL at the output node is simply: \\[\nI_\\mathrm{out} + g_\\mathrm{m12}\\left(-V_\\mathrm{out}\\right) = 0\n\\] Thus, the output impedance is easily calculated. \\[\nZ_\\mathrm{out} = \\frac{V_\\mathrm{out}}{I_\\mathrm{out}} = \\frac{V_\\mathrm{out}}{g_\\mathrm{m12}V_\\mathrm{out}} = \\frac{1}{g_\\mathrm{m12}}\n\\]\n\n\n\n\n\n\n\n\n\n\nFigure 32: The voltage buffer redrawn for noise analysis.\n\n\n\n\n\nWe see that the feedback around the transconductor \\(g_\\mathrm{m12}\\) creates an impedance of \\(1/g_\\mathrm{m12}\\). We can now calculate the effective load conductance of \\[\nY'_\\mathrm{load} = g_\\mathrm{ds2} + g_\\mathrm{ds4} + s C_\\mathrm{load} + g_\\mathrm{m12} \\approx g_\\mathrm{m12} + s C_\\mathrm{load}.\n\\tag{24}\\]\nThe output noise voltage is then (using Equation 1) \\[\n\\overline{V_\\mathrm{n,out}^2}(f) = \\frac{\\overline{I_\\mathrm{n}^2}}{|Y'_\\mathrm{load}|^2} = \\frac{\\overline{I_\\mathrm{n}^2}}{g_\\mathrm{m12}^2 + (2 \\pi f C_\\mathrm{load})2^2} = \\frac{8 k T (\\gamma_{12} g_\\mathrm{m12} + \\gamma_{34} g_\\mathrm{m34})}{g_\\mathrm{m12}^2 + (2 \\pi f C_\\mathrm{load})^2}.\n\\]\nWe can use the identity Equation 9 to calculate the rms output noise to \\[\nV_\\mathrm{n,out,rms}^2 = \\int_0^\\infty \\overline{V_\\mathrm{n,out}^2}(f) df = \\frac{k T}{C_\\mathrm{load}} \\left( 2 \\gamma_{12} + 2 \\gamma_{34} \\frac{g_\\mathrm{m34}}{g_\\mathrm{m12}} \\right).\n\\tag{25}\\]\nInspecting Equation 25 we can see that the integrated output noise is the \\(k T / C\\) noise of the output load capacitor, enhanced by the \\(\\gamma_{12}\\) of the input differential pair, plus a (smaller) contribution of the current mirror load \\(M_{3,4}\\). Intuitively, this result makes sense.\n\n\n\n\n\n\nExercise: Derivation of 5T-OTA Performance\n\n\n\nPlease take your time and carefully go through the explanations and derivations for the 5-transistor-OTA in Section 8.2 and Section 8.3. Try to do the calculations yourself; if you get stuck, review the previous chapters."
  },
  {
    "objectID": "analog_circuit_design.html#sec-basic-ota-sizing",
    "href": "analog_circuit_design.html#sec-basic-ota-sizing",
    "title": "Analog Circuit Design",
    "section": "8.4 5T-OTA Sizing",
    "text": "8.4 5T-OTA Sizing\nOutfitted with the governing equations derived in Section 8.3 we can now size the MOSFETs in the OTA, we remember that we have to size \\(M_{1,2}\\) and \\(M_{3,4}\\) equally.\nFirst, we need to select a proper \\(g_\\mathrm{m}/I_\\mathrm{D}\\) for the MOSFET. Remembering Section 3 we see that for the input differential pair we should go for a large \\(g_\\mathrm{m}\\), thus we select a \\(g_\\mathrm{m}/I_\\mathrm{D}= 10\\). As \\(g_\\mathrm{ds}\\) of \\(M_2\\) could limit the dc gain (Equation 18) we go with a rather long \\(L = 5\\,\\mu\\text{m}\\). For current sources a small \\(g_\\mathrm{m}/I_\\mathrm{D}\\) is a good idea, so we start with \\(g_\\mathrm{m}/I_\\mathrm{D}=5\\) (because we can not go too low because of \\(V_\\mathrm{ds,sat}\\)) and also an \\(L = 5\\,\\mu\\text{m}\\). The \\(g_\\mathrm{m}/I_\\mathrm{D}\\) is also useful to estimate the required drain-source voltage to keep a MOSFET in saturation (i.e., keep the \\(g_\\mathrm{ds}\\) small) with this approximate relationship:\n\\[\nV_\\mathrm{ds,sat} = \\frac{2}{g_\\mathrm{m}/I_\\mathrm{D}}\n\\tag{26}\\]\n\n\n\n\n\n\nExercise: 5T-OTA Sizing\n\n\n\nPlease size the 5T-OTA according to the previous \\(g_\\mathrm{m}/I_\\mathrm{D}\\) and \\(L\\) suggestions. Please calculate the \\(W\\) of \\(M_{1-6}\\) and the total supply current. Please check wether gain error, total output noise, and turn-on settling is met with the calculated devices sizes and bias currents.\n\n\nThe sizing procedure and its calculation are best performed in a Jupyter notebook, as we can easily look up the exact data from the pre-computed tables:\n\n\n\n\n\n\nSolution: 5T-OTA Sizing\n\n\n\n\n\n\nSizing for Basic 5T-OTA\nCopyright 2024 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given parameters as taken from the specification table or inital guesses\nc_load = 50e-15\ngm_id_m12 = 10\ngm_id_m34 = 5\ngm_id_m56 = 5\nl_12 = 5\nl_34 = 5\nl_56 = 5\nf_bw = 10e6 # -3dB bandwidth of the voltage buffer\ni_total_limit = 10e-6\ni_bias_in = 20e-6\noutput_voltage = 1.3\nvin_min = 0.7\nvin_max = 0.9\nvdd_min = 1.45\nvdd_max = 1.55\n\n\n# we get the required gm of M1/2 from the -3dB bandwidth requirement of the voltage buffer specification\n# note that the -3dB bandwidth of the voltage buffer with gain Av=1 is equal to the unity gain bandwidth\n# of the ota, hence we wet them equal here\n# we add a factor of 3 to allow for PVT variation plus additional MOSFET parasitic loading\ngm_m12 = f_bw * 3 * 4*np.pi*c_load\nprint('gm12 =', round(gm_m12/1e-3, 4), 'mS')\n\ngm12 = 0.0188 mS\n\n\n\n# since we know gm12 and the gmid we can calculate the bias current\nid_m12 = gm_m12 / gm_id_m12\ni_total = 2*id_m12\nprint('i_total (exact) =', round(i_total/1e-6, 1), 'µA')\n# we round to 0.5µA bias currents\ni_total = max(round(i_total / 1e-6 * 2) / 2 * 1e-6, 0.5e-6)\nid_m12 = i_total/2\n\nprint('i_total (rounded) =', i_total/1e-6, 'µA')\nif i_total &lt; i_total_limit:\n    print('[info] power consumption target is met!')\nelse:\n    print('[info] power consumption target is NOT met!') \n\ni_total (exact) = 3.8 µA\ni_total (rounded) = 4.0 µA\n[info] power consumption target is met!\n\n\n\n# we calculate the dc gain\ngm_gds_m12 = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_gds_m34 = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0)\n\ngds_m12 = gm_m12 / gm_gds_m12\ngm_m34 = gm_id_m34 * i_total/2\ngds_m34 = gm_m34 / gm_gds_m34\n\na0 = gm_m12 / (gds_m12 + gds_m34)\nprint('a0 =', round(20*np.log10(a0), 1), 'dB')\n\na0 = 34.8 dB\n\n\n\n# we calculate the MOSFET capacitance which adds to Cload, to see the impact on the BW\ngm_cgs_m12 = lv_nmos.lookup('GM_CGS', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_cdd_m12 = lv_nmos.lookup('GM_CDD', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_cdd_m34 = lv_pmos.lookup('GM_CDD', GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0)\n\nc_load_parasitic = abs(gm_m12/gm_cgs_m12) + abs(gm_m12/gm_cdd_m12) + abs(gm_m34/gm_cdd_m34)\nprint('additional load capacitance =', round(c_load_parasitic/1e-15, 1), 'fF')\n\nf_bw = gm_m12 / (4*np.pi * (c_load + c_load_parasitic))\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\n\nadditional load capacitance = 54.9 fF\nunity gain bandwidth incl. parasitics = 14.3 MHz\n\n\n\n# we can now look up the VGS of the MOSFET\nvgs_m12 = lv_nmos.look_upVGS(GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0.0)\nvgs_m34 = lv_pmos.look_upVGS(GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0.0) \nvgs_m56 = lv_nmos.look_upVGS(GM_ID=gm_id_m56, L=l_56, VDS=0.75, VSB=0.0) \n\nprint('vgs_12 =', round(float(vgs_m12), 3), 'V')\nprint('vgs_34 =', round(float(vgs_m34), 3), 'V')\nprint('vgs_56 =', round(float(vgs_m56), 3), 'V')\n\nvgs_12 = 0.367 V\nvgs_34 = 0.729 V\nvgs_56 = 0.591 V\n\n\n\n# calculate settling time due to slewing with the calculated bias current\nt_slew = (c_load + c_load_parasitic) * output_voltage / i_total\nprint('slewing time =', round(t_slew/1e-6, 3), 'µs')\nt_settle = 5/(2*np.pi*f_bw)\nprint('settling time =', round(t_settle/1e-6, 3), 'µs')\n\nslewing time = 0.034 µs\nsettling time = 0.056 µs\n\n\n\n# calculate voltage gain error\ngain_error = a0 / (1 + a0)\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\n\nvoltage gain error = -1.8 %\n\n\n\n# calculate total rms output noise\nsth_m12 = lv_nmos.lookup('STH_GM', VGS=vgs_m12, L=l_12, VDS=0.75, VSB=0) * gm_m12\ngamma_m12 = sth_m12/(4*1.38e-23*300*gm_m12)\n\nsth_m34 = lv_pmos.lookup('STH_GM', VGS=vgs_m34, L=l_34, VDS=0.75, VSB=0) * gm_m34\ngamma_m34 = sth_m34/(4*1.38e-23*300*gm_m34)\n\noutput_noise_rms = np.sqrt(1.38e-23*300 / (c_load + c_load_parasitic) * (2*gamma_m12 + 2*gamma_m34 * gm_m34/gm_m12))\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\n\noutput noise = 354.2 µVrms\n\n\n\n# calculate all widths\nid_w_m12 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m12, L=l_12, VDS=vgs_m12, VSB=0)\nw_12 = id_m12 / id_w_m12\nw_12_round = max(round(w_12*2)/2, 0.5)\nprint('M1/2 W =', round(w_12, 2), 'um, rounded W =', w_12_round, 'um')\n\nid_m34 = id_m12\nid_w_m34 = lv_pmos.lookup('ID_W', GM_ID=gm_id_m34, L=l_34, VDS=vgs_m34, VSB=0)\nw_34 = id_m34 / id_w_m34\nw_34_round = max(round(w_34*2)/2, 0.5) \nprint('M3/4 W =', round(w_34, 2), 'um, rounded W =', w_34_round, 'um')\n\nid_w_m5 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m56, L=l_56, VDS=vgs_m56, VSB=0)\nw_5 = i_total / id_w_m5\nw_5_round = max(round(w_5*2)/2, 0.5)\nprint('M5 W =', round(w_5, 2), 'um, rounded W =', w_5_round, 'um')\nw_6 = w_5_round * i_bias_in / i_total\nw_6_round = max(round(w_6*2)/2, 0.5)\nprint('M6 W =', round(w_6_round, 2), 'um')\n\nM1/2 W = 1.77 um, rounded W = 2.0 um\nM3/4 W = 1.64 um, rounded W = 1.5 um\nM5 W = 0.74 um, rounded W = 0.5 um\nM6 W = 2.5 um\n\n\n\n# print out final design values\nprint('5T-OTA dimensioning:')\nprint('--------------------')\nprint('M1/2 W=', w_12_round, ', L=', l_12)\nprint('M3/4 W=', w_34_round, ', L=', l_34)\nprint('M5   W=', w_5_round, ', L=', l_56)\nprint('M6   W=', w_6_round, ', L=', l_56)\nprint()\nprint('5T-OTA performance summary:')\nprint('---------------------------')\nprint('supply current =', round(i_total/1e-6, 1), 'µA')\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\nprint('turn-on time (slewing+settling) =', round((t_slew+t_settle)/1e-6, 3), 'µs')\nprint()\nprint('5T-OTA bias point check:')\nprint('------------------------')\nprint('headroom M1 =', round(vdd_min-vgs_m34+vgs_m12-vin_max, 3), 'V')\nprint('headroom M4 =', round(vdd_min-vin_max, 3), 'V')\nprint('headroom M5 =', round(vin_min-vgs_m12, 3), 'V')\n\n5T-OTA dimensioning:\n--------------------\nM1/2 W= 2.0 , L= 5\nM3/4 W= 1.5 , L= 5\nM5   W= 0.5 , L= 5\nM6   W= 2.5 , L= 5\n\n5T-OTA performance summary:\n---------------------------\nsupply current = 4.0 µA\noutput noise = 354.2 µVrms\nvoltage gain error = -1.8 %\nunity gain bandwidth incl. parasitics = 14.3 MHz\nturn-on time (slewing+settling) = 0.09 µs\n\n5T-OTA bias point check:\n------------------------\nheadroom M1 = 0.188 V\nheadroom M4 = 0.55 V\nheadroom M5 = 0.333 V\n\n\nSource: Sizing for Basic 5T-OTA"
  },
  {
    "objectID": "analog_circuit_design.html#sec-basic-ota-simulation",
    "href": "analog_circuit_design.html#sec-basic-ota-simulation",
    "title": "Analog Circuit Design",
    "section": "8.5 5T-OTA Simulation",
    "text": "8.5 5T-OTA Simulation\nWith the initial sizing of the MOSFETs of the 5T-OTA done, we can design the 5T-OTA circuit and setup a simulation testbench to check the performance parameters. Since this is the first time we draw a more complex schematic, and use a hierarchical design, we should note that drawing a schematic is an art, and there exists a set of rules and recommendations how to name pins, how to use annotations, and so on. Please read Section 21 before you start into your design work.\n\n\n\n\n\n\nExercise: 5T-OTA Design and Testbench\n\n\n\nPlease design the circuit of the 5T-OTA. Put the OTA circuit in a separate schematic, create a symbol for it, and use this symbol in a testbench you create in Xschem for this 5T-OTA used as a voltage buffer as shown in Figure 27. Use typical conditions for the simulation, and check how well the specification in Table 2 is met, and how well the derivations in Section 8.2 and Section 8.3 fit to the simulation results.\nIf you get stuck, you can find the testbench and 5T-OTA schematic here (for the small-signal analysis) and here (for the large-signal settling simulation). For interested students, the loop gain analysis with Middlebrook’s and Tian’s method of the 5T-OTA can be found here."
  },
  {
    "objectID": "analog_circuit_design.html#sec-mosfet-mismatch",
    "href": "analog_circuit_design.html#sec-mosfet-mismatch",
    "title": "Analog Circuit Design",
    "section": "8.6 MOSFET Mismatch",
    "text": "8.6 MOSFET Mismatch\nSo far, we have assumed that implemented MOSFETs show no difference from device to device, which means that two transistors behave completely identical, and the resulting differential circuits are fully symmetric. However, due to manufacturing tolerances, this is not the case in reality. MOSFETs will show mismatch due to tiny random fluctuations in manufacturing, and we have to account for this.\nFor a typical MOSFET, we usually consider two main mismatch effects (Pelgrom, Duinmaijer, and Welbers 1989):\n\nA variation of the threshold voltage (mainly due to variations in doping levels).\nA variation of the critical dimensions of the MOSFET (\\(W\\) and \\(L\\) as well as vertical dimensions).\n\nBoth effects influence the drain current of the MOSFET, and they are indirectly proportional to the size of the MOSFET. So, if we want to reduce the mismatch, we have to increase the size of the MOSFET by increasing its gate area \\(W \\cdot L\\).\nIf we formulate the drain current mismatch \\(\\Delta I_\\mathrm{D}/ I_\\mathrm{D}\\) of two nominally identical MOSFET we get\n\\[\n\\frac{\\Delta I_\\mathrm{D}}{I_\\mathrm{D}} = \\frac{A_\\mathrm{mosfet}}{\\sqrt{W L}}\n\\tag{27}\\]\nwith \\(A_\\mathrm{mosfet}\\) being a mismatch parameter for a given CMOS technology.\n\n\n\n\n\n\nMOSFET Mismatch\n\n\n\nUsually, the mismatch in MOSFETs is characterized via two mismatch parameters (Pelgrom, Duinmaijer, and Welbers 1989):\n\nThe threshold voltage mismatch\n\n\\[\n\\Delta V_\\mathrm{th}= \\frac{A_\\mathrm{vth}}{\\sqrt{W L}}\n\\tag{28}\\]\n\nand the size mismatch\n\n\\[\n\\frac{\\Delta (W/L)}{(W/L)} = \\frac{A_\\mathrm{k}}{\\sqrt{W L}}.\n\\tag{29}\\]\nThe resulting input offset voltage \\(V_\\mathrm{offs}\\) of a differential pair is then given by (Razavi 2017) \\[\nV_\\mathrm{offs} = \\sqrt{\\left( \\frac{V_\\mathrm{GS}- V_\\mathrm{th}}{2} \\frac{\\Delta (W/L)}{{(W/L)}} \\right)^2 + \\Delta V_\\mathrm{th}^2}.\n\\tag{30}\\]\nThe mismatch in the drain current of two current-mirror transistors is given by (Razavi 2017)\n\\[\n\\frac{\\Delta I_\\mathrm{D}}{I_\\mathrm{D}} = \\frac{\\Delta (W/L)}{(W/L)} - 2 \\frac{\\Delta V_\\mathrm{th}}{V_\\mathrm{GS}- V_\\mathrm{th}}.\n\\tag{31}\\]\nTo minimize the input offset voltage in a differential pair we should strive to minimize \\(V_\\mathrm{GS}\\) (see Equation 30) and to minimize the mismatch in current mirrors we should target a large \\(V_\\mathrm{GS}\\) (see Equation 31). In both cases the MOSFET area \\(W \\cdot L\\) needs to be large enough (see Equation 28 and Equation 29).\n\n\nHow can we now cope with mismatch in design and simulation? We can account the transitor mismatch according to Equation 28 and Equation 29 in circuit analysis and quantify its effect. We can then take this into account when performing the circuit sizing procedure.\nWe can also simulate the effects of MOSFET mismatch on circuit performance by doing a Monte Carlo simulation. Here, a random realization of the variations of all circuit components (where mismatch is modelled) is taken and the circuit is simulated. Then, another random realization is simulated, and so on. In summary, we run the same simulation for different realizations \\(N\\) times and evaluate the resulting variations of the circuit parameters. If \\(N\\) is large enough then the distributions should approach a Gaussian distribution, and we can then estimate the variances of the circuit parameters. Using statistical analysis we can then assess the yield of a circuit, i.e., how many circuit realizations will meet the specification.\n\n\n\n\n\n\nNumber of Monte Carlo Simulation Runs\n\n\n\nThe number of Monte Carlo simulation runs \\(N\\) has to be large enough to approach Gaussian distributions to allow estimation of the variances. However, this comes at the cost of a large simulation time, so a balance has to be found. Often, \\(N = 250\\) is a good compromise between simulation time and well-behaved parameter distributions.\n\n\nAs you can see in the previous discussion, running Monte Carlo simulations is a tedious process due to the large number of involved simulations and the required data processing of the heaps of simulation data. Luckily, CACE supports this type of simulation, and we will use it in Section 8.8."
  },
  {
    "objectID": "analog_circuit_design.html#sec-resistor-mismatch",
    "href": "analog_circuit_design.html#sec-resistor-mismatch",
    "title": "Analog Circuit Design",
    "section": "8.7 Resistor Mismatch",
    "text": "8.7 Resistor Mismatch\nSimilar to the MOSFET mismatch discussed in Section 8.6, resistors will also show mismatch. Equivalently to Equation 27 the resistor mismatch \\(\\Delta R / R\\) can be characterized by\n\\[\n\\frac{\\Delta R}{R} = \\frac{A_\\mathrm{res}}{\\sqrt{W L}}\n\\tag{32}\\]\nwith \\(A_\\mathrm{res}\\) being a mismatch parameter for a given CMOS technology.\nWith Equation 32 we now have two criteria for how to select the width \\(W\\) of a specific resistor (the length \\(L\\) is then derived from the required resistance value with \\(R = R_\\square \\cdot L / W\\)):\n\nThe current handling capability (the larger the \\(W\\), the more dc current a resistor can carry), and\nthe resistor mismatch (the larger the \\(W\\), the larger the \\(W L\\) for a given \\(L/W\\)).\n\nIf a resistor’s dimensions are not limited by the two criteria above then we usually choose the minimum width that is allowed for a given resistor in a specific technology (for SG13G2 it is \\(L_\\mathrm{min} = 0.5\\,\\mu\\text{m}\\)) to save area and to minimize the parasitic capacitance of the resistor to substrate."
  },
  {
    "objectID": "analog_circuit_design.html#sec-basic-ota-simulation-pvt",
    "href": "analog_circuit_design.html#sec-basic-ota-simulation-pvt",
    "title": "Analog Circuit Design",
    "section": "8.8 5T-OTA Simulation versus PVT and MC",
    "text": "8.8 5T-OTA Simulation versus PVT and MC\nAs you have seen in Section 8.5 running simulations by hand is tedious. When we want to check the overall performance, we have to run many simulations over various conditions:\n\nThe supply voltage of the circuit has tolerances, and thus we need to check the performance against this variation.\nThe temperature at which the circuit is operated is likely changing. Also the performance against this has to be verified.\nWhen manufacturing the wafers random variations in various process parameters lead to changed parameters of the integrated circuit components. In order to check for this effect, wafer foundries provide model files which shall cover these manufacturing excursions. Simplified, this leads to a slower or faster MOSFET, and usually NMOS and PMOS are not correlated, so we have the process corners SS, SF, TT, FS, and FF. So far, we have only used the TT models in our simulations.\n\nThe variations listed in the previous list are abbreviated as PVT (process, voltage, temperature) variations. In order to finalize a circuit all combinations of these (plus the variations in operating conditions like input voltage) have to be simulated. As you can imagine, this leads to a huge number of simulations, and simulation results which have to be evaluated for pass/fail.\nThere are two options how to tackle this efficiently:\n\nAs an experienced designer you have a very solid understanding of the circuit, plus based on the analytic equations you can identify which combination of operating conditions will lead to a worst case performance. Thus, you can drastically reduce the number of corners to simulate, and you run them by hand.\nYou are using a framework which highly automates this task of running a plethora of different simulations and evaluating the outcome. These frameworks are called simulation runners.\n\nLuckily, there are open-source versions of simulation runners available, and we will use CACE in this lecture. CACE is written in Python and allows to setup a datasheet in YAML which defines the simulation problem and the performance parameters to evaluate against which limits. The resulting simulations are then run in parallel and the simulation data is evaluated and summarized in various forms.\nThere is a CACE setup available for our 5T-OTA. The datasheet describes the operating conditions and the simulations tasks. For each simulation a testbench template is needed, this one is used for ac simulations, this one is used for noise simulation, and this one is used for transient simulation.\nAfter a successful run, a documentation is automatically generated. The result of a full run of this OTA design is presented here:\n\n\n\n\n\n\nNote 2: CACE Summary for 5T-OTA\n\n\n\n\n\nCACE Summary for ota-5t\nnetlist source: schematic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nTool\nResult\nMin Limit\nMin Value\nTyp Target\nTyp Value\nMax Limit\nMax Value\nStatus\n\n\n\n\nOutput voltage ratio\nngspice\ngain\n0.97 V/V\n0.987 V/V\nany\n1.000 V/V\n1.03 V/V\n1.007 V/V\nPass ✅\n\n\nBandwidth\nngspice\nbw\n10e6 Hz\n15550400.000 Hz\nany\n26912100.000 Hz\nany\n34052200.000 Hz\nPass ✅\n\n\nOutput voltage ratio (MC)\nngspice\ngain_mc\nany\n0.837 V/V\nany\n1.010 V/V\nany\n1.185 V/V\nPass ✅\n\n\nBandwidth (MC)\nngspice\nbw_mc\n10e6 Hz\n18988400.000 Hz\nany\n26567100.000 Hz\nany\n29443100.000 Hz\nPass ✅\n\n\nOutput noise\nngspice\nnoise\nany\n0.308 mV\nany\n0.371 mV\n1 mV\n0.454 mV\nPass ✅\n\n\nSettling time\nngspice\ntsettle\nany\n0.137 us\nany\n0.144 us\n10 us\n0.156 us\nPass ✅\n\n\n\n\nPlots\n\n\ngain_vs_temp\n\n\n\ngain_vs_temp\n\n\n\n\ngain_vs_vin\n\n\n\ngain_vs_vin\n\n\n\n\ngain_vs_vdd\n\n\n\ngain_vs_vdd\n\n\n\n\ngain_vs_corner\n\n\n\ngain_vs_corner\n\n\n\n\nbw_vs_temp\n\n\n\nbw_vs_temp\n\n\n\n\nbw_vs_vin\n\n\n\nbw_vs_vin\n\n\n\n\nbw_vs_vdd\n\n\n\nbw_vs_vdd\n\n\n\n\nbw_vs_corner\n\n\n\nbw_vs_corner\n\n\n\n\ngain_mc\n\n\n\ngain_mc\n\n\n\n\nbw_mc\n\n\n\nbw_mc\n\n\n\n\nnoise_vs_temp\n\n\n\nnoise_vs_temp\n\n\n\n\nnoise_vs_vin\n\n\n\nnoise_vs_vin\n\n\n\n\nnoise_vs_vdd\n\n\n\nnoise_vs_vdd\n\n\n\n\nnoise_vs_corner\n\n\n\nnoise_vs_corner\n\n\n\n\nsettling_vs_temp\n\n\n\nsettling_vs_temp\n\n\n\n\nsettling_vs_vin\n\n\n\nsettling_vs_vin\n\n\n\n\nsettling_vs_vdd\n\n\n\nsettling_vs_vdd\n\n\n\n\nsettling_vs_corner\n\n\n\nsettling_vs_corner\n\n\n\n\n\n\n\n8.8.1 PVT Simulation Analysis\nLooking at the CACE report in Note 2 we see that (luckily) the specification is met for all parameters. This is great news! We now have a design that we carefully simulated across PVT and other corners, and which is ready for layout. Once we have the layout ready, we can extract the wiring parasitic (\\(R\\) and \\(C\\)) as well as other layout-dependent effects like well proximity. Using this augmented netlist we can then again use CACE to check performance across conditions and parameter variations, and if we still pass all specification points then our design is finished.\n\n\n8.8.2 Monte Carlo Simulation Analysis\nLooking at the CACE report in Note 2 we see that the output voltage specification is not met due to MOSFET mismatch! We have not considered transistor mismatch in the circuit sizing procedure, and as a result the selected MOSFET dimensions proof to be too small. We should now go back and change the transistor sizing (increasing \\(L\\) significantly while keeping the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) values). Likely we will find that some performance parameters are now deteriorating due to the increased MOSFET dimensions, and we need to iterate until all performance metrics are met in the presence of transistor mismatch.\nIt is not unusual that the power consumption now increases, as we have to increase the size of the MOSFETs for matching, and these larger MOSFETs increase the parasitic capacitances which in turn lead to larger power consumption to keep the required bandwidth by increasing the \\(g_\\mathrm{m}\\).\n\n\n\n\n\n\nExercise: Re-Sizing of 5T-OTA for Mismatch\n\n\n\nGo back to Section 8.4 and repeat the sizing procedure of the 5T-OTA by increasing the \\(L\\) of the MOSFETs significantly. Focus first on the differential pair as it will likely have the biggest impact (see Equation 30). Then, tune the size of the output current mirror if necessary (see Equation 31).\nOnce you are happy with the sizing result repeat the PVT simulations in CACE to confirm the performance of the voltage buffer including mismatch."
  },
  {
    "objectID": "analog_circuit_design.html#plots",
    "href": "analog_circuit_design.html#plots",
    "title": "Analog Circuit Design",
    "section": "Plots",
    "text": "Plots"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_temp",
    "href": "analog_circuit_design.html#gain_vs_temp",
    "title": "Analog Circuit Design",
    "section": "gain_vs_temp",
    "text": "gain_vs_temp\n\n\n\ngain_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_vin",
    "href": "analog_circuit_design.html#gain_vs_vin",
    "title": "Analog Circuit Design",
    "section": "gain_vs_vin",
    "text": "gain_vs_vin\n\n\n\ngain_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_vdd",
    "href": "analog_circuit_design.html#gain_vs_vdd",
    "title": "Analog Circuit Design",
    "section": "gain_vs_vdd",
    "text": "gain_vs_vdd\n\n\n\ngain_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_corner",
    "href": "analog_circuit_design.html#gain_vs_corner",
    "title": "Analog Circuit Design",
    "section": "gain_vs_corner",
    "text": "gain_vs_corner\n\n\n\ngain_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_temp",
    "href": "analog_circuit_design.html#bw_vs_temp",
    "title": "Analog Circuit Design",
    "section": "bw_vs_temp",
    "text": "bw_vs_temp\n\n\n\nbw_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_vin",
    "href": "analog_circuit_design.html#bw_vs_vin",
    "title": "Analog Circuit Design",
    "section": "bw_vs_vin",
    "text": "bw_vs_vin\n\n\n\nbw_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_vdd",
    "href": "analog_circuit_design.html#bw_vs_vdd",
    "title": "Analog Circuit Design",
    "section": "bw_vs_vdd",
    "text": "bw_vs_vdd\n\n\n\nbw_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_corner",
    "href": "analog_circuit_design.html#bw_vs_corner",
    "title": "Analog Circuit Design",
    "section": "bw_vs_corner",
    "text": "bw_vs_corner\n\n\n\nbw_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#gain_mc",
    "href": "analog_circuit_design.html#gain_mc",
    "title": "Analog Circuit Design",
    "section": "gain_mc",
    "text": "gain_mc\n\n\n\ngain_mc"
  },
  {
    "objectID": "analog_circuit_design.html#bw_mc",
    "href": "analog_circuit_design.html#bw_mc",
    "title": "Analog Circuit Design",
    "section": "bw_mc",
    "text": "bw_mc\n\n\n\nbw_mc"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_temp",
    "href": "analog_circuit_design.html#noise_vs_temp",
    "title": "Analog Circuit Design",
    "section": "noise_vs_temp",
    "text": "noise_vs_temp\n\n\n\nnoise_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_vin",
    "href": "analog_circuit_design.html#noise_vs_vin",
    "title": "Analog Circuit Design",
    "section": "noise_vs_vin",
    "text": "noise_vs_vin\n\n\n\nnoise_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_vdd",
    "href": "analog_circuit_design.html#noise_vs_vdd",
    "title": "Analog Circuit Design",
    "section": "noise_vs_vdd",
    "text": "noise_vs_vdd\n\n\n\nnoise_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_corner",
    "href": "analog_circuit_design.html#noise_vs_corner",
    "title": "Analog Circuit Design",
    "section": "noise_vs_corner",
    "text": "noise_vs_corner\n\n\n\nnoise_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_temp",
    "href": "analog_circuit_design.html#settling_vs_temp",
    "title": "Analog Circuit Design",
    "section": "settling_vs_temp",
    "text": "settling_vs_temp\n\n\n\nsettling_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_vin",
    "href": "analog_circuit_design.html#settling_vs_vin",
    "title": "Analog Circuit Design",
    "section": "settling_vs_vin",
    "text": "settling_vs_vin\n\n\n\nsettling_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_vdd",
    "href": "analog_circuit_design.html#settling_vs_vdd",
    "title": "Analog Circuit Design",
    "section": "settling_vs_vdd",
    "text": "settling_vs_vdd\n\n\n\nsettling_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_corner",
    "href": "analog_circuit_design.html#settling_vs_corner",
    "title": "Analog Circuit Design",
    "section": "settling_vs_corner",
    "text": "settling_vs_corner\n\n\n\nsettling_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#sec-ota-variants-single-ended",
    "href": "analog_circuit_design.html#sec-ota-variants-single-ended",
    "title": "Analog Circuit Design",
    "section": "8.9 OTA Variants",
    "text": "8.9 OTA Variants\nFollowing, we are going to discuss two popular variants of the simple 5T-OTA. The first version provides an almost rail-to-rail single-ended output, and can thus be used for a variety of applications requiring this range. The arrangement is shown in Figure 33. It is a single-stage amplifier, as the only high-impedance point is at the output where significant voltage-gain is produced. The current mirrors can be used to scale up the current generated in the input differential pair to some extent in the output stage (or can be used to lower the current compared to the bias current in the diffpair); i.e., the bias currents of the input stage and the output stage can be set independently.\nBeing a single-stage amplifier stability is usually not an issue, as only the output node is high-ohmic; all other nodes feature a MOSFET diode so the node impedance is \\(\\approx g_\\mathrm{m}^{-1}\\) and thus the according poles are located at high frequencies.\n\n\n\n\n\n\n\n\nFigure 33: Single-ended OTA with rail-to-rail output stage.\n\n\n\n\n\nAnother popular version is shown in Figure 34. Here, we have a two-stage amplifier able to provide higher voltage gain. The first stage (the diffpair loaded by a current mirror) is followed by a single-stage common-source amplifier with current-source load. Being a two-stage amplifier with two high-ohmic nodes, stability is a concern, so usually we need some form of compensation. Figure 34 shows a very simplistic Miller-compensation using \\(C_\\mathrm{M}\\). Often, we would want to implement a more advanced scheme. Some examples can be found in (Baker, n.d.). An interesting technique is the indirect compensation with cascoded input differential pairs (see Figure 41) for higher power supply rejection. An advantage of this two-stage amplifier (compared with the simple 5T-OTA) is the dc-balanced load on top of the differential pair, as each side sees a voltage drop from \\(V_\\mathrm{DD}\\) of one \\(V_\\mathrm{GS}\\) (\\(V_\\mathrm{GS3}\\) on the left side, \\(V_\\mathrm{GS5}\\) on the right side).\n\n\n\n\n\n\n\n\nFigure 34: Single-ended two-stage OTA with rail-to-rail output.\n\n\n\n\n\nNote that the circuit of Figure 34 can be easily modified into a low-dropout voltage regulator (LDO). This simple yet often effective circuit is shown in Figure 35. The pass transistor \\(M_\\mathrm{pass}\\) has to be sized according to the load current and the dropout voltage.\n\n\n\n\n\n\n\n\nFigure 35: A basic low-dropout voltage regulator (LDO) with Miller compensation.\n\n\n\n\n\nThe reference voltage \\(V_\\mathrm{ref}\\) is scaled by \\(R_1\\) and \\(R_2\\), so that the output voltage \\(V_\\mathrm{out}\\) is given by\n\\[\nV_\\mathrm{out} \\approx V_\\mathrm{ref} \\left( 1 + \\frac{R_1}{R_2} \\right)\n\\]\nif the gain of the OTA is sufficiently high. The quiescent current through \\(R_{1,2}\\) establishes a minimum load current for the LDO, which is often good for stability. More information on LDOs can be found in (Razavi 2019)."
  },
  {
    "objectID": "analog_circuit_design.html#cascode-output-impedance",
    "href": "analog_circuit_design.html#cascode-output-impedance",
    "title": "Analog Circuit Design",
    "section": "9.1 Cascode Output Impedance",
    "text": "9.1 Cascode Output Impedance\nAs a first step, we want to calculate the output impedance at the drain of the MOSFET (i.e., looking into the drain). For this, we replace \\(G_\\mathrm{D}\\) with a current source. The resulting small-signal equivalent circuit is shown in Figure 39.\n\n\n\n\n\n\n\n\nFigure 39: The simplified MOSFET cascode small-signal model for calculation of the output impedance.\n\n\n\n\n\nWe realize that \\(i_\\mathrm{out}\\) flows through \\(G_\\mathrm{S}\\) and drops \\(v_\\mathrm{gs}\\) (note the sign): \\[\nv_\\mathrm{gs}= -\\frac{i_\\mathrm{out}}{G_\\mathrm{S}}\n\\]\nFurther, \\(v_\\mathrm{out} = -v_\\mathrm{gs}+ v_\\mathrm{ds}\\). Calculating KCL at the output node results in \\[\ni_\\mathrm{out} - g_\\mathrm{m}v_\\mathrm{gs}- g_\\mathrm{ds}v_\\mathrm{ds}= 0.\n\\]\nUsing the previously found identities, and after a bit of algebraic manipulations we arrive at \\[\ng_\\mathrm{out} = \\frac{i_\\mathrm{out}}{v_\\mathrm{out}} = \\frac{g_\\mathrm{ds}}{1 + \\frac{g_\\mathrm{m}+ g_\\mathrm{ds}}{G_\\mathrm{S}}} = \\frac{g_\\mathrm{ds}\\cdot G_\\mathrm{S}}{G_\\mathrm{S} + g_\\mathrm{m}+ g_\\mathrm{ds}}\n\\tag{33}\\]\nWe find that if \\(G_\\mathrm{S} = 0\\) (an open) then \\(g_\\mathrm{out} = 0\\), and if \\(G_\\mathrm{S} = \\infty\\) (a short) then \\(g_\\mathrm{out} = g_\\mathrm{ds}\\). We can calculate the benefits of a cascode if we assume we put a cascode on top of a common-source transistor stage (thus \\(G_\\mathrm{S} = g_\\mathrm{ds}'\\)) and get \\[\ng_\\mathrm{out} = \\frac{g_\\mathrm{ds}\\cdot g_\\mathrm{ds}'}{g_\\mathrm{ds}' + g_\\mathrm{m}+ g_\\mathrm{ds}} \\approx g_\\mathrm{ds}' \\frac{g_\\mathrm{ds}}{g_\\mathrm{m}}.\n\\tag{34}\\]\n\n\n\n\n\n\nBenefit of Cascode (Output)\n\n\n\nThe output impedance of the lower MOSFET (\\(r_\\mathrm{ds} = 1 / g_\\mathrm{ds}'\\)) is increased by the self-gain of the cascode transistor! This is a powerful technique to increase the output impedance of a transistor stage by cascoding, much better than increasing \\(L\\)."
  },
  {
    "objectID": "analog_circuit_design.html#cascode-input-impedance",
    "href": "analog_circuit_design.html#cascode-input-impedance",
    "title": "Analog Circuit Design",
    "section": "9.2 Cascode Input Impedance",
    "text": "9.2 Cascode Input Impedance\nTo calculate the input impedance of a cascode (i.e., looking into the source) we replace \\(G_\\mathrm{S}\\) with a current source. The resulting small-signal equivalent circuit is shown in Figure 40.\n\n\n\n\n\n\n\n\nFigure 40: The simplified MOSFET cascode small-signal model for calculation of the input impedance.\n\n\n\n\n\nWe note that \\(v_\\mathrm{gs}= -v_\\mathrm{in}\\) and that \\(i_\\mathrm{in}\\) flows through \\(G_\\mathrm{D}\\), resulting in \\(v_\\mathrm{D} = i_\\mathrm{in} / G_\\mathrm{D}\\). Note that \\(v_\\mathrm{ds}=  v_\\mathrm{D} - v_\\mathrm{in}\\). Formulating KCL at the input node results in \\[\ni_\\mathrm{in} + g_\\mathrm{ds}v_\\mathrm{ds}+ g_\\mathrm{m}v_\\mathrm{gs}= 0.\n\\]\nAfter some manipulation we find that \\[\ng_\\mathrm{in} = \\frac{i_\\mathrm{in}}{v_\\mathrm{in}} = \\frac{(g_\\mathrm{m}+ g_\\mathrm{ds}) \\cdot G_\\mathrm{D}}{g_\\mathrm{ds}+ G_\\mathrm{D}}.\n\\tag{35}\\]\nSetting \\(G_\\mathrm{D} = 0\\) (an open) results in \\(g_\\mathrm{in} = 0\\) as well, so the input impedance of the cascode is very large when the drain impedance is large.\nHowever, setting \\(G_\\mathrm{D} = \\infty\\) (a short or low-ohmic impedance) results in the well-known result of \\(g_\\mathrm{in} = g_\\mathrm{m}+ g_\\mathrm{ds}\\approx g_\\mathrm{m}\\), which means that the input impedance looking into a cascode is approximately \\(1/g_\\mathrm{m}\\).\n\n\n\n\n\n\nBenefit of Cascode (Input)\n\n\n\nThis has the practical benefit that a capacitance connected at this node results in a high-frequency pole, which is often not critical in terms of stability. Further, the voltage swing at a cascode input node is small due to the often small impedance, and this minimizes the Miller effect at connected inter-node capacitors (see Section 16.1)."
  },
  {
    "objectID": "analog_circuit_design.html#sec-improved-ota-sizing",
    "href": "analog_circuit_design.html#sec-improved-ota-sizing",
    "title": "Analog Circuit Design",
    "section": "10.1 Sizing the Improved OTA",
    "text": "10.1 Sizing the Improved OTA\nLike the sizing of the 5T-OTA in Section 8.4 we will again use the \\(g_\\mathrm{m}/I_\\mathrm{D}\\) method using a Python notebook. Instead of using \\(L = 5\\,\\mu\\text{m}\\) we will this time use a reduced \\(L = 0.5\\,\\mu\\text{m}\\) for \\(M_\\mathrm{1/1C,2/2C,3/3C,4/4C}\\) (for speed reasons) and \\(L = 5\\,\\mu\\text{m}\\) for \\(M_\\mathrm{5,6}\\) for better common-mode rejection (the tail current mirror is less critical in terms of speed and stability).\nWe set \\(g_\\mathrm{m}/I_\\mathrm{D}= 13\\) across the board for a good trade-off between speed, current efficiency, and voltage headroom for the MOSFETs (this is now way more critical than in the basic 5T-OTA as we stack now double as many MOSFET at the same supply voltage). Please look at Section 3 to confirm this choice.\n\n\n\n\n\n\nImproved OTA Sizing\n\n\n\n\n\n\nSizing for Basic (Improved) OTA\nCopyright 2024-2025 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given parameters as taken from the specification table or initial guesses\nc_load = 50e-15\ngm_id_m12 = 13\ngm_id_m12c = 13\ngm_id_m34 = 13\ngm_id_m34c = 13\ngm_id_m56 = 13\nl_12 = 0.5\nl_12c = 0.5\nl_34 = 0.5\nl_34c = 0.5\nl_56 = 5\nf_bw = 10e6 # -3dB bandwidth of the voltage buffer\ni_total_limit = 10e-6 # we plan 2x5uA in addition for additional bias voltage generation\ni_bias_in = 5e-6\noutput_voltage = 1.3\nvin_min = 0.7\nvin_max = 0.9\nvdd_min = 1.45\nvdd_max = 1.55\nvds_headroom = 0.2\n\n\n# we get the required gm of M1/2 from the -3dB bandwidth requirement of the voltage buffer specification\n# note that the -3dB bandwidth of the voltage buffer with gain Av=1 is equal to the unity gain bandwidth\n# of the ota, hence we wet them equal here\n# we add a factor of 3 to allow for PVT variation plus additional MOSFET parasitic loading\n# we also add an additional factor of 2 to get more dc gain (and there is power still in the budget)\ngm_m12 = f_bw * 3 * 4*np.pi*c_load * 3\nprint('gm12 =', round(gm_m12/1e-3, 4), 'mS')\n\ngm12 = 0.0565 mS\n\n\n\n# since we know gm12 and the gmid we can calculate the bias current\nid_m12 = gm_m12 / gm_id_m12\ni_total = 2*id_m12\nprint('i_total (exact) =', round(i_total/1e-6, 1), 'µA')\n# we round to 0.5µA bias currents\ni_total = max(round(i_total / 1e-6 * 2) / 2 * 1e-6, 0.5e-6)\n# here is a manual override to set the current; we keep a reserve of 2µA for bias branch\ni_total = 8e-6\nid_m12 = i_total/2\n\nprint('i_total (rounded) =', i_total/1e-6, 'µA')\nif i_total &lt; i_total_limit:\n    print('[info] power consumption target is met!')\nelse:\n    print('[info] power consumption target is NOT met!') \n\ni_total (exact) = 8.7 µA\ni_total (rounded) = 8.0 µA\n[info] power consumption target is met!\n\n\n\n# we calculate the dc gain\ngm_gds_m12 = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\ngm_gds_m12c = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\ngm_gds_m34 = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_m34, L=l_34, VDS=vds_headroom, VSB=0)\ngm_gds_m34c = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom)\n# conductance of lower cascoded differential pair\ngds_m12 = gm_m12 / gm_gds_m12\ngds_m12_casc = gds_m12 / gm_gds_m12c\n# conductance of upper cascoded current mirror\ngm_m34 = gm_id_m34 * i_total/2\ngds_m34 = gm_m34 / gm_gds_m34\ngds_m34_casc = gds_m34 / gm_gds_m34c\n\nprint('gds_12 =', round(gds_m12/1e-6, 3), 'µs')\nprint('gm_12c/gds_12c =',round(float(gm_gds_m12c), 1))\nprint('gds_34 =', round(gds_m34/1e-6, 3), 'µs')\nprint('gm_34c/gds_34c =', round(float(gm_gds_m34c), 1))\n\na0 = gm_m12 / (gds_m12_casc + gds_m34_casc)\nprint('a0 =', round(20*np.log10(a0), 1), 'dB')\n\ngds_12 = 4.026 µs\ngm_12c/gds_12c = 13.4\ngds_34 = 2.031 µs\ngm_34c/gds_34c = 24.9\na0 = 43.4 dB\n\n\n\n# we calculate the MOSFET capacitance which adds to Cload, to see the impact on the BW\ngm_cgs_m12 = lv_nmos.lookup('GM_CGS', GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\ngm_cdd_m12c = lv_nmos.lookup('GM_CDD', GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\ngm_cdd_m34c = lv_pmos.lookup('GM_CDD', GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom)\n\nc_load_parasitic = abs(gm_m12/gm_cgs_m12) + abs(gm_m12/gm_cdd_m12c) + abs(gm_m34/gm_cdd_m34c)\nprint('additional load capacitance =', round(c_load_parasitic/1e-15, 1), 'fF')\n\nf_bw = gm_m12 / (4*np.pi * (c_load + c_load_parasitic))\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\n\nadditional load capacitance = 5.5 fF\nunity gain bandwidth incl. parasitics = 81.15 MHz\n\n\n\n# we can now look up the VGS of the MOSFET\nvgs_m12 = lv_nmos.look_upVGS(GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\nvgs_m12c = lv_nmos.look_upVGS(GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\nvgs_m34 = lv_pmos.look_upVGS(GM_ID=gm_id_m34, L=l_34, VDS=vds_headroom, VSB=0.0) \nvgs_m34c = lv_pmos.look_upVGS(GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom) \nvgs_m56 = lv_nmos.look_upVGS(GM_ID=gm_id_m56, L=l_56, VDS=vds_headroom, VSB=0.0) \n\nprint('vgs_12  =', round(float(vgs_m12), 3), 'V')\nprint('vgs_12c =', round(float(vgs_m12c), 3), 'V')\nprint('vgs_34  =', round(float(vgs_m34), 3), 'V')\nprint('vgs_34c =', round(float(vgs_m34c), 3), 'V')\nprint('vgs_56  =', round(float(vgs_m56), 3), 'V')\n\nvgs_12  = 0.436 V\nvgs_12c = 0.458 V\nvgs_34  = 0.475 V\nvgs_34c = 0.512 V\nvgs_56  = 0.318 V\n\n\n\n# calculate settling time due to slewing with the calculated bias current\nt_slew = (c_load + c_load_parasitic) * output_voltage / i_total\nprint('slewing time  =', round(t_slew/1e-6, 3), 'µs')\nt_settle = 5/(2*np.pi*f_bw)\nprint('settling time =', round(t_settle/1e-6, 3), 'µs')\n\nslewing time  = 0.009 µs\nsettling time = 0.01 µs\n\n\n\n# calculate voltage gain error\ngain_error = a0 / (1 + a0)\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\n\nvoltage gain error = -0.7 %\n\n\n\n# calculate total rms output noise\nsth_m12 = lv_nmos.lookup('STH_GM', VGS=vgs_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom) * gm_m12\ngamma_m12 = sth_m12/(4*1.38e-23*300*gm_m12)\n\nsth_m34 = lv_pmos.lookup('STH_GM', VGS=vgs_m34, L=l_34, VDS=vds_headroom, VSB=0) * gm_m34\ngamma_m34 = sth_m34/(4*1.38e-23*300*gm_m34)\n\noutput_noise_rms = np.sqrt(1.38e-23*300 / (c_load + c_load_parasitic) * (2*gamma_m12 + 2*gamma_m34 * gm_m34/gm_m12))\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\n\noutput noise = 555.4 µVrms\n\n\n\n# calculate all widths\nid_w_m12 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m12, L=l_12, VDS=vds_headroom, VSB=2*vds_headroom)\nw_12 = id_m12 / id_w_m12\nw_12_round = max(round(w_12*2)/2, 0.5)\nprint('M1/2  W =', round(w_12, 2), 'um, rounded W =', w_12_round, 'um')\n\nid_m12c = id_m12\nid_w_m12c = lv_nmos.lookup('ID_W', GM_ID=gm_id_m12c, L=l_12c, VDS=vds_headroom, VSB=3*vds_headroom)\nw_12c = id_m12c / id_w_m12c\nw_12c_round = max(round(w_12c*2)/2, 0.5)\nprint('M1/2c W =', round(w_12c, 2), 'um, rounded W =', w_12c_round, 'um')\n\nid_m34 = id_m12\nid_w_m34 = lv_pmos.lookup('ID_W', GM_ID=gm_id_m34, L=l_34, VDS=vds_headroom, VSB=0)\nw_34 = id_m34 / id_w_m34\nw_34_round = max(round(w_34*2)/2, 0.5) \nprint('M3/4  W =', round(w_34, 2), 'um, rounded W =', w_34_round, 'um')\n\nid_m34c = id_m12\nid_w_m34c = lv_pmos.lookup('ID_W', GM_ID=gm_id_m34c, L=l_34c, VDS=vds_headroom, VSB=vds_headroom)\nw_34c = id_m34c / id_w_m34c\nw_34c_round = max(round(w_34c*2)/2, 0.5) \nprint('M3/4c W =', round(w_34c, 2), 'um, rounded W =', w_34c_round, 'um')\n\nid_w_m5 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m56, L=l_56, VDS=vds_headroom, VSB=0)\nw_5 = i_total / id_w_m5\nw_5_round = max(round(w_5*2)/2, 0.5)\nprint('M5    W =', round(w_5, 2), 'um, rounded W =', w_5_round, 'um')\n\nw_6 = w_5_round * i_bias_in / i_total\nprint('M6    W =', round(w_6, 2), 'um')\n\nM1/2  W = 0.83 um, rounded W = 1.0 um\nM1/2c W = 0.8 um, rounded W = 1.0 um\nM3/4  W = 3.28 um, rounded W = 3.5 um\nM3/4c W = 2.99 um, rounded W = 3.0 um\nM5    W = 14.2 um, rounded W = 14.0 um\nM6    W = 8.75 um\n\n\n\n# Print out final design values\nprint('Improved OTA dimensioning:')\nprint('--------------------------')\nprint('M1/2  W=', w_12_round, ', L=', l_12)\nprint('M1/2c W=', w_12c_round, ', L=', l_12c)\nprint('M3/4  W=', w_34_round, ', L=', l_34)\nprint('M3/4c W=', w_34c_round, ', L=', l_34c)\nprint('M5   W=', w_5_round, ', L=', l_56)\nprint('M6   W=', round(w_6, 2), ', L=', l_56)\nprint()\nprint('Improved OTA performance summary:')\nprint('---------------------------------')\nprint('supply current =', round(i_total/1e-6, 1), 'µA')\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\nprint('turn-on time (slewing+settling) =', round((t_slew+t_settle)/1e-6, 3), 'µs')\nprint()\nprint('Improved OTA bias point check:')\nprint('------------------------------')\nprint('headroom M1+M1c =', round(vdd_min-vgs_m34+vgs_m12-vin_max, 3), 'V')\nprint('headroom M4+M4c =', round(vdd_min-vin_max, 3), 'V')\nprint('headroom M5     =', round(vin_min-vgs_m12, 3), 'V')\n\nImproved OTA dimensioning:\n--------------------------\nM1/2  W= 1.0 , L= 0.5\nM1/2c W= 1.0 , L= 0.5\nM3/4  W= 3.5 , L= 0.5\nM3/4c W= 3.0 , L= 0.5\nM5   W= 14.0 , L= 5\nM6   W= 8.75 , L= 5\n\nImproved OTA performance summary:\n---------------------------------\nsupply current = 8.0 µA\noutput noise = 555.4 µVrms\nvoltage gain error = -0.7 %\nunity gain bandwidth incl. parasitics = 81.15 MHz\nturn-on time (slewing+settling) = 0.019 µs\n\nImproved OTA bias point check:\n------------------------------\nheadroom M1+M1c = 0.512 V\nheadroom M4+M4c = 0.55 V\nheadroom M5     = 0.264 V\n\n\nSource: Sizing for Basic (Improved) OTA\n\n\n\nLooking at this sizing result we see that we achieve an improved \\(A0 &gt; 43\\,\\text{dB}\\) while meeting also the other performance requirements of Table 2 with margin. In addition, we check the voltage headroom of the critical MOSFET to see if we can squeeze it into the available supply voltage range, and see that this is possible with our above choice selection of parameters.\n\n\n\n\n\n\nExercise: Improved OTA Sizing\n\n\n\nPlease take a detailed look at the above sizing notebook and play with the numbers and calculations. Do you find a better trade-off for the input parameters? Can you understand the thinking process behind the choices and calculations?"
  },
  {
    "objectID": "analog_circuit_design.html#designing-the-improved-ota",
    "href": "analog_circuit_design.html#designing-the-improved-ota",
    "title": "Analog Circuit Design",
    "section": "10.2 Designing the Improved OTA",
    "text": "10.2 Designing the Improved OTA\nBased on the collected experience in this lecture and the result of the sizing procedure in Section 10.1 you should be able to design this OTA. If you want, please go ahead and try an implementation and check its performance with CACE.\nAs an alternative there is a prepared OTA design shown in Figure 42 which we will discuss in detail next.\n\n\n\n\n\n\nFigure 42: Improved OTA design in Xschem.\n\n\n\n\n10.2.1 Discussion of the OTA Design\nWe will now do an analysis of the circuit design of the OTA including all the complications which make this design practical.\n\nFor easier navigation, the device identifier are consistent with the circuit sketch in Figure 41.\nSome MOSFET dimensions are rounded to make a better fit in the IC layout. Please also look carefully at \\(W\\), \\(L\\), and \\(\\mathrm{ng}\\). The parameter \\(\\mathrm{ng}\\) defines how the total \\(W\\) of a MOSFET should be split into individual MOSFET fingers with \\(W_\\mathrm{f} = W / \\mathrm{ng}\\). This is done to arrive at a suitably sized MOSFET physical implementation. As we will not deal with IC layout in this lecture we will leave it at that.\nIn order to allow good matching in the IC layout, MOSFETs (and other components) have to be constructed from equal pieces. To that end, \\(W/L\\) scaling is done using unit elements (see finger width \\(W_\\mathrm{f}\\)). Sometimes, besides \\(W\\) the length \\(L\\) has to be scaled, and this leads to the oddly-looking series stacking of some MOSFET (easily recognizable by the connected gates). In order to increase circuit readability, a subcircuit could be constructed hiding this series stacking of MOSFET, but it is sometimes easier to avoid subcircuits. There is a fine line in this trade-off, sometime a depth of 4 is the decision point between subcircuit use/no-use.\nAs you can (hopefully) see the circuit is carefully drawn to ease readability. Important nets are named, text comments state certain properties like nominal voltage levels, bias currents, etc. Current sensing elements are added to directly see the dc currents in the circuit simulation.\nThe bias voltage generation for the cascodes is included as well. The voltage drop for the bottom transistors is developed by properly scaling the MOSFETs in the reference branch. We reduce the \\(W/L\\) ratio to increase the \\(V_\\mathrm{GS}\\) to create a voltage headroom for the bottom MOSFET. We are using a dummy branch for bias generation (constructed with \\(M_\\mathrm{7-10}\\)).\nThe floating bias voltage \\(V_\\mathrm{bias1}\\) is created by implementing a current source from \\(V_\\mathrm{DD}\\) (\\(M_\\mathrm{9}\\)), then a MOSFET diode \\(M_{10}\\), and an increased current towards \\(V_\\mathrm{SS}\\) through \\(M_\\mathrm{5}\\).\nPower-down transistors \\(M_{\\mathrm{pd,}x}\\) are added to allow a proper shutdown of the circuit with a digital enable input. It is generally a good idea to clamp floating nodes in off-mode so that no issues during power-down (like increased leakage currents) or delayed startup or shutdown are occurring. It is further a good design principle to buffer all incoming digital signals with inverters (\\(M_\\mathrm{pd,1-4}\\)) connected to the local supply. This lowers the risk of unwanted noise coupling or excessive slew rates on the incoming digital signals.\nSensitive bias nodes are buffered with decoupling capacitors. We are using MOSFETs as nonlinear capacitors, which is not an issue in this application, but we value the increased capacitive density. Please note how the MOSFET are connected (some are tied to \\(V_\\mathrm{DD}\\) while others are tied to \\(V_\\mathrm{SS}\\)).\n\n\n\n\n\n\n\nParallel Connection\n\n\n\nNote that a parallel connection of devices is effectively possible using the multiplier notation of Xschem."
  },
  {
    "objectID": "analog_circuit_design.html#simulation-of-improved-ota",
    "href": "analog_circuit_design.html#simulation-of-improved-ota",
    "title": "Analog Circuit Design",
    "section": "10.3 Simulation of Improved OTA",
    "text": "10.3 Simulation of Improved OTA\nNow that the circuit design of the improved OTA is done, we can use the same simulation testbenches as for the basic OTA. The testbenches are shown in Figure 43, Figure 44, and Figure 45.\n\n\n\n\n\n\nFigure 43: Simulation testbench of the improved OTA design (small-signal).\n\n\n\n\n\n\n\n\n\nFigure 44: Simulation testbench of the improved OTA design (large-signal).\n\n\n\n\n\n\n\n\n\nFigure 45: Simulation testbench of the improved OTA design (loop gain analysis).\n\n\n\n\n\n\n\n\n\nExercise: Improved OTA Initial Simulation\n\n\n\nPlease use the above testbenches to simulate the improved OTA:\n\nCheck the dc bias points. Are they good? How stable are they across PVT variations?\nWhat are the small-signal parameters like gain, noise and bandwidth? Are they fitting the specification?\nWhat is large-signal performance? Is the settling fast enough? Is the settling well behaved, i.e., are there overshoots or other strange ringing indicating potential stability issues?\nTry to improve the design. Change various device parameters and see what happens. Whenever you change something, check the dc operating point first. If the dc operating point is not good no further simulations make sense."
  },
  {
    "objectID": "analog_circuit_design.html#corner-simulation-of-improved-ota",
    "href": "analog_circuit_design.html#corner-simulation-of-improved-ota",
    "title": "Analog Circuit Design",
    "section": "10.4 Corner Simulation of Improved OTA",
    "text": "10.4 Corner Simulation of Improved OTA\nJust like for the basic OTA we use the CACE system to check the performance of the improved OTA design holistically across variations like PVT and input signal variations. The results of the CACE run are shown below in Note 3.\n\n\n\n\n\n\nNote 3: CACE Summary for Improved OTA\n\n\n\n\n\nCACE Summary for ota-improved\nnetlist source: schematic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nTool\nResult\nMin Limit\nMin Value\nTyp Target\nTyp Value\nMax Limit\nMax Value\nStatus\n\n\n\n\nOutput voltage ratio\nngspice\ngain\n0.99 V/V\n1.000 V/V\nany\n1.002 V/V\n1.01 V/V\n1.006 V/V\nPass ✅\n\n\nBandwidth\nngspice\nbw\n10e6 Hz\n146600000.000 Hz\nany\n206653000.000 Hz\nany\n254164000.000 Hz\nPass ✅\n\n\nOutput voltage ratio (MC)\nngspice\ngain_mc\nany\n0.809 V/V\nany\n1.023 V/V\nany\n1.304 V/V\nPass ✅\n\n\nBandwidth (MC)\nngspice\nbw_mc\n10e6 Hz\n24169400.000 Hz\nany\n171443500.000 Hz\nany\n279056000.000 Hz\nPass ✅\n\n\nOutput noise\nngspice\nnoise\nany\n0.309 mV\nany\n0.391 mV\n0.6 mV\n0.530 mV\nPass ✅\n\n\nSettling time\nngspice\ntsettle\nany\n0.134 us\nany\n0.141 us\n1 us\n0.151 us\nPass ✅\n\n\n\n\nPlots\n\n\ngain_vs_temp\n\n\n\ngain_vs_temp\n\n\n\n\ngain_vs_vin\n\n\n\ngain_vs_vin\n\n\n\n\ngain_vs_vdd\n\n\n\ngain_vs_vdd\n\n\n\n\ngain_vs_corner\n\n\n\ngain_vs_corner\n\n\n\n\nbw_vs_temp\n\n\n\nbw_vs_temp\n\n\n\n\nbw_vs_vin\n\n\n\nbw_vs_vin\n\n\n\n\nbw_vs_vdd\n\n\n\nbw_vs_vdd\n\n\n\n\nbw_vs_corner\n\n\n\nbw_vs_corner\n\n\n\n\ngain_mc\n\n\n\ngain_mc\n\n\n\n\nbw_mc\n\n\n\nbw_mc\n\n\n\n\nnoise_vs_temp\n\n\n\nnoise_vs_temp\n\n\n\n\nnoise_vs_vin\n\n\n\nnoise_vs_vin\n\n\n\n\nnoise_vs_vdd\n\n\n\nnoise_vs_vdd\n\n\n\n\nnoise_vs_corner\n\n\n\nnoise_vs_corner\n\n\n\n\nsettling_vs_temp\n\n\n\nsettling_vs_temp\n\n\n\n\nsettling_vs_vin\n\n\n\nsettling_vs_vin\n\n\n\n\nsettling_vs_vdd\n\n\n\nsettling_vs_vdd\n\n\n\n\nsettling_vs_corner\n\n\n\nsettling_vs_corner\n\n\n\n\n\n\nThe improved performance allows to improve the specifications in a few important points, notably the output voltage tolerance which is an important metric for a reference voltage buffer. We have intentionally increased the power consumption a little bit, but we negotiated with the chip lead designer a changed bias current level, so overall the situation is even slightly improved. The new situation with the improved design is summarized in Table 3 (unchanged entries are not shown).\n\n\n\nTable 3: Voltage buffer specification\n\n\n\n\n\n\n\n\n\n\n\nSpecification\nBasic 5T-OTA\nImproved OTA\nUnit\n\n\n\n\nOutput voltage error\n\\(&lt;3\\)\n\\(&lt;1\\)\n%\n\n\nTotal output noise (rms)\n\\(&lt;1\\)\n\\(&lt;0.6\\)\nmVrms\n\n\nSupply current (as low as possible)\n\\(&lt;10\\)\n\\(&lt;20\\)\nµA\n\n\nTurn-on time (settled to with 1%)\n\\(&lt;10\\)\n\\(&lt;1\\)\nµs\n\n\nExternally provided bias current (nominal)\n\\(20\\)\n\\(5\\)\nµA"
  },
  {
    "objectID": "analog_circuit_design.html#plots-1",
    "href": "analog_circuit_design.html#plots-1",
    "title": "Analog Circuit Design",
    "section": "Plots",
    "text": "Plots"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_temp-1",
    "href": "analog_circuit_design.html#gain_vs_temp-1",
    "title": "Analog Circuit Design",
    "section": "gain_vs_temp",
    "text": "gain_vs_temp\n\n\n\ngain_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_vin-1",
    "href": "analog_circuit_design.html#gain_vs_vin-1",
    "title": "Analog Circuit Design",
    "section": "gain_vs_vin",
    "text": "gain_vs_vin\n\n\n\ngain_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_vdd-1",
    "href": "analog_circuit_design.html#gain_vs_vdd-1",
    "title": "Analog Circuit Design",
    "section": "gain_vs_vdd",
    "text": "gain_vs_vdd\n\n\n\ngain_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#gain_vs_corner-1",
    "href": "analog_circuit_design.html#gain_vs_corner-1",
    "title": "Analog Circuit Design",
    "section": "gain_vs_corner",
    "text": "gain_vs_corner\n\n\n\ngain_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_temp-1",
    "href": "analog_circuit_design.html#bw_vs_temp-1",
    "title": "Analog Circuit Design",
    "section": "bw_vs_temp",
    "text": "bw_vs_temp\n\n\n\nbw_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_vin-1",
    "href": "analog_circuit_design.html#bw_vs_vin-1",
    "title": "Analog Circuit Design",
    "section": "bw_vs_vin",
    "text": "bw_vs_vin\n\n\n\nbw_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_vdd-1",
    "href": "analog_circuit_design.html#bw_vs_vdd-1",
    "title": "Analog Circuit Design",
    "section": "bw_vs_vdd",
    "text": "bw_vs_vdd\n\n\n\nbw_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#bw_vs_corner-1",
    "href": "analog_circuit_design.html#bw_vs_corner-1",
    "title": "Analog Circuit Design",
    "section": "bw_vs_corner",
    "text": "bw_vs_corner\n\n\n\nbw_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#gain_mc-1",
    "href": "analog_circuit_design.html#gain_mc-1",
    "title": "Analog Circuit Design",
    "section": "gain_mc",
    "text": "gain_mc\n\n\n\ngain_mc"
  },
  {
    "objectID": "analog_circuit_design.html#bw_mc-1",
    "href": "analog_circuit_design.html#bw_mc-1",
    "title": "Analog Circuit Design",
    "section": "bw_mc",
    "text": "bw_mc\n\n\n\nbw_mc"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_temp-1",
    "href": "analog_circuit_design.html#noise_vs_temp-1",
    "title": "Analog Circuit Design",
    "section": "noise_vs_temp",
    "text": "noise_vs_temp\n\n\n\nnoise_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_vin-1",
    "href": "analog_circuit_design.html#noise_vs_vin-1",
    "title": "Analog Circuit Design",
    "section": "noise_vs_vin",
    "text": "noise_vs_vin\n\n\n\nnoise_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_vdd-1",
    "href": "analog_circuit_design.html#noise_vs_vdd-1",
    "title": "Analog Circuit Design",
    "section": "noise_vs_vdd",
    "text": "noise_vs_vdd\n\n\n\nnoise_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#noise_vs_corner-1",
    "href": "analog_circuit_design.html#noise_vs_corner-1",
    "title": "Analog Circuit Design",
    "section": "noise_vs_corner",
    "text": "noise_vs_corner\n\n\n\nnoise_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_temp-1",
    "href": "analog_circuit_design.html#settling_vs_temp-1",
    "title": "Analog Circuit Design",
    "section": "settling_vs_temp",
    "text": "settling_vs_temp\n\n\n\nsettling_vs_temp"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_vin-1",
    "href": "analog_circuit_design.html#settling_vs_vin-1",
    "title": "Analog Circuit Design",
    "section": "settling_vs_vin",
    "text": "settling_vs_vin\n\n\n\nsettling_vs_vin"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_vdd-1",
    "href": "analog_circuit_design.html#settling_vs_vdd-1",
    "title": "Analog Circuit Design",
    "section": "settling_vs_vdd",
    "text": "settling_vs_vdd\n\n\n\nsettling_vs_vdd"
  },
  {
    "objectID": "analog_circuit_design.html#settling_vs_corner-1",
    "href": "analog_circuit_design.html#settling_vs_corner-1",
    "title": "Analog Circuit Design",
    "section": "settling_vs_corner",
    "text": "settling_vs_corner\n\n\n\nsettling_vs_corner"
  },
  {
    "objectID": "analog_circuit_design.html#bandgap-reference",
    "href": "analog_circuit_design.html#bandgap-reference",
    "title": "Analog Circuit Design",
    "section": "11.1 Bandgap Reference",
    "text": "11.1 Bandgap Reference\nIt has been realized that a bipolar junction transistor (BJT) has the wonderful property, that the base-emitter voltage \\(V_\\mathrm{BE}\\) has the following approximate relationship vs. temperature (R. J. Widlar 1971)\n\\[\nV_\\mathrm{BE}\\approx V_\\mathrm{g0} \\left( 1 - \\frac{T}{T_0} \\right) + V_\\mathrm{BE0} \\left( \\frac{T}{T_0} \\right)\n\\tag{37}\\]\nwhere \\(V_\\mathrm{g0} = 1.205\\,\\text{V}\\) is the bandgap voltage of silicon at \\(0\\,\\text{K}\\) and \\(V_\\mathrm{BE0}\\) is the base-emitter voltage of a BJT as reference temperature \\(T_0\\). Further, the difference in \\(V_\\mathrm{BE}\\) of two BJT operated at different emitter current densities \\(J_1\\) and \\(J_2\\) is given as\n\\[\n\\Delta V_\\mathrm{BE}= \\frac{k T}{q} \\ln \\left( \\frac{J_1}{J_2} \\right)\n\\tag{38}\\]\nwith \\(k\\) the Boltzmann constant, and \\(q\\) the elementary charge.\nAdding Equation 37 and Equation 38 results in a reference voltage of value\n\\[\nV_\\mathrm{ref} =  V_\\mathrm{g0} \\left( 1 - \\frac{T}{T_0} \\right) + V_\\mathrm{BE0} \\left( \\frac{T}{T_0} \\right) +  \\frac{k T}{q} \\ln \\left( \\frac{J_1}{J_2} \\right)\n\\tag{39}\\]\nwhich can be made temperature-insensitive when the terms, which are a function of \\(T\\), cancel each other, and only\n\\[\nV_\\mathrm{ref} =  V_\\mathrm{g0}\n\\tag{40}\\]\nremains. We thus have created an on-chip reference (called the bandgap voltage reference) which is almost independent of manufacturing tolerances with zero temperature coefficient. Of course, this is only true neglecting second-order effects, but nevertheless, reference accuracies of \\(\\pm 1 \\ldots 3\\%\\) without trimming are perfectly possible.\nThe original implementation in (R. J. Widlar 1971) uses NPN transistors. The question is, where do we find BJT in a CMOS process? Luckily, when looking at the typical implementations, we find that there is a layer sandwich of P-N-P available. While the PNPs constructed parasitically out of this available layers are available for free without extra processing cost, they are very slow, show unusually small \\(\\beta &lt; 10\\), and the collector is tied to \\(V_\\mathrm{SS}\\) as it is the substrate. Still, for bandgap references, they are very useful.\nA simple implementation of a bandgap reference circuit is shown in Figure 47. If we scale \\(R_1\\) and \\(R_2\\) correctly then we can achieve Equation 40. Note that the output voltage is ca. \\(1.2\\,\\text{V}\\), so operating this circuit on low supply voltages will be problematic.\n\n\n\n\n\n\n\n\nFigure 47: A simple bandgap reference.\n\n\n\n\n\n\\(M_1\\) to \\(M_4\\) are scaled in a way that in both branches the same bias current is flowing. Further, \\(M_1\\) and \\(M_2\\) ensure that there is the same potential at their sources. Since the PNP are scaled by the factor \\(n\\) (thus the current density is different) so that the following voltage develops across \\(R_1\\):\n\\[\n\\Delta V_\\mathrm{BE}= \\frac{k T}{q} \\ln m\n\\]\nHence, the bias current in all the branches is given by\n\\[\nI_\\mathrm{bias} = \\frac{\\Delta V_\\mathrm{BE}}{R_1} = \\frac{1}{R_1} \\frac{k T}{q} \\ln m.\n\\tag{41}\\]\nInspecting Equation 41 we see that \\(I_\\mathrm{bias} = k_1 T\\) is a linear function of temperature \\(T\\), a property that is very useful and called PTAT (proportional to absolute temperature). With \\(M_5\\) we mirror this bias current into the output branch, and the output voltage \\(V_\\mathrm{ref}\\) is then given by\n\\[\nV_\\mathrm{ref} = V_\\mathrm{BE}+ \\frac{R_2}{R_1} \\frac{k T}{q} \\ln m.  \n\\]\nBy proper selection of \\(R_1\\), \\(R_2\\) and \\(m\\) we can satisfy Equation 39 to result in Equation 40.\n\n\n\n\n\n\nImproved Bandgap Reference\n\n\n\nFor an improved implementation of Figure 47, the current mirrors should be cascoded, and a startup circuit should be included to guarantee proper operation after enabling it. Further, Equation 37 and Equation 38 build on the relationship \\(I_\\mathrm{C} = f(V_\\mathrm{BE})\\), while we control \\(I_\\mathrm{E}\\) in this circuit. If \\(\\beta\\) is large then \\(I_\\mathrm{C} \\approx I_\\mathrm{E}\\), but this is not the case for the used PNPs.\n\n\nThe circuit of Figure 47 has been implemented in Xschem and is shown in Figure 48. The current sources have been improved by using cascodes. We are using the low-voltage current mirror type already introduced in Section 10. The bias voltages for the cascodes are generated via the voltage drops of \\(R_3\\) and \\(R_4\\), respectively.\nNo base current compensation for the BJTs is implemented, as it is assumed that the \\(\\beta\\) of the PNP are similar although they are operated at different emitter current densities.\nNote the addition of a startup branch with \\(M_\\mathrm{startup}\\) which is inactive during normal operation but will inject a startup current if no proper bias point has yet been found.\nThere is no circuitry added for enabling/disabling the circuit, which would also be needed for a practical implementation. As usual, the MOSFET sizing has been done in this notebook.\nThe resistors \\(R_{1-4}\\) have been implemented out of unit elements of ca. \\(5\\,\\text{k}\\Omega\\) for optimum matching. Building a bandgap for the first time on silicon likely will show a slightly deviating temperature coefficient, which is why we keep a few dummy resistors around in \\(R_2\\) to compensate the TC in a redesign.\n\n\n\n\n\n\nFigure 48: Simple bandgap reference circuit in Xschem.\n\n\n\nThe Xschem schematic is available here and the simulated reference voltage vs. temperature is shown in Figure 49. For a typical process we achieve a TC of \\(\\pm 0.2\\%\\).\n\n\n\n\n\n\n\n\nFigure 49: Reference voltage from simulated bandgap circuit.\n\n\n\n\n\nPlease note how tight the dc operating point is in this design to keep all MOSFET saturated. We only use \\(100\\,\\text{mV}\\) nominally as headroom. The circuit in Figure 48 works only marginally at \\(V_\\mathrm{DD}= 1.5\\,\\text{V}\\), but would not work at \\(1.2\\,\\text{V}\\) or lower. Improved circuit architectures for \\(&lt;1\\,\\text{V}\\) operation exist Eberlein, Panagopoulos, and Pretl (2018)."
  },
  {
    "objectID": "analog_circuit_design.html#sec-banba-bandgap",
    "href": "analog_circuit_design.html#sec-banba-bandgap",
    "title": "Analog Circuit Design",
    "section": "11.2 Banba Bandgap Reference",
    "text": "11.2 Banba Bandgap Reference\nThe Banba reference (Banba et al. 1999) is quite a bit trickier to design than the classical bandgap shown in Figure 47. It requires the use of an error amplifier; luckily, we can use the 5T-OTA which we designed in Section 8. Since a loop is involved the startup of this circuit is not easy and requires the use of a transient simulation and a proper pre-charge of critical nodes. We can use the ngspice scripting language to (a) set the temperature for a sweep, (b) run a transient simulation, and (c) capture the final reference voltage and save it.\nA first design has been implemented and is shown in Figure 50, and the testbench is shown in Figure 51. The supply voltage (which could be lower than \\(1.5\\,\\text{V}\\)) is limited by our OTA design; however, it works well at \\(V_\\mathrm{DD}= 1.5\\,\\text{V}\\). The simulated reference voltage (which is scaled to roughly \\(V_\\mathrm{bandgap} / 2\\)) is shown in Figure 52.\n\n\n\n\n\n\nFigure 50: Banba bandgap reference circuit in Xschem.\n\n\n\nNote the self-biasing of the OTA with the current generated in the reference branches. The feedback loop needs capacitors for stabilization, and we use area-efficient MOSFET for this task. For a detailed explanation of this circuit please refer to (Banba et al. 1999), but in brief, the operation is as follows:\nThe CTAT and PTAT currents required for compensating each others TC’s are built using a \\(\\Delta V_\\mathrm{BE}\\) cell (given the PTAT current) with parallel resistors (providing the CTAT current). Voltages are sensed using an error amplifier and current sources are controlled to achieve matching currents in both branches. This current can then also be mirrored to flow through another resistor which can be scaled to produce the output voltage.\nIn comparison to the classical bandgap reference shown in Figure 47 (where the developed currents in all branches are PTAT) the currents developed in the Banba reference are constant vs. temperature.\nThe minimum supply voltage for the Banba reference is the \\(V_\\mathrm{BE}\\) of the PNP plus the saturation voltage of one MOSFET current source, so ca. \\(V_\\mathrm{DDmin} \\ge 0.8\\,\\text{V} + 0.2\\,\\text{V} \\approx 1\\,\\text{V}\\). Of course we also need to design an OTA which can work at this low supply.\n\n\n\n\n\n\nFigure 51: Banba bandgap testbench Xschem.\n\n\n\n\n\n\n\n\n\n\n\nFigure 52: Reference voltage from simulated Banba bandgap circuit.\n\n\n\n\n\nA well described design of a Banba bandgap reference (including a two-stage OTA and a regulated cascode for the output current mirror), covering much more details than discussed here, can be found in [Razavi_2021_bandgap].\n\n\n\n\n\n\nExercise: Improved Low-Voltage Bandgap\n\n\n\nAs an optional exercise for advanced users: Design a bandgap circuit following [Razavi_2021_bandgap]. Implement the shown two-stage OTA and the regulated cascode.\nAs a starting point, the design of Section 11.2 can be used. As this design will contain more blocks, please build up a hierarchical design, with the OTAs designed in separate subcircuits."
  },
  {
    "objectID": "analog_circuit_design.html#miller-compensation",
    "href": "analog_circuit_design.html#miller-compensation",
    "title": "Analog Circuit Design",
    "section": "12.1 Miller Compensation",
    "text": "12.1 Miller Compensation\nA popular way to stabilize a multi-pole feedback-system is to make one pole dominant, and try to shift the other poles to sufficiently high frequencies, that we have enough phase margin in the closed-loop system. We may strive for \\(60^\\circ\\) as this will only cause a minor peaking in the frequency response (Gray et al. 2009).\nThe question now is where to implement this dominant pole. In order to create a low-frequency pole we need a high-impedance point and a large capacitance. Placing just a large capacitor is unwelcome, as this causes large area consumption on chip.\nLuckily, we know from the analysis in Section 16.1 that we can use voltage gain to increase the apparent value of a capacitor by feedback. Inspecting our circuit in Figure 53 we see that we have voltage gain from node \\(A\\) to node \\(B\\) and node \\(A'\\) and \\(B'\\), respectively. This means we have an opportunity to strap a capacitor between those nodes, and create a dominant pole at node \\(A\\) (and \\(A'\\)).\nWe can now add these so-called “Miller capacitors” to our circuit. The result is shown in Figure 54. (We have also added resistors in series with the capacitors; we ignore these resistors for the time being).\n\n\n\n\n\n\n\n\nFigure 54: Differential two-stage OTA with resistive load and Miller compensation.\n\n\n\n\n\nIt is instructive to look at the small-signal equivalent circuit of the common-source stage \\(M_4\\) loaded by current-source \\(M_7\\). The resulting model is shown in Figure 55 (we are ignoring the bulk effect of \\(M_4\\), and lump components of \\(M_{4,7}\\) into the input and the output impedances formed by \\(C_\\mathrm{L}\\), \\(C_\\mathrm{in}\\), \\(g_\\mathrm{in}\\) and \\(g_\\mathrm{out}\\)).\n\n\n\n\n\n\n\n\nFigure 55: Small-signal model of common-source stage with Miller compensation.\n\n\n\n\n\nIn order to analyze the transfer function and thus the poles and zeros of this configuration we formulate KCL at the input and output node and the current through \\(C_\\mathrm{m}\\) (we set \\(R_\\mathrm{m}=0\\) for now):\n\\[\nI_\\mathrm{in} + I_\\mathrm{m} - V_\\mathrm{gs} (s C_\\mathrm{in} + g_\\mathrm{in}) = 0\n\\tag{42}\\]\n\\[\n-I_\\mathrm{m} - g_\\mathrm{m}V_\\mathrm{gs} - V_\\mathrm{out} (s C_\\mathrm{L} + g_\\mathrm{out}) = 0\n\\tag{43}\\]\n\\[\nI_\\mathrm{m} = s C_\\mathrm{m} (V_\\mathrm{out} - V_\\mathrm{gs})\n\\tag{44}\\]\nUsing Equation 44 in Equation 42 and Equation 43 and then calculating the transfer function we arrive at\n\\[\n\\frac{V_\\mathrm{out}}{I_\\mathrm{in}} = \\frac{s C_\\mathrm{m} - g_\\mathrm{m}}{(s C_\\mathrm{m} + s C_\\mathrm{L} + g_\\mathrm{out})(s C_\\mathrm{m} + s C_\\mathrm{in} + g_\\mathrm{in}) - (s C_\\mathrm{m} - g_\\mathrm{m}) s C_\\mathrm{m}}.\n\\tag{45}\\]\nIn order to check Equation 45 we can set \\(s C_\\mathrm{m} = 0\\) and see whether we can interpret the result:\n\\[\n\\frac{V_\\mathrm{out}}{I_\\mathrm{in}} = -\\frac{g_\\mathrm{m}}{(s C_\\mathrm{L} + g_\\mathrm{out})(s C_\\mathrm{in} + g_\\mathrm{in})} = -\\frac{g_\\mathrm{m}}{g_\\mathrm{out} g_\\mathrm{in}}\n\\frac{1}{\\left( 1 + \\frac{s C_\\mathrm{L}}{g_\\mathrm{out}} \\right)}\n\\frac{1}{\\left( 1 + \\frac{s C_\\mathrm{in}}{g_\\mathrm{in}} \\right)}\n\\tag{46}\\]\nWe find that Equation 46 looks reasonable, as we have the correct dc gain of \\(-g_\\mathrm{m}/(g_\\mathrm{out} g_\\mathrm{in})\\) and two poles, one at the input and one at the output.\nWe now return to the more interesting case of \\(s C_\\mathrm{m} \\neq 0\\). We use the reasonable assumption that \\(g_\\mathrm{m}\\gg g_\\mathrm{in,out}\\) to simplify the algebra and result in an interpretable result. After quite a few pages of algebraic manipulations (please try for yourself!) we arrive at\n\\[\n\\frac{V_\\mathrm{out}}{I_\\mathrm{in}} = -\\frac{g_\\mathrm{m}}{g_\\mathrm{out} g_\\mathrm{in}}\n\\frac{\\left( 1 - \\frac{s C_\\mathrm{m}}{g_\\mathrm{m}} \\right)}\n{\n\\left( 1 + s \\frac{C_\\mathrm{L} + C_\\mathrm{in} + \\frac{C_\\mathrm{in} C_\\mathrm{L}}{C_\\mathrm{m}}}{g_\\mathrm{m}} \\right)\n\\left( 1 + s \\frac{C_\\mathrm{m} \\frac{g_\\mathrm{m}}{g_\\mathrm{out}}}{g_\\mathrm{in}} \\right)\n}.\n\\tag{47}\\]\nLooking at Equation 47 we can identify important changes compared to Equation 46. We have the intended low-frequency pole \\(s_\\mathrm{p1}\\) at the input where the capacitor \\(C_\\mathrm{m}\\) is increased by the dc gain of the common-source stage \\(g_\\mathrm{m}/ g_\\mathrm{out}\\):\n\\[\ns_\\mathrm{p1} = -\\frac{g_\\mathrm{in}}{C_\\mathrm{m} \\frac{g_\\mathrm{m}}{g_\\mathrm{out}}}\n\\]\nWe further have a high frequency pole \\(s_\\mathrm{p2}\\) where the pole at the output has been shifted to higher frequencies! This is a very welcome effect called pole splitting, and it helps to stabilize the feedback system, as the nondominant (output) pole is shifted out in frequency while the dominant (input) pole is pulled in.\n\\[\ns_\\mathrm{p2} = -\\frac{g_\\mathrm{m}}{C_\\mathrm{L} + C_\\mathrm{in} + \\frac{C_\\mathrm{in} C_\\mathrm{L}}{C_\\mathrm{m}}}\n\\]\nTogether, the movement of poles \\(s_\\mathrm{p1}\\) and \\(s_\\mathrm{p2}\\) is a great deal in terms of stability. However, not all is rosy, as we have to also look at the numerator of Equation 47. Here we see that a zero \\(s_\\mathrm{z}\\) has been formed, unfortunately a quite bad one. Calculating its location as\n\\[\ns_\\mathrm{z} = +\\frac{g_\\mathrm{m}}{C_\\mathrm{m}}\n\\tag{48}\\]\nwe see that it is located in the right half-plane of the s-domain. Such a zero leads to a rise of the magnitude of the transfer function (this is generally not a bad thing), but the phase contribution of this zero is negative. This means that we are loosing phase margin, yet we push available gain to higher frequencies; in other words, we are degrading phase- and gain-margin!\nA circuit-level interpretation of this effect is that while the Miller capacitor is wanted at the input of the amplifier (i.e., the feedback path), it also allows the input signal to pass to the output (i.e., the forward path). Since in normal operation the signal is inverted and in feed-forward mode it is not we have this unwanted effect of phase shift.\nLuckily, there are several techniques to break the feed-forward path while keeping the feedback path (e.g., using a source follower to drive the output side of the Miller capacitor). For our purposes, we use a slightly simpler technique of adding a resistor in series to the Miller capacitor (see Figure 54 and Figure 55). Doing this we can modify the location of this zero, and even push it into the left-half-plane. This is excellent news for stability, as now this zero helps to improve gain- and phase-margin!\nRepeating the calculation of the transfer function \\(V_\\mathrm{out} / I_\\mathrm{in}\\) including \\(R_\\mathrm{m}\\) we see that the zero location is changed and can be calculated as (the pole locations are also slightly changed due to the addition of \\(R_\\mathrm{m}\\), but we will not discuss the resulting equations here)\n\\[\ns_\\mathrm{z} = \\frac{g_\\mathrm{m}}{C_\\mathrm{m} (1 - g_\\mathrm{m}R_\\mathrm{m})}\n\\tag{49}\\]\nIf we do not use the resistor (i.e., \\(R_\\mathrm{m}=0\\)) then Equation 49 collapses to Equation 48. If \\(g_\\mathrm{m}R_\\mathrm{m} &lt; 1\\) then the zero stays in the right half-plane; if \\(g_\\mathrm{m}R_\\mathrm{m} &gt; 1\\) then the zero moves into the left half-plane (this is what we want). If \\(g_\\mathrm{m}R_\\mathrm{m} = 1\\) then we have compensated the zero at it moves to \\(-\\infty\\); however, in practice exact compensation is not easy to establish across conditions, so we want to move the zero into the left half-plane. Adding a bit of margin want to size\n\\[\nR_\\mathrm{m} &gt; \\frac{2}{g_\\mathrm{m}}.\n\\]"
  },
  {
    "objectID": "analog_circuit_design.html#common-mode-regulation",
    "href": "analog_circuit_design.html#common-mode-regulation",
    "title": "Analog Circuit Design",
    "section": "12.2 Common-Mode Regulation",
    "text": "12.2 Common-Mode Regulation\nIn fully-differential (i.e., differential inputs and outputs) OTAs we have a new issue concerning common-mode voltage control: Depending on the feedback network around the OTA we might or might not have a defined dc operating point (common-mode wise). Think of the following scenario: If implement an integrator with an OTA then the feedback network from output to input consists of a capacitor. This means that the output of the OTA is loaded very high ohmic, and any small current mismatch between \\(M_4\\)/\\(M_7\\) or \\(M_6\\)/\\(M_8\\) (see Figure 54) will cause a strong deviation of the dc operating point at the output!\nWe can not accept that the dc operating points in a circuit are ill defined. We thus need a way to establish the dc operating point. Using the diode-resistive load for the differential pair in Figure 54 the dc operating point there is well-defined by the diode-connected \\(M_{3,5}\\). However, the output stage is different, and we need to add circuitry to also control the dc operating point there.\nOne well-known way is to sense the common-mode voltage using two resistors (similar to \\(R_{1,2}\\) in Figure 54), and compare this measured common-mode voltage to a reference voltage using an error amplifier. Then the output of the error amplifier controls the common-mode voltage, e.g., by driving the gates of \\(M_{7,8}\\) in Figure 54.\n\n\n\n\n\n\nDifferential and Common-Mode Loops\n\n\n\nWhen using an error amplifier to regulate a common-mode point keep in mind that you need to check the differential and common-mode stability of these various loops! This can lead to tricky situations, especially under large-signal excitation where the common-mode sensing might not work as expected!\nIn order to get a differential circuit stable one often has to make the common-mode loop faster than the differential loops. So simple, high-speed error amplifiers are an advantage.\nIn summary, stability investigations are critically important for differential circuits, and never forget to check for common-mode stability as well!\n\n\nInstead of a common-mode regulation loop (and all its complications regarding stability) often a common-mode setting is sufficient (after all, a somewhat imprecise setting of the dc points is good enough). A common-mode setting has the advantage that no error amplifier is required. We will also use this approach of a common-mode loop setting in the adapted differential OTA shown in Figure 56.\n\n\n\n\n\n\n\n\nFigure 56: Differential two-stage OTA with resistive load, Miller compensation and output common-mode control.\n\n\n\n\n\nResistors \\(R_{3,4}\\) sense the output voltages and create a replica of the common-mode point (assuming \\(R_3 = R_4\\)). This common-mode point is connected to the gates of \\(M_{7,8}\\) to essentially connect \\(M_{7,8}\\) like a diode (only for common-mode operation); in differential mode, \\(M_7\\) and \\(M_8\\) act as current source, like the load of the differential pair \\(M_{3,5}\\). However, since we want to set the common-mode voltage at the output independently from \\(V_\\mathrm{GS7,8}\\) we also pull a current through \\(R_{3,4}\\) to cause \\(V_\\mathrm{DS7,8} \\neq V_\\mathrm{GS7,8}\\); essentially, this is a diode connection including a voltage shift! The output common-mode voltage is then given by\n\\[\nV_\\mathrm{out,cm} = V_\\mathrm{GS7,8} + \\frac{R_{3,4} I_\\mathrm{D11}}{2}.\n\\]\n\n\n\n\n\n\nModify Bias Points with Currents\n\n\n\nKeep the technique shown in Figure 56 (using \\(R_{3,4}\\) and \\(M_{11}\\)) in mind: You can always modify a bias point by injecting a dc current into a node, or by pulling a dc current out of a node (or do both to increase or lower the quiescent current through a resistor or transistor)! Since we likely have already current mirrors in the circuit it is usually a minor effort adding MOSFETs to create these bias currents."
  },
  {
    "objectID": "analog_circuit_design.html#sec-miller-theorem",
    "href": "analog_circuit_design.html#sec-miller-theorem",
    "title": "Analog Circuit Design",
    "section": "16.1 Miller’s Theorem",
    "text": "16.1 Miller’s Theorem\nUsing Miller’s theorem we can find the equivalent circuit of an impedance connected between two nodes, and we know the transfer function between these nodes. The given situation is shown in Figure 59, and the equivalent circuit is shown in Figure 60.\n\n\n\n\n\n\n\n\nFigure 59: An impedance connected between two nodes A and B.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 60: An equivalent circuit using Miller’s theorem.\n\n\n\n\n\nUsing Miller’s theorem (Sheikholeslami 2015) we can calculate \\[\nZ_1 = \\frac{Z}{1 - A} = \\frac{Z}{1 - V_\\mathrm{B} / V_\\mathrm{A}}\n\\] and \\[\nZ_2 = \\frac{Z}{1 - A^{-1}} = \\frac{Z}{1 - V_\\mathrm{A} / V_\\mathrm{B}}\n\\] to arrive at an equivalent circuit, given that \\(A = V_\\mathrm{B} / V_\\mathrm{A}\\) is the voltage gain between nodes A and B. A derivation of this theorem is relative straightforward considering the current through \\(Z\\) when looking into the impedance from either node A or node B and calculating an equivalent impedance causing the same current.\nNote that if \\(V_\\mathrm{A} = V_\\mathrm{B}\\) then there is no current flow through \\(Z\\), and accordingly the impedances \\(Z_1 = Z_2 = \\infty\\).\nMiller’s theorem can be quite handy when an impedance is strapped between two nodes, and we want to break this connection in a calculation, e.g., considering the effect of \\(C_\\mathrm{GD}\\) in a MOSFET.\n\n\n\n\n\n\nMiller’s Secret\n\n\n\nNote that Miller’s compensation is so much more than just making a big capacitor out of a small one. There are layers upon layers of subtlety, and huge hidden benefits which can be read in (Mangelsdorf 2025)."
  },
  {
    "objectID": "analog_circuit_design.html#sec-bode-noise-theorem",
    "href": "analog_circuit_design.html#sec-bode-noise-theorem",
    "title": "Analog Circuit Design",
    "section": "16.2 Bode’s Noise Theorem",
    "text": "16.2 Bode’s Noise Theorem\nThe total integrated noise of any (no matter how complicated) \\(RLC\\) network (interpreted as a one-port) is given by\n\\[\n\\overline{V_\\mathrm{n}^2} = kT \\left( \\frac{1}{C_\\infty} - \\frac{1}{C_0} \\right),\n\\]\nwhere \\(C_\\infty\\) is the capacitance looking into the network with all resistors and inductors open-circuited, and \\(C_0\\) is the capacitance looking into the circuit when all inductors and resistors are shorted (Pavan 2019).\nReference (Pavan 2019) is an excellent read deriving Bode’s noise theorem from different angles."
  },
  {
    "objectID": "analog_circuit_design.html#open-loop-configuration",
    "href": "analog_circuit_design.html#open-loop-configuration",
    "title": "Analog Circuit Design",
    "section": "17.1 Open-Loop Configuration",
    "text": "17.1 Open-Loop Configuration\nFor the open-loop case, the gates of \\(M_1\\) and \\(M_2\\) are tied to ground and thus, both \\(v_\\mathrm{gs}\\) are equal. \\[\nv_\\mathrm{in,p}=v_\\mathrm{in,n}=0~\\text{V}\n\\] \\[\nv_\\mathrm{gs1} = v_\\mathrm{gs2}\n\\tag{50}\\]\nKCL at the output node: \\[\ni_\\mathrm{out} -g_\\mathrm{ds4} v_\\mathrm{out} - g_\\mathrm{m34}v_\\mathrm{gs34} - i_{g_\\mathrm{ds2}} - g_\\mathrm{m2}v_\\mathrm{gs2} = 0\n\\tag{51}\\]\nKCL at the tail node: \\[\ng_\\mathrm{m1}v_\\mathrm{gs1} + g_\\mathrm{m2}v_\\mathrm{gs2} + i_{g_\\mathrm{ds2}} + g_\\mathrm{ds5}v_\\mathrm{gs2} = 0\n\\]\nUsing Equation 50 we can eliminate \\(v_\\mathrm{gs1}\\) and solve for \\(i_{g_\\mathrm{ds2}}\\). \\[\ni_{g_\\mathrm{ds2}} = -\\left(g_\\mathrm{m1}+g_\\mathrm{m2}+g_\\mathrm{ds5}\\right)v_\\mathrm{gs2}\n\\tag{52}\\]\nFurthermore, we need an expression for \\(v_\\mathrm{gs34}\\). Ohm’s law at the conductance \\(g_\\mathrm{m34}\\) will suffice. \\[\nv_\\mathrm{gs34} = -\\frac{g_\\mathrm{m1}}{g_\\mathrm{m34}}v_\\mathrm{gs1}\n\\tag{53}\\]\nKVL from the output node down to ground (over \\(g_\\mathrm{ds2}\\) and \\(g_\\mathrm{ds5}\\)) in combination with Equation 52 gives us an expression for \\(v_\\mathrm{gs2}\\) \\[\nv_\\mathrm{gs2} = -\\frac{g_\\mathrm{ds2}}{g_\\mathrm{m1}+g_\\mathrm{m2}+g_\\mathrm{ds2}+g_\\mathrm{ds5}}v_\\mathrm{out}\n\\tag{54}\\]\nNow, we can plug in all quantities into Equation 51. First, Equation 52 is inserted, which provides an expression for the current through the output conductance \\(g_\\mathrm{ds2}\\) of \\(M_2\\). \\[\ni_\\mathrm{out} -g_\\mathrm{ds4} v_\\mathrm{out} - g_\\mathrm{m34}v_\\mathrm{gs34} + \\left(g_\\mathrm{m1}+g_\\mathrm{ds5}\\right)v_\\mathrm{gs2} = 0\n\\]\nSecond, \\(v_\\mathrm{gs34}\\) is substituted by Equation 53. Since we have assumed a matched pair of transistors for the current mirror comprised of \\(M_3\\) and \\(M_4\\), \\(g_\\mathrm{m34}\\) perfectly cancels out of the equation, and is effectively replaced by the transconductance \\(g_\\mathrm{m1}\\) of the input transistor \\(M_1\\). \\[\ni_\\mathrm{out} -g_\\mathrm{ds4} v_\\mathrm{out} + \\left(2g_\\mathrm{m1}+g_\\mathrm{ds5}\\right)v_\\mathrm{gs2} = 0\n\\]\nThird, Equation 54 gives as an expression for the last remaining unknown \\(v_\\mathrm{gs2}\\). Thus, the factor in front of \\(v_\\mathrm{out}\\) defines the conductance at the output node. \\[\ni_\\mathrm{out} -\\left[g_\\mathrm{ds4} + \\left(2g_\\mathrm{m1}+g_\\mathrm{ds5}\\right)\\frac{g_\\mathrm{ds2}}{g_\\mathrm{m1}+g_\\mathrm{m2}+g_\\mathrm{ds2}+g_\\mathrm{ds5}}\\right]v_\\mathrm{out} = 0\n\\tag{55}\\] Before, we interpret this result, we use are assumption of matched input transistors (\\(g_\\mathrm{m12}=g_\\mathrm{m1}=g_\\mathrm{m2}\\)) and slightly rearrange the equation to give us more insight. \\[\ni_\\mathrm{out} -\\left[g_\\mathrm{ds4} + \\frac{g_\\mathrm{ds2}\\cdot\\left(2g_\\mathrm{m12}+g_\\mathrm{ds5}\\right)}{g_\\mathrm{ds2}+\\left(2g_\\mathrm{m12}+g_\\mathrm{ds5}\\right)}\\right]v_\\mathrm{out} = 0\n\\tag{56}\\] Now, we can identify the common equation of the total resistance of two parallel resistors. However, we are dealing with conductances here, so the same equation describes the total conductance of two conductances in series, while parallel conductances are simply summed. In parallel to \\(g_\\mathrm{ds4}\\), there is effectively the series connection of \\(g_\\mathrm{ds2}\\) and \\(\\left(2g_\\mathrm{m12}+g_\\mathrm{ds5}\\right)\\) at work. If we apply the general assumption of \\(g_\\mathrm{m}\\gg g_\\mathrm{ds}\\), only the parallel connection of \\(g_\\mathrm{ds4}\\) and \\(g_\\mathrm{ds2}\\) remains. Therefore, moving \\(g_\\mathrm{ds2} + g_\\mathrm{ds4}\\) in parallel to \\(C_\\mathrm{load}\\) in Section 8.3 was valid. \\[\n\\frac{i_\\mathrm{out}}{v_\\mathrm{out}}\\approx g_\\mathrm{ds4} + g_\\mathrm{ds2}\n\\tag{57}\\]"
  },
  {
    "objectID": "analog_circuit_design.html#closed-loop-configuration",
    "href": "analog_circuit_design.html#closed-loop-configuration",
    "title": "Analog Circuit Design",
    "section": "17.2 Closed-Loop Configuration",
    "text": "17.2 Closed-Loop Configuration\nIn contrast to the open-loop case, we keep the gate of \\(M_1\\) connected to ground and tie the input of \\(M_2\\) to the output node \\(v_\\mathrm{out}\\). \\[\nv_\\mathrm{in,n} = v_\\mathrm{out}\n\\tag{58}\\]\nKCL at the output node: \\[\ni_\\mathrm{out} -g_\\mathrm{ds4} v_\\mathrm{out} - g_\\mathrm{m34}v_\\mathrm{gs34} - g_\\mathrm{ds2}v_\\mathrm{gs2} - g_\\mathrm{m2}v_\\mathrm{gs2} = 0\n\\tag{59}\\]\nWe use KVL from the output node down to ground to find an expression for \\(v_\\mathrm{gs2}\\). \\[\nv_\\mathrm{gs2} =  v_\\mathrm{out} + v_\\mathrm{gs1}\n\\tag{60}\\]\nKCL at the tail node: \\[\ng_\\mathrm{m1}v_\\mathrm{gs1} + g_\\mathrm{m2}v_\\mathrm{gs2} + g_\\mathrm{ds2}v_\\mathrm{gs2} + g_\\mathrm{ds5}v_\\mathrm{gs2} = 0\n\\tag{61}\\]\nUsing Equation 60 to substitute \\(v_\\mathrm{gs2}\\) in {#eq-app-vbufzout-kcl-vtail-cl} we find an equation for \\(v_\\mathrm{gs1}\\). \\[\nv_\\mathrm{gs1} = -\\frac{g_\\mathrm{m2}+g_\\mathrm{ds2}}{g_\\mathrm{m1}+g_\\mathrm{m2}+g_\\mathrm{ds2}+g_\\mathrm{ds5}}v_\\mathrm{out}\n\\tag{62}\\]\nAgain, we derive the output conductance by plugging Equation 60, Equation 53 and Equation 62 step by step into Equation 59. First, we use Equation 60 to eliminate \\(v_\\mathrm{gs2}\\). \\[\ni_\\mathrm{out} -\\left(g_\\mathrm{ds4} + g_\\mathrm{ds2} + g_\\mathrm{m2}\\right)v_\\mathrm{out} - g_\\mathrm{m34}v_\\mathrm{gs34} - \\left(g_\\mathrm{ds2} + g_\\mathrm{m2}\\right)v_\\mathrm{gs1} = 0\n\\]\nSecond, Equation 53 also holds for the closed-loop case and lets us eliminate \\(v_\\mathrm{gs34}\\). \\[\ni_\\mathrm{out} -\\left(g_\\mathrm{ds4} + g_\\mathrm{ds2} + g_\\mathrm{m2}\\right)v_\\mathrm{out} - \\left(g_\\mathrm{ds2} + g_\\mathrm{m2} - g_\\mathrm{m1}\\right)v_\\mathrm{gs1} = 0\n\\]\nThird, we use Equation 62 to eliminate the remaining unknown \\(v_\\mathrm{gs1}\\). \\[\ni_\\mathrm{out} -\\left(g_\\mathrm{ds4} + g_\\mathrm{ds2} + g_\\mathrm{m2}\\right)v_\\mathrm{out} + \\left(g_\\mathrm{ds2} + g_\\mathrm{m2} - g_\\mathrm{m1}\\right)\\frac{g_\\mathrm{m2}+g_\\mathrm{ds2}}{g_\\mathrm{m1}+g_\\mathrm{m2}+g_\\mathrm{ds2}+g_\\mathrm{ds5}}v_\\mathrm{out} = 0\n\\]\nA more simpler result can be obtained, if we neglect \\(g_\\mathrm{ds2}\\) and \\(g_\\mathrm{ds5}\\) in Equation 62 first (\\(g_\\mathrm{m}\\gg g_\\mathrm{ds}\\)) and then plug it into our main equation. Additionally, we use \\(g_\\mathrm{m12}=g_\\mathrm{m1}=g_\\mathrm{m2}\\) to further simplify the equation. \\[\ni_\\mathrm{out} -\\left(g_\\mathrm{ds4} + \\frac{3}{2} g_\\mathrm{ds2} + g_\\mathrm{m12}\\right)v_\\mathrm{out} \\approx 0\n\\]\nIf we apply \\(g_\\mathrm{m}\\gg g_\\mathrm{ds}\\) again, we arrive at the same result which was used for the noise calculation in Section 8.3, compare the expression for \\(Y'_\\mathrm{load}\\) given by Equation 24 . \\[\ni_\\mathrm{out} -\\left(g_\\mathrm{m12}\\right)v_\\mathrm{out} \\approx 0\n\\]"
  },
  {
    "objectID": "analog_circuit_design.html#commands",
    "href": "analog_circuit_design.html#commands",
    "title": "Analog Circuit Design",
    "section": "20.1 Commands",
    "text": "20.1 Commands\n\nac dec|lin points fstart fstop performs a small-signal ac analysis with either linear or decade sweep\ndc sourcename vstart vstop vincr [src2 start2 stop2 incr2] runs a dc-sweep, optionally across two variables\ndisplay shows the available data vectors in the current plot\necho can be used to display text, $variable or $&vector, can be useful for debugging\nlet name = expr to create a new vector; unlet vector deletes a specified vector; access vector data with $&vec\nlinearize vec linearizes a vector on an equidistant time scale, do this before an FFT; with set specwindow=windowtype a proper windowing function can be set\nmeas can be used for various evaluations of measurement results (see ngspice manual for details)\nnoise v(output &lt;ref&gt;) src (dec|lin) pts fstart fstop runs a small-signal noise analysis\nop calculates the operating point, useful for checking bias points and device parameters\nplot expr vs scale to plot something\nprint expr to print it, use print all to print everything\nremzerovec can be useful to remove vectors with zero length, which otherwise cause issues when saving or plotting data\nrusage plot information about resource usage like memory\nsave all or save signal specifies which data is saved during simulation; this lowers RAM usage during simulation and size of RAW file; do save before the actual simulation statement\nsetplot show a list of available plots\nset var = value to set the value of a variable; use variable with $var; unset var removes a variable\nset enable_noisy_r to enable noise of behavioral resistors; usually, this is a good idea\nshell cmd to run a shell command\nshow : param, like show : gm shows the \\(g_\\mathrm{m}\\) of all devices after running an operating point with op\nspec plots a spectrum (i.e. frequency domain plot)\nstatus shows the saved parameters and nodes\ntf runs a transfer function analysis, returning transfer function, input and output resistance\ntran tstep tstop &lt;tstart &lt;tmax&gt;&gt; runs a transient analysis until tstop, reporting results with tstep step size, starting to plot at tstart and performs time steps not larger then tmax\nwrdata writes data into a file in a tabular ASCII format; easy to further process\nwrite writes simulation data (the saved nodes) into a RAW file; default is binary, can be changed to ASCII with set filetype=ascii; with set appendwrite data is added to an existing file"
  },
  {
    "objectID": "analog_circuit_design.html#options",
    "href": "analog_circuit_design.html#options",
    "title": "Analog Circuit Design",
    "section": "20.2 Options",
    "text": "20.2 Options\nUse option option=val option=val to set various options; important ones are:\n\nabstol sets the absolute current error tolerance (default is 1pA)\ngmin is the conductance applied at every node for convergence improvement (default is 1e-12); this can be critical for very high impedance circuits\nklu sets the KLU matrix solver\nlist print the summary listing of the input data\nmaxord sets the numerical order of the integration method (default is 2 for Gear)\nmethod set the numerical integration method to gear or trap (default is trap)\nnode prints the node table\nopts prints the option values\ntemp sets the simulation temperature\nreltol set the relative error tolerance (default is 0.001 = 0.1%)\nsavecurrents saves the terminal currents of all devices\nsparse sets the sparse matrix solver, which can run noise analysis, but is slower than klu\nvntol sets the absolute voltage error tolerance (default is 1µV)\nwarn enables the printing of the SOA warning messages"
  },
  {
    "objectID": "analog_circuit_design.html#convergence-helper",
    "href": "analog_circuit_design.html#convergence-helper",
    "title": "Analog Circuit Design",
    "section": "20.3 Convergence Helper",
    "text": "20.3 Convergence Helper\n\noption gmin can be used to increase the conductance applied at every node\noption method=gear can lead to improved convergence\n.nodeset can be used to specify initial node voltage guesses\n.ic can be used to set initial conditions"
  },
  {
    "objectID": "analog_circuit_design.html#prolog",
    "href": "analog_circuit_design.html#prolog",
    "title": "Analog Circuit Design",
    "section": "21.1 Prolog",
    "text": "21.1 Prolog\nA consistent naming and schematic drawing style, as well as VHDL/Verilog coding scheme, is a huge help in avoiding errors and increasing productivity. Even if just one person works on a design, the error rate is lowered. If multiple persons work together in a team, a consistent working style is a big help for smooth cooperation without misunderstanding each other’s intentions. Consistency also helps to reuse existing blocks. In a well-done design, the documentation is included in the schematic/source code, so there is no searching for a piece of documentation somewhere else (which is often not found anyway)."
  },
  {
    "objectID": "analog_circuit_design.html#pins",
    "href": "analog_circuit_design.html#pins",
    "title": "Analog Circuit Design",
    "section": "21.2 Pins",
    "text": "21.2 Pins\n\nName package pins (interfacing with the outside the IC) in UPPERCASE, and all internal signals in lowercase.\nSupply voltages like VDD/VCC and ground like VSS/GND need to start with either VDD, VCC, VSS, VEE or GND, plus a suitable suffix. Examples: VDD1, VDD_AMP, vdd_ldo_out, VSS_ANA (uppercase means connected to a pin, lowercase means a VDD is created on-chip by, e.g., an LDO).\nPreferred are VDD/VSS for CMOS and VCC/GND for bipolar circuits. In BiCMOS circuits VDD/VSS are preferred, as usually, the digital content is the major part.\nDigital signals in an analog schematic should start with di_ (for digital input) or do_ (for digital output). Example: di_ctrl1. In the rare case of a bi-directional digital signal dio_ can be used.\nName digital signals consistently: di_pon is active-high, di_pon_b is active-low (_b standing for the negating “bar”); as an alternative, this last signal could be named di_disable. di_reset is an active-high reset, but often a reset is active-low, so it needs to be named di_reset_b (an alternative is di_resetn).\nIn mixed-voltage designs, it might be useful to append the voltage level of a signal to avoid connecting incompatible inputs and outputs. Example: do_comp_1v2 or di_poweron_3v3.\nDigital buses always have the MSB to the left and LSB to the right. Example: do_adc[7:0].\nAnalog signals should start with a v for a voltage signal or i for a current signal. It is often useful to include a value for bias signals or make the naming meaningful. RF signals, which are often neither voltage nor current signals, start the name with rf_. Examples: Signal and pin names like ibias_30u (30uA of bias current), vbg_1v2 (a bandgap voltage of 1.2V), vin_p, v_filt_out_n, and rf_lna_i speak for themselves.\nAppending analog signals with _i and _o might be useful if a clear direction is obvious in the signal flow. If a signal is bi-directional, it is better to skip _io. If using _p or _n in combination with _i or _o then use _pi/_ni or _po/_no.\nConsistently use pin types input, output, or inout to indicate signal flow. Power supply pins are of inout type."
  },
  {
    "objectID": "analog_circuit_design.html#schematics",
    "href": "analog_circuit_design.html#schematics",
    "title": "Analog Circuit Design",
    "section": "21.3 Schematics",
    "text": "21.3 Schematics\n\nIn analog schematics, add a textual note about basic circuit performance. For example, in an amplifier, note things like suitable supply range, typical and w.c. current consumption, gain, GBW, input voltage range, PSRR, and other useful information.\nIf a circuit has a quirk or is particularly clever, add a note on how it works, so others can understand the function without excessive analysis (reviewing a circuit should not be a brain teaser).\nUse provided borders or drawing templates for schematics, and fill the data in, like circuit designer name, date, change history, project name, etc.\nUse a versioning system for your data, and check in often. This avoids data loss, and going back to an earlier design stage is simple. SVN is often preferable to GIT for binary data.\nDraw uncluttered clear circuits. Ideally, the circuit function is apparent by inspection quickly. Everyone can obscure an inverter so that it takes 5 minutes to recognize it, but this is not a good design.\nDon’t alter the standard grid setting while drawing schematics (also make sure that the pins in your drawn symbols are on the standard grid)! Off-grid schematic elements will haunt you and your colleagues forever!\nOnce a schematic is finished, take the time to name component instances properly (you can use speaking names like Rstab or simply use R1, R2, etc.). Use iterated instances to clean up the circuit. Use wire bundles to clean up circuits where useful. A clever technique is to use bundles and iterated instances to efficiently draw large resistor ladders, for example (however, use with care).\nAvoid connection-by-name, as it makes the circuit hard to read. However, there is a fine line to not cluttering circuits. Signals with many connections (vdd, vss, pon, pon_b) are often better done with connection-by-name instead of drawing a wire.\nSome tools allow the use of colored wires, which might be used to mark signal paths, bias lines, etc. However, this should not be overdone; use it with care.\nIf you add auxiliary elements like current probes, ensure they get proper treatment when creating the netlist for the LVS (some elements should be shorted, and some elements simply taken out). Ideally, only use a single schematic for simulation, LVS, etc. By using tool features this can usually be done, and avoids the need to keep multiple schematics of one block in sync.\nUse annotations in the schematics to (1) denote current levels in branches, (2) denote bias voltage levels, (3) explain the function of logic input signals, and (4) put in logic tables if not obvious.\nAdd comments concerning the layout, like matching devices, certain considerations of placement, sensitive nodes, etc.\nAdd simple ASCII diagrams for timing signals if useful.\nName internal signals (signals connected to pins are anyway named like the port) in a meaningful way; this makes tracking signals in simulation or layout much easier (automatic net names like net0032 are of not much help).\nProperly name instances, not just I1 or I2; better is amp1, inv2, etc. (a descriptor in a tool output like I1/I13/I5/net017 is not helpful; compare that to adc1/bias/bg/vref_int).\nOn check-and-save, never ignore warnings; just fix them! They will annoy you and others forever and might flag critical design flaws.\nName cells interpretably, ideally making the function clear already by the name. It is often useful to prefix or postfix a cell by the project name and design iteration. Example: In the project GIGAPROJECT, the cells which are changed in the second design step are prefixed with g2_, like g2_amp_bias. Of course, more letters as a project abbreviation are useful if a name collision is likely to happen.\nCell names in lowercase are a good choice, as otherwise, capitalization leads to inconsistency in cell names. Use _ to break words instead of CamelCase, like amp_bias_startup.\nWhen building a design, start with the hierarchy first; plan a suitable design structure, and define all interfaces. Implement simple behavioral models for every circuit block (either with controlled sources or using Verilog-A or VHDL/Verilog digital models). In this way, you can simulate the overall design early and find issues in the hierarchy or the interconnects. Then, populate the hierarchy with the detailed circuit designs in the leaf cells. At each point in the design process, you have a design that can be simulated, with some blocks as behavioral models and some blocks already designed. Try to avoid scattered circuit elements (digital or analog) in the hierarchy; it is better to push all components into the leaf cells.\nAvoid huge schematics, better break them down into smaller, maintainable, and self-contained blocks, and provide a simulation test bench for these simple blocks. In this way, later re-simulation across the hierarchy is easily possible.\nWhen building up the hierarchy, choose pin names and signal names as consistently as possible. Example: use the signal name vref_int when connecting two leaf cells with the pin names vref_int_o and vref_int_i.\nAvoid the excessive use of net breakers like small resistors, as they inhibit net tracing and can lead to simulation convergence issues. If a net breaker is needed (or a current should be probed) use a 0V dc voltage source."
  },
  {
    "objectID": "analog_circuit_design.html#symbols",
    "href": "analog_circuit_design.html#symbols",
    "title": "Analog Circuit Design",
    "section": "21.4 Symbols",
    "text": "21.4 Symbols\n\nSpend time drawing nice symbols! Ideally, the underlying circuit functionality is apparent by just looking at the symbol.\nArrange the pins in a meaningful way.\nGroup pins that belong together. An often useful arrangement is to locate the inputs on the left side, outputs on the right, digital control inputs at the bottom, and supplies at the top.\nMake the origin of a symbol in the top-left corner. In this way, symbols can be changed more easily, for example, by swapping out different versions of blocks.\nThe cell name (and potentially library name) should be visible in the symbol, not only in the properties."
  },
  {
    "objectID": "analog_circuit_design.html#design-robustness",
    "href": "analog_circuit_design.html#design-robustness",
    "title": "Analog Circuit Design",
    "section": "21.5 Design Robustness",
    "text": "21.5 Design Robustness\n\nIt is good practice to buffer incoming digital signals with a local inverter (connected to the local block supply) before connecting it to internal nodes. This improves the slew rate of the control signal and lowers the chance of unwanted cross-talk.\nConsider dummy elements for good matching, and try to make useful unit sizes of components. This will make the layout creation much smoother.\nThe golden rule of good analog performance is good matching, and good matching is achieved by identical components (size, orientation, surroundings)! If the layout does not look nice (humans like symmetry), it will not perform well.\nConsider supply decoupling and bias voltage decoupling inside the cells. Often, dummy elements can be used for that. Be aware, however, of unwanted supply resonances (think bond wire L and decoupling C) and slow transients of bias nodes after disturbance.\nAlways implement a proper power-down mode. Avoid floating nodes in off-mode. The better defined the on- as well as the off-mode are, the less the chance of leakage currents. Always simulate both modes (on and off), and also simulate a transient power-up of a circuit to identify issues with slow bias start or insufficient turn-off, or nasty feedback loop instabilities during transients.\nWhen drawing the first schematic, add parasitic capacitances to each node. If all nodes are labeled, a capacitor bank is easily put into one corner of the schematic with parasitic caps tied to the ground. Use 5fF as a starting value (and replace it later with the correct value from parasitic extraction). This accounts for some wiring parasitics in layout and helps to account for these layout impairments early in the design phase and later when simulating the schematic instead of the extracted netlist with parasitics."
  },
  {
    "objectID": "analog_circuit_design.html#rules-for-good-mixed-signal-and-rf-circuits",
    "href": "analog_circuit_design.html#rules-for-good-mixed-signal-and-rf-circuits",
    "title": "Analog Circuit Design",
    "section": "21.6 Rules for Good Mixed-Signal and RF Circuits",
    "text": "21.6 Rules for Good Mixed-Signal and RF Circuits\n\nSeparate analog and digital power supply, connect to package pins with multiple bond wires/bumps, and separate noisy and clean vdd/vss from each other!\nPrevent supply loops; keep vdd and vss lines close to each other (incl. bond wires and PCB traces)! This minimizes L and coupling factor k.\nSome prefer a massive (punched) ground plane, which is possible if you have enough metal levels. With a ground plane, the return path of a signal or supply line is just a few microns away.\nUse chip-internal decoupling capacitors, and decouple bias voltages to the correct potential (vdd or vss, or another node, depending on the circuit)!\nUse substrate contacts and guard rings to lower substrate crosstalk but use a quiet potential for connection; use triple-well if available! Connecting a guard-ring/substrate contact to a noisy supply is a prime noise injector (usually unwanted).\nPhysically separate quiet and noisy circuits (at least by the epi thickness)!\nReduce circuit noise generation as much as possible (avoid switching circuits if possible, use constant-current circuits instead, and use series/shunt regulators for supply isolation).\nReduce sensitivity of circuits to interference (by using a fully differential design with high PSRR/CMRR, symmetrical layout parasitics, and good matching)!"
  },
  {
    "objectID": "analog_circuit_design.html#vhdlverilog-coding-guide",
    "href": "analog_circuit_design.html#vhdlverilog-coding-guide",
    "title": "Analog Circuit Design",
    "section": "21.7 VHDL/Verilog Coding Guide",
    "text": "21.7 VHDL/Verilog Coding Guide\nThese recommendations are specifically targeted at Verilog; however, they apply similarly to VHDL.\n\nUse automatic checkers (linters) to see whether your code contains errors or vulnerabilities. Commercial or open-source tools allow this, e.g., Icarus Verilog (iverilog -g2005 -tnull FILE.v) or Verilator (verilator --lint-only -Wall FILE.v).\nWrite readable and maintainable code; use speaking variable names, and use a naming convention for inputs (ending with _i) and outputs (ending with _o). IO signals are using _io. Active-low signals have an n or b in their name (coming before the direction), like reset_ni. Use comments to explain the intention.\nWith a synchronous reset reset-related racing conditions are often avoided. If an asynchronous reset is desirable (which is often the case), ensure the reset signals are free from race conditions.\nModule-local registers and wires could append _w (for Verilog wire) or _r (for Verilog reg) to make their function clear. This is not required in SystemVerilog where the unified type logic should be used.\nUse an assign statement for logic as this often is easier to read than an always @(*) block. The ternary operator COND ? TRUE : FALSE can help with conditional assignments and is often a better choice than a (nested) if ... else statement.\nDeclare all outputs explicitly with either reg or wire.\nUse local parameter definitions with localparam in a module to make the code easier to follow. Name parameters in UPPERCASE.\nTake care to reset all registers to a defined state (in simulation and HW).\nUse the rule of “one file per module.” The filename shall match the module declaration.\nUse `default_nettype none at the beginning of a file containing a module definition. After the module you can use `default_nettype wire. This will add a safety net against typos in signal names.\nIn a logic assign block, use assign @(*) begin ... end instead of spelling out the signals in the sensitivity list. Forgetting a signal could lead to serious mismatches between simulation and HW.\nMake your code flexible by making bit widths and other values parameterized using a localparam or module parameter.\nBe cautious of implicit type conversions and bit-width adaptions; better make explicit conversions and match bit widths in assignments.\nUse only blocking assignments (=) in always @(*) blocks, and only non-blocking assignments (&lt;=) in clocked always @(posedge ...) blocks.\n\nA comprehensive coding style guide for Verilog/SystemVerilog can be found here, and it is highly recommended to follow it."
  },
  {
    "objectID": "analog_circuit_design.html#further-reading",
    "href": "analog_circuit_design.html#further-reading",
    "title": "Analog Circuit Design",
    "section": "21.8 Further Reading",
    "text": "21.8 Further Reading\n\nGood information about drawing schematics, design testbenches, etc: https://circuit-artists.com\nSutherland/Mills, Verilog and SystemVerilog Gotchas - 101 Common Coding Erorrs and How to Avoid Them, Springer, 2010\nB. Razavi, The Analog Mind, recurrent column in IEEE Solid-State Circuits Magazine"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analog Circuit Design",
    "section": "",
    "text": "Analog Circuit Design\n \n(c) 2024-2025 Harald Pretl and co-authors, Institute for Integrated Circuits and Quantum Computing (IICQC), Johannes Kepler University, Linz (JKU)\nThis is the material for an intermediate-level MOSFET circuit design course, held at JKU under course number 336.009 (“KV Analoge Schaltungstechnik”). Follow this link to access the material.\nThe course makes heavy use of circuit simulation, using Xschem for schematic entry and ngspice for simulation. The 130nm CMOS technology SG13G2 from IHP Microelectronics is used.\nTools and PDK are integrated in the IIC-OSIC-TOOLS Docker image, which will be used during the coursework.\nAll course material is made publicly available and shared under the Apache-2.0 license.\nWe happily accept pull requests to fix typos or add content! If you want to discuss something that is not clear, please open an issue!"
  },
  {
    "objectID": "sizing/lookup_sg13.html",
    "href": "sizing/lookup_sg13.html",
    "title": "MOSFET gm/ID Lookup for IHP SG13G2",
    "section": "",
    "text": "Copyright 2024 Boris Murmann and Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n\n\n# lookup a specific value\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS\ngm = lv_nmos.lookup('GM', L=0.13, VGS=0.9, VDS=0.75, VSB=0)\nprint(\"gm =\", round(float(gm/1e-3),3), 'mS')\nid = lv_nmos.lookup('ID', L=0.13, VGS=0.9, VDS=0.75, VSB=0)\nprint(\"Id =\", round(float(id/1e-3),3), \"mA\")\n\ngm = 3.581 mS\nId = 0.895 mA\n\n\n\n# query below uses minimum L, VDS=max(vgs)/2=0.9 and VSB=0 as defaults since they not specified\ngm = lv_nmos.lookup('GM', VGS=0.9)\nprint(\"gm =\", round(float(gm/1e-3),4), 'mS')\n\ngm = 3.581 mS\n\n\n\n# similar to above, but now we are looking up a ratio against another ratio\ngm_cgg = lv_nmos.lookup('GM_CGG', GM_ID=15)\nft = gm_cgg/2/np.pi\nprint(\"ft =\", round(float(ft/1e9), 1), \"GHz\")\n\nft = 9.9 GHz"
  },
  {
    "objectID": "sizing/techsweep_sg13_plots_triode.html",
    "href": "sizing/techsweep_sg13_plots_triode.html",
    "title": "MOSFET gm/ID Lookup for IHP SG13G2 in Triode Region",
    "section": "",
    "text": "Copyright 2024 Harald Pretl and Michael Koefinger\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\nfrom pygmid import Lookup as lk\nimport numpy as np\nimport matplotlib.pyplot as plt\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n\n\n# sweep source potential\nVS = np.arange(0.2,1.41,0.01)\n\n# NMOS lookup\nVG_n = 1.5\nVB_n = 0\nVSB_n = VS - VB_n\nVGS_n = VG_n - VS\ngds_n = lv_nmos.lookup('GDS', L=0.13, VGS=VGS_n, VDS=0.01, VSB=VSB_n)\n\n# PMOS lookup\nVG_p = 0\nVB_p = 1.5\nVSB_p = np.abs(VS - VB_p)\nVGS_p = np.abs(VG_p - VS)\ngds_p = lv_pmos.lookup('GDS', L=0.13, VGS=VGS_p, VDS=0.01, VSB=VSB_p)\n\n# calc Ron per width\nron_n = 1/np.diag(gds_n)\nron_p = 1/np.diag(gds_p)\nron_w_n = ron_n*lv_nmos['W']\nron_w_p = ron_p*lv_pmos['W']\nron_w_tg = 1/(1/ron_w_n+1/ron_w_p)\nron_w_tg_3 = 1/(1/ron_w_n+3/ron_w_p)\nron_w_tg_2_6 = 1/(2/ron_w_n+6/ron_w_p)\n\n\n# plot Ron versus source potential\n#| label: fig-triode-ron-vs-vsource-1\n#| fig-cap: $R_\\mathrm{on,n}$ and $R_\\mathrm{on,p}$ as a function of the source voltage ($V_\\mathrm{DS} = 10\\,\\text{mV}$).\nfig, ax1 = plt.subplots()\nax1.grid(axis='both')\nax1.set_xlabel(r'$V_\\mathrm{S}$ (V)')\nax1.set_ylabel(r'$R_\\mathrm{on}\\cdot W$ (k$\\Omega$ $\\cdot$ $\\mu$m)')\nax1.plot(VS, ron_w_n/1e3, color = 'tab:blue', label = \"NMOS\")\nax1.plot(VS, ron_w_p/1e3, color = 'tab:red', label = \"PMOS\")\nax1.legend(loc='center right')\nfig.tight_layout()\nplt.ylim(0,10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# plot Ron versus source potential\n#| label: fig-triode-ron-vs-vsource-2\n#| fig-cap: $R_\\mathrm{on,n}$, $R_\\mathrm{on,p}$ and $R_\\mathrm{on,n} \\parallel R_\\mathrm{on,p}$ as a function of the source voltage ($V_\\mathrm{DS} = 10\\,\\text{mV}$).\nfig, ax1 = plt.subplots()\nax1.grid(axis='both')\nax1.set_xlabel(r'$V_\\mathrm{S}$ (V)')\nax1.set_ylabel(r'$R_{on}\\cdot W$ (k$\\Omega$ $\\cdot$ $\\mu$m)')\nax1.plot(VS, ron_w_n/1e3, color = 'tab:blue', label = \"NMOS\")\nax1.plot(VS, ron_w_p/1e3, color = 'tab:red', label = \"PMOS\")\nax1.plot(VS, ron_w_tg/1e3, color = 'tab:green', label = \"TG, WP=WN\")\nax1.plot(VS, ron_w_tg_3/1e3, color = 'tab:orange', label = \"TG, WP=3WN\")\nax1.legend(loc='center right')\nfig.tight_layout()\nplt.ylim(0,10)\nplt.axvline(0.75, color = 'grey', linestyle = '--')\nplt.axhline(np.min(ron_w_n)/1e3, color = 'grey', linestyle = '--')\nplt.show()\n\n\n\n\n\n\n\n\n\n# sweep source potential\n#VS = np.arange(0.,1.5,0.01)\n\n# NMOS lookup\nVG_n = 0\nVB_n = 0\nVSB_n = VS - VB_n\nVGS_n = VG_n - VS\ncgs_n = lv_nmos.lookup('CGS', L=0.13, VGS=VGS_n, VDS=0.01, VSB=VSB_n)\ncgd_n = lv_nmos.lookup('CGD', L=0.13, VGS=VGS_n, VDS=0.01, VSB=VSB_n)\ncss_n = lv_nmos.lookup('CSS', L=0.13, VGS=VGS_n, VDS=0.01, VSB=VSB_n)\ncdd_n = lv_nmos.lookup('CDD', L=0.13, VGS=VGS_n, VDS=0.01, VSB=VSB_n)\n\n# PMOS lookup\nVG_p = 1.5\nVB_p = 1.5\nVSB_p = np.abs(VS - VB_p)\nVGS_p = np.abs(VG_p - VS)\ncgs_p = lv_nmos.lookup('CGS', L=0.13, VGS=VGS_p, VDS=0.01, VSB=VSB_p)\ncgd_p = lv_nmos.lookup('CGD', L=0.13, VGS=VGS_p, VDS=0.01, VSB=VSB_p)\ncss_p = lv_nmos.lookup('CSS', L=0.13, VGS=VGS_p, VDS=0.01, VSB=VSB_p)\ncdd_p = lv_nmos.lookup('CDD', L=0.13, VGS=VGS_p, VDS=0.01, VSB=VSB_p)\n\n#  calc Coff per width\n#  ---S---||---G---||---D---\n#     |                 |\n#    ---  CSS          --- CDD\n#    ---               ---\n#     |                 |\n#     B                 B\n\ncoff_n = 1/(1/np.diag(cgs_n)+1/np.diag(cgd_n))+1/(1/np.diag(css_n)+1/np.diag(cdd_n))\ncoff_p = 1/(1/np.diag(cgs_p)+1/np.diag(cgd_p))+1/(1/np.diag(css_p)+1/np.diag(cdd_p))\ncoff_w_n = coff_n/lv_nmos['W']\ncoff_w_p = coff_p/lv_pmos['W']\n\n\n# plot Coff versus source potential\n#| label: fig-triode-coff-vs-vsource\n#| fig-cap: $C_\\mathrm{off,n}$ and $C_\\mathrm{off,p}$ as a function of the source voltage ($V_\\mathrm{DS} = 10\\,\\text{mV}$).\nfig, ax1 = plt.subplots()\nax1.grid(axis='both')\nax1.set_xlabel(r'$V_\\mathrm{S}$ (V)')\nax1.set_ylabel(r'$C_\\mathrm{off} / W$ (fF/$\\mu$m)')\nax1.plot(VS, coff_w_n/1e-15, color = 'tab:blue', label = \"NMOS\")\nax1.plot(VS, coff_w_p/1e-15, color = 'tab:red', label = \"PMOS\")\nax1.legend(loc='center right')\nfig.tight_layout()\nplt.ylim(0.65,0.85)\nplt.show()\n\n\n\n\n\n\n\n\n\n# plot Ron*Coff versus source potential\n#| label: fig-triode-fom-vs-vsource\n#| fig-cap: $C_\\mathrm{off,n}$ and $C_\\mathrm{off,p}$ as a function of the source voltage ($V_\\mathrm{DS} = 10\\,\\text{mV}$).\nfig, ax1 = plt.subplots()\nax1.grid(axis='both')\nax1.set_xlabel(r'$V_\\mathrm{S}$ (V)')\nax1.set_ylabel(r'$\\text{FoM}=R_\\mathrm{on} \\cdot C_\\mathrm{off}$ (ps)')\nax1.plot(VS, ron_w_tg_3*(coff_w_n+coff_w_p)/1e-12, color = 'tab:blue', label = \"WP1=3WN1\")\nax1.plot(VS, ron_w_tg_2_6*(coff_w_n+coff_w_p)/1e-12, color = 'tab:red', label = \"WP2=3*2*WN1\")\nax1.legend(loc='upper right')\nfig.tight_layout()\nplt.show()"
  },
  {
    "objectID": "sizing/techsweep_sg13_plots_nmos.html",
    "href": "sizing/techsweep_sg13_plots_nmos.html",
    "title": "MOSFET gm/ID Evaluation Script for IHP SG13G2",
    "section": "",
    "text": "Copyright 2024 Boris Murmann and Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\nThis notebook displays various important metrics for the SG13G2 CMOS technology. The corresponding Xschem testbenches are named techsweep_sg13g2_lv_nmos.sch and techsweep_sg13g2_lv_pmos.sch (to be found in the xschem folder).\n\ndevices = ['sg13_lv_nmos', 'sg13_lv_pmos']\nchoice = 0 # select which device to plot, start from 0\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n# widths used for characterization\nw = np.array([5, 5])\n\n\n# read ngspice data\ndf_raw = pd.read_csv('./techsweep_'+devices[choice]+'.txt', sep=r'\\s+')\npar_names = df_raw.columns.to_list()\npar_prefix = par_names[1].split('[')[0]\n\n# remove extra headers in file body and unwanted columns\n#df_raw = df_raw[~df_raw['v-sweep'].str.contains('v-sweep')]\ndf = df_raw.drop(['frequency', 'frequency.1'], axis=1)\ndf = df.apply(pd.to_numeric)\n\n# rename columns for readability\ndf.columns = df.columns.str.removeprefix(par_prefix+'[')\ndf.columns = df.columns.str.replace(par_prefix[1:], '')\ndf.columns = df.columns.str.removesuffix(']')\n\n# round sweep vectors to easily addressable values\ndf['l'] = df['l'].apply(lambda x: round(x/1e-6, 3))\ndf['vgs'] = df['vgs'].apply(lambda x: round(x, 3))\ndf['vds'] = df['vds'].apply(lambda x: round(x, 3))\ndf['vsb'] = df['vsb'].apply(lambda x: round(x, 3))\n\nprint(df.columns)\n# Note on noise data: \n# 1.: sid, sfl are thermal and flicker noise current densities at 1 Hz in A^2/Hz from operating point data\n\nIndex(['cdd', 'cgb', 'cgd', 'cgdol', 'cgg', 'cgs', 'cgsol', 'cjd', 'cjs',\n       'css', 'fug', 'gds', 'gm', 'gmb', 'ids', 'l', 'rg', 'sfl', 'sid', 'vds',\n       'vdss', 'vgs', 'vsb', 'vth'],\n      dtype='object')\n\n\n\n# sweep variable vectors\nl = np.unique(abs(df['l']))\nvgs = np.unique(abs(df['vgs']))\nvds = np.unique(abs(df['vds']))\nvsb = np.unique(abs(df['vsb']))\n\n\n# plot gm/ID and fT versus gate bias\n#| label: fig-nmos-gmid-ft-vs-vgs\n#| fig-cap: $g_m/I_D$ and $f_T$ as a function of the gate-source voltage.\nL1 = min(l); VDS1=0.75; VSB1=0\ndf1 = df.loc[(df['l'] == L1) & (abs(df['vds']) == VDS1) & (abs(df['vsb']) == VSB1)]\ngm_id1 = df1['gm'].values/df1['ids'].values\ncgg1 = df1['cgg'].values + df1['cgdol'].values+df1['cgsol'].values \nft1 = df1['gm'].values/cgg1/2/np.pi\nft2 = df1['fug'].values\n\nfig, ax1 = plt.subplots()\nax1.grid(axis='x')\nax1.set_xlabel(r'$V_\\mathrm{GS}$ (V)')\ncolor = 'tab:blue'\nax1.set_ylabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)', color=color)\nax1.plot(vgs, gm_id1, color=color)\nax1.tick_params(axis='y', labelcolor=color)\nax2 = ax1.twinx()\ncolor = 'tab:red'\nax2.set_ylabel(r'$f_\\mathrm{T}$ (GHz)', color=color)\nax2.plot(vgs, ft1/1e9, color=color)\nax2.plot(vgs, ft2/1e9, color=color)\nax2.tick_params(axis='y', labelcolor=color)\nfig.tight_layout()\nplt.title(devices[choice]+', $L$='+str(L1)+r'µm, $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.xlim(0, 1.5)\nplt.axvline(x = df1['vth'].values[0], color='k', linestyle='--')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_gmID_fT_VGS.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\n\n# plot product of gm/ID and fT versus gm/ID\nfig, ax1 = plt.subplots()\nplt.plot(gm_id1, gm_id1*ft1/1e9)\nplt.xlim(2, 26)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{T} \\cdot g_\\mathrm{m}/I_\\mathrm{D}$ (GHz $\\cdot$ S/A)')\nplt.title(devices[choice]+', $L$='+str(L1)+r'µm, $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_fTgmID_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\n\n# plot fT versus gm/ID\n#| label: fig-nmos-ft-vs-gmid\n#| fig-cap: $f_T$ vs. $g_m/I_D$.\nplt.plot(gm_id1, ft1/1e9)\nplt.xlim(2, 26)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{T}$ (GHz)')\nplt.title(devices[choice]+', $L$='+str(L1)+r'µm, $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n# plot fT versus gm/ID for all L\n#| label: fig-nmos-ft-vs-gmid-vs-l\n#| fig-cap: $f_T$ vs. $g_m/I_D$ as a function of $L$.\nVDS2=0.75; VSB2=0\ndf2 = df.loc[(abs(df['vds']) == VDS2) & (abs(df['vsb']) == VSB2)]\ngm_id2 = df2['gm'].values/df2['ids'].values\ngm_id2 = np.reshape(gm_id2, (len(vgs), -1), order='F')\nft2 = df2['gm'].values/(df2['cgg'].values+df2['cgdol'].values+df2['cgsol'].values)/2/np.pi\nft2 = np.reshape(ft2, (len(vgs), -1), order='F')\n\nfig, ax = plt.subplots()\nax.plot(gm_id2, ft2/1e9)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{T}$ (GHz)')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_fT_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot gm/gds versus gm/ID for all L\n#| label: fig-nmos-gmgds-vs-gmid-vs-l\n#| fig-cap: $g_m/g_{ds}$ vs. $g_m/I_D$ as a function of $L$.\ngm_gds2 = df2['gm'].values/df2['gds'].values\ngm_gds2 = np.reshape(gm_gds2, (len(vgs), -1), order='F')\n\nfig, ax = plt.subplots()\nax.plot(gm_id2, gm_gds2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.ylim(0, 200)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$g_\\mathrm{m}/g_\\mathrm{ds}$ (V/V)')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.grid()\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_gmgds_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot Id/W (Jd) versus gm/ID for all L\n#| label: fig-nmos-jd-vs-gmid-vs-l\n#| fig-cap: $I_D/W$ vs. $g_m/I_D$ as a function of $L$.\njd2 = df2['ids'].values/w[choice]/1e-6\njd2 = np.reshape(jd2, (len(vgs), -1), order='F')\n\nfig, ax = plt.subplots()\nax.semilogy(gm_id2, jd2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nif choice == 0:\n    plt.ylim(1e-2, 1e3)\nelse:\n    plt.ylim(1e-2,1e3)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$I_\\mathrm{D}/W$ ($\\mu$A/$\\mu$m)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_IDW_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot Vdss versus gm/ID for all L\n#| label: fig-nmos-vdsat-vs-gmid-vs-l\n#| fig-cap: $V_{ds,sat}$ vs. $g_m/I_D$ as a function of $L$.\nvdss2 = df2['vdss']\nvdss2 = np.reshape(vdss2, (len(vgs), -1), order='F')\nfig, ax = plt.subplots()\nax.plot(gm_id2, vdss2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.ylim(0, 1)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$V_\\mathrm{ds,sat}$ (V)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_Vdssat_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot gamm versus gm/ID for all L\n#| label: fig-nmos-gamma-vs-gmid-vs-l\n#| fig-cap: $\\gamma$ vs. $g_m/I_D$ as a function of $L$.\nsid2 = df2['sid'].values\ngm2 = df2['gm'].values\nsid2 = np.reshape(sid2, (len(vgs), -1), order='F')\ngm2 = np.reshape(gm2, (len(vgs), -1), order='F')\ngamma2 = sid2/4/1.38e-23/300/gm2\n\nfig, ax = plt.subplots()\nax.plot(gm_id2, gamma2)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nif choice == 0:\n    plt.ylim(0.6,1.2)\nelse:\n    plt.ylim(1,2.5)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'Noise factor $\\gamma$ (1)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_gamma_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque.\n\n\n\n# plot fco versus gm/ID for all L\n#| label: fig-nmos-fco-vs-gmid-vs-l\n#| fig-cap: Flicker-noise corner frequency vs. $g_m/I_D$ as a function of $L$.\nsfl2 = df2['sfl'].values\nsfl2 = np.reshape(sfl2, (len(vgs), -1), order='F')\nfco = sfl2/sid2\nfig, ax = plt.subplots()\nax.semilogy(gm_id2, fco)\nax.legend(loc='center right', bbox_to_anchor=(1.2, 0.5), title='L (µm)', labels=l.tolist())\nplt.xlim(2, 26)\nplt.ylim(1e2, 1e8)\nplt.xlabel(r'$g_\\mathrm{m}/I_\\mathrm{D}$ (S/A)')\nplt.ylabel(r'$f_\\mathrm{co}$ (Hz)')\nplt.grid(which='minor')\nplt.grid(which='major')\nplt.title(devices[choice]+r', $V_\\mathrm{DS}$='+str(VDS1)+r'V, $V_\\mathrm{SB}$='+str(VSB1)+'V')\nplt.show()\nfig.savefig(\"techsweep_sg13_plots_nmos_overview/plots/NMOS_fco_gmID.eps\", bbox_inches='tight')\n\n\n\n\n\n\n\n\nThe PostScript backend does not support transparency; partially transparent artists will be rendered opaque."
  },
  {
    "objectID": "sizing/sizing_bandgap_simple.html",
    "href": "sizing/sizing_bandgap_simple.html",
    "title": "Sizing for Bandgap Reference",
    "section": "",
    "text": "Copyright 2025 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given values\nid_spec = 10e-6\ngm_id_spec = 20\nL_spec = 1\n\n\n# get the vgs for NMOS and PMOS\nvgsn = lv_nmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=0.75, VSB=0.8)\nvgsn = lv_nmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=vgsn, VSB=0.8)\n\nvgsp = lv_pmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=0.75, VSB=0.0)\nvgsp = lv_pmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=vgsp, VSB=0.0)\n\nprint('VGS of NMOS =', round(float(vgsn), 3), 'V')\nprint('VGS of PMOS =', round(float(vgsp), 3), 'V')\n\nVGS of NMOS = 0.356 V\nVGS of PMOS = 0.387 V\n\n\n\n# find the W of the transistors\nidn_w = lv_nmos.lookup('ID_W', GM_ID=gm_id_spec, L=L_spec, VDS=vgsn, VSB=0)\nwn = id_spec / idn_w\nprint('NMOS W =', round(wn, 2), 'um, rounded W =', round(wn*2)/2, 'um')\n\nidp_w = lv_pmos.lookup('ID_W', GM_ID=gm_id_spec, L=L_spec, VDS=vgsp, VSB=0)\nwp = id_spec / idp_w\nprint('PMOS W =', round(wp, 2), 'um, rounded W =', round(wp*2)/2, 'um')\n\nNMOS W = 14.45 um, rounded W = 14.5 um\nPMOS W = 51.9 um, rounded W = 52.0 um"
  },
  {
    "objectID": "sizing/sizing_basic_ota_w_circuit.html",
    "href": "sizing/sizing_basic_ota_w_circuit.html",
    "title": "Sizing for Basic 5T-OTA With Schematic",
    "section": "",
    "text": "Copyright 2024-2025 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\nimport schemdraw as sd\nimport schemdraw.elements as elm\nsd.svgconfig.svg2 = False\nwith sd.Drawing() as d:\n    d.config(unit=2)\n    d.config(fontsize=16)\n    \n    M1 = elm.AnalogNFet(offset_gate=False).drop('source').theta(0).label('$M_1$', ofst=-1.5).reverse()\n    elm.Line().down().length(0.5)\n    elm.Line().right().length(1.5).dot()\n    d.push()\n\n    elm.Line().down().length(0.5)\n    M5 = elm.AnalogNFet(offset_gate=False).anchor('drain').theta(0).label('$M_5$', ofst=-1.5).reverse()\n    elm.Ground()\n    elm.Line().left().length(4).at(M5.gate)\n    M6 = elm.AnalogNFet(offset_gate=False).anchor('gate').theta(0).label('$M_6$')\n    elm.Ground()\n    elm.Line().up().dot().at(M6.drain).length(0.5)\n    d.push()\n    elm.Line().up().length(1.5)\n    Ibias = elm.SourceI().up().label(r'$I_\\mathrm{bias}$').reverse()\n    elm.Vdd()\n    d.pop()\n    elm.Line().right().length(1.5)\n    elm.Line().down().toy(M6.gate).dot()\n\n    d.pop()\n    elm.Line().right().length(1.5)\n    elm.Line().up().length(0.5)\n    M2 = elm.AnalogNFet(offset_gate=False).anchor('source').theta(0).label('$M_2$')\n    \n    elm.Line().left().at(M1.gate).length(0.5).dot(open=True).label(r'$V_\\mathrm{in,p}$', 'left')\n    elm.Line().right().at(M2.gate).length(0.5).dot(open=True).label(r'$V_\\mathrm{in,n}$', 'right')\n    \n    elm.Line().up().at(M1.drain).length(0.5).dot()\n    d.push()\n    elm.Line().up().length(0.5)\n    M3 = elm.AnalogPFet(offset_gate=False).anchor('drain').theta(0).label('$M_3$')\n    elm.Vdd().at(M3.source)\n\n    elm.Line().up().at(M2.drain).length(0.5).dot()\n    d.push()\n    elm.Line().right().length(1.5).dot(open=True).label(r'$V_\\mathrm{out}$', 'right')\n    d.pop()\n    elm.Line().up().length(0.5)\n    M4 = elm.AnalogPFet(offset_gate=False).anchor('drain').theta(0).label('$M_4$', ofst=-1.5).reverse()\n    elm.Vdd().at(M4.source)\n\n    elm.Line().at(M4.gate).tox(M3.gate)\n    \n    d.pop()\n    elm.Line().right().tox(M5.drain)\n    elm.Line().up().toy(M3.gate).dot()\n\n\n\n\n\n\n\n\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given parameters as taken from the specification table or initial guesses\nc_load = 50e-15\ngm_id_m12 = 10\ngm_id_m34 = 5\ngm_id_m56 = 5\nl_12 = 5\nl_34 = 5\nl_56 = 5\nf_bw = 10e6 # -3dB bandwidth of the voltage buffer\ni_total_limit = 10e-6\ni_bias_in = 20e-6\noutput_voltage = 1.3\nvin_min = 0.7\nvin_max = 0.9\nvdd_min = 1.45\nvdd_max = 1.55\n\n\n# we get the required gm of M1/2 from the -3dB bandwidth requirement of the voltage buffer specification\n# note that the -3dB bandwidth of the voltage buffer with gain Av=1 is equal to the unity gain bandwidth\n# of the ota, hence we wet them equal here\n# we add a factor of 3 to allow for PVT variation plus additional MOSFET parasitic loading\ngm_m12 = f_bw * 3 * 4*np.pi*c_load\nprint('gm12 =', round(gm_m12/1e-3, 4), 'mS')\n\ngm12 = 0.0188 mS\n\n\n\n# since we know gm12 and the gmid we can calculate the bias current\nid_m12 = gm_m12 / gm_id_m12\ni_total = 2*id_m12\nprint('i_total (exact) =', round(i_total/1e-6, 1), 'µA')\n# we round to 0.5µA bias currents\ni_total = max(round(i_total / 1e-6 * 2) / 2 * 1e-6, 0.5e-6)\nid_m12 = i_total/2\n\nprint('i_total (rounded) =', i_total/1e-6, 'µA')\nif i_total &lt; i_total_limit:\n    print('[info] power consumption target is met!')\nelse:\n    print('[info] power consumption target is NOT met!') \n\ni_total (exact) = 3.8 µA\ni_total (rounded) = 4.0 µA\n[info] power consumption target is met!\n\n\n\n# we calculate the dc gain\ngm_gds_m12 = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_gds_m34 = lv_pmos.lookup('GM_GDS', GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0)\n\ngds_m12 = gm_m12 / gm_gds_m12\ngm_m34 = gm_id_m34 * i_total/2\ngds_m34 = gm_m34 / gm_gds_m34\n\na0 = gm_m12 / (gds_m12 + gds_m34)\nprint('a0 =', round(20*np.log10(a0), 1), 'dB')\n\na0 = 34.8 dB\n\n\n\n# we calculate the MOSFET capacitance which adds to Cload, to see the impact on the BW\ngm_cgs_m12 = lv_nmos.lookup('GM_CGS', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_cdd_m12 = lv_nmos.lookup('GM_CDD', GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0)\ngm_cdd_m34 = lv_pmos.lookup('GM_CDD', GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0)\n\nc_load_parasitic = abs(gm_m12/gm_cgs_m12) + abs(gm_m12/gm_cdd_m12) + abs(gm_m34/gm_cdd_m34)\nprint('additional load capacitance =', round(c_load_parasitic/1e-15, 1), 'fF')\n\nf_bw = gm_m12 / (4*np.pi * (c_load + c_load_parasitic))\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\n\nadditional load capacitance = 54.9 fF\nunity gain bandwidth incl. parasitics = 14.3 MHz\n\n\n\n# we can now look up the VGS of the MOSFET\nvgs_m12 = lv_nmos.look_upVGS(GM_ID=gm_id_m12, L=l_12, VDS=0.75, VSB=0.0)\nvgs_m34 = lv_pmos.look_upVGS(GM_ID=gm_id_m34, L=l_34, VDS=0.75, VSB=0.0) \nvgs_m56 = lv_nmos.look_upVGS(GM_ID=gm_id_m56, L=l_56, VDS=0.75, VSB=0.0) \n\nprint('vgs_12 =', round(float(vgs_m12), 3), 'V')\nprint('vgs_34 =', round(float(vgs_m34), 3), 'V')\nprint('vgs_56 =', round(float(vgs_m56), 3), 'V')\n\nvgs_12 = 0.367 V\nvgs_34 = 0.729 V\nvgs_56 = 0.591 V\n\n\n\n# calculate settling time due to slewing with the calculated bias current\nt_slew = (c_load + c_load_parasitic) * output_voltage / i_total\nprint('slewing time =', round(t_slew/1e-6, 3), 'µs')\nt_settle = 5/(2*np.pi*f_bw)\nprint('settling time =', round(t_settle/1e-6, 3), 'µs')\n\nslewing time = 0.034 µs\nsettling time = 0.056 µs\n\n\n\n# calculate voltage gain error\ngain_error = a0 / (1 + a0)\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\n\nvoltage gain error = -1.8 %\n\n\n\n# calculate total rms output noise\nsth_m12 = lv_nmos.lookup('STH_GM', VGS=vgs_m12, L=l_12, VDS=0.75, VSB=0) * gm_m12\ngamma_m12 = sth_m12/(4*1.38e-23*300*gm_m12)\n\nsth_m34 = lv_pmos.lookup('STH_GM', VGS=vgs_m34, L=l_34, VDS=0.75, VSB=0) * gm_m34\ngamma_m34 = sth_m34/(4*1.38e-23*300*gm_m34)\n\noutput_noise_rms = np.sqrt(1.38e-23*300 / (c_load + c_load_parasitic) * (2*gamma_m12 + 2*gamma_m34 * gm_m34/gm_m12))\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\n\noutput noise = 354.2 µVrms\n\n\n\n# calculate all widths\nid_w_m12 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m12, L=l_12, VDS=vgs_m12, VSB=0)\nw_12 = id_m12 / id_w_m12\nw_12_round = max(round(w_12*2)/2, 0.5)\nprint('M1/2 W =', round(w_12, 2), 'um, rounded W =', w_12_round, 'um')\n\nid_m34 = id_m12\nid_w_m34 = lv_pmos.lookup('ID_W', GM_ID=gm_id_m34, L=l_34, VDS=vgs_m34, VSB=0)\nw_34 = id_m34 / id_w_m34\nw_34_round = max(round(w_34*2)/2, 0.5) \nprint('M3/4 W =', round(w_34, 2), 'um, rounded W =', w_34_round, 'um')\n\nid_w_m5 = lv_nmos.lookup('ID_W', GM_ID=gm_id_m56, L=l_56, VDS=vgs_m56, VSB=0)\nw_5 = i_total / id_w_m5\nw_5_round = max(round(w_5*2)/2, 0.5)\nprint('M5 W =', round(w_5, 2), 'um, rounded W =', w_5_round, 'um')\nw_6 = w_5_round * i_bias_in / i_total\nw_6_round = max(round(w_6*2)/2, 0.5)\nprint('M6 W =', round(w_6_round, 2), 'um')\n\nM1/2 W = 1.77 um, rounded W = 2.0 um\nM3/4 W = 1.64 um, rounded W = 1.5 um\nM5 W = 0.74 um, rounded W = 0.5 um\nM6 W = 2.5 um\n\n\n\n# print out final design values\nprint('5T-OTA dimensioning:')\nprint('--------------------')\nprint('M1/2 W=', w_12_round, ', L=', l_12)\nprint('M3/4 W=', w_34_round, ', L=', l_34)\nprint('M5   W=', w_5_round, ', L=', l_56)\nprint('M6   W=', w_6_round, ', L=', l_56)\nprint()\nprint('5T-OTA performance summary:')\nprint('---------------------------')\nprint('supply current =', round(i_total/1e-6, 1), 'µA')\nprint('output noise =', round(output_noise_rms/1e-6, 1), 'µVrms')\nprint('voltage gain error =', round((gain_error-1)*100, 1), '%')\nprint('unity gain bandwidth incl. parasitics =', round(f_bw/1e6, 2), 'MHz')\nprint('turn-on time (slewing+settling) =', round((t_slew+t_settle)/1e-6, 3), 'µs')\nprint()\nprint('5T-OTA bias point check:')\nprint('------------------------')\nprint('headroom M1 =', round(vdd_min-vgs_m34+vgs_m12-vin_max, 3), 'V')\nprint('headroom M4 =', round(vdd_min-vin_max, 3), 'V')\nprint('headroom M5 =', round(vin_min-vgs_m12, 3), 'V')\n\n5T-OTA dimensioning:\n--------------------\nM1/2 W= 2.0 , L= 5\nM3/4 W= 1.5 , L= 5\nM5   W= 0.5 , L= 5\nM6   W= 2.5 , L= 5\n\n5T-OTA performance summary:\n---------------------------\nsupply current = 4.0 µA\noutput noise = 354.2 µVrms\nvoltage gain error = -1.8 %\nunity gain bandwidth incl. parasitics = 14.3 MHz\nturn-on time (slewing+settling) = 0.09 µs\n\n5T-OTA bias point check:\n------------------------\nheadroom M1 = 0.188 V\nheadroom M4 = 0.55 V\nheadroom M5 = 0.333 V\n\n\n\nimport schemdraw as sd\nimport schemdraw.elements as elm\nsd.svgconfig.svg2 = False\nwith sd.Drawing() as d:\n    d.config(unit=2)\n    d.config(fontsize=16)\n    \n    M1 = elm.AnalogNFet(offset_gate=False).drop('source').theta(0).label(str(w_12_round)+'/'+str(l_12), ofst=-2).reverse()\n    elm.Line().down().length(0.5)\n    elm.Line().right().length(1.5).dot()\n    d.push()\n\n    elm.Line().down().length(0.5)\n    M5 = elm.AnalogNFet(offset_gate=False).anchor('drain').theta(0).label(str(w_5_round)+'/'+str(l_56), ofst=-2).reverse()\n    elm.Ground()\n    elm.Line().left().length(4).at(M5.gate).label(str(round(float(vgs_m56),2))+'V')\n    M6 = elm.AnalogNFet(offset_gate=False).anchor('gate').theta(0).label(str(w_6_round)+'/'+str(l_56))\n    elm.Ground()\n    elm.Line().up().dot().at(M6.drain).length(0.5)\n    d.push()\n    elm.Line().up().length(1.5)\n    Ibias = elm.SourceI().up().label(str(round(i_bias_in/1e-6,0))+'µA').reverse()\n    elm.Vdd().label(str(vdd_min)+'V')\n    d.pop()\n    elm.Line().right().length(1.5)\n    elm.Line().down().toy(M6.gate).dot()\n\n    d.pop()\n    elm.Line().right().length(1.5)\n    elm.Line().up().length(0.5)\n    M2 = elm.AnalogNFet(offset_gate=False).anchor('source').theta(0).label(str(w_12_round)+'/'+str(l_12))\n    \n    elm.Line().left().at(M1.gate).length(0.5).dot(open=True).label(r'$V_\\mathrm{in,p}$', 'left')\n    elm.Line().right().at(M2.gate).length(0.5).dot(open=True).label(r'$V_\\mathrm{in,n}$', 'right')\n    \n    elm.Line().up().at(M1.drain).length(0.5).dot()\n    d.push()\n    elm.Line().up().length(0.5)\n    M3 = elm.AnalogPFet(offset_gate=False).anchor('drain').theta(0).label(str(w_34_round)+'/'+str(l_34))\n    elm.Vdd().at(M3.source).label(str(vdd_min)+'V')\n\n    elm.Line().up().at(M2.drain).length(0.5).dot()\n    d.push()\n    elm.Line().right().length(1.5).dot(open=True).label(r'$V_\\mathrm{out}$', 'right')\n    d.pop()\n    elm.Line().up().length(0.5)\n    M4 = elm.AnalogPFet(offset_gate=False).anchor('drain').theta(0).label(str(w_34_round)+'/'+str(l_34), ofst=-2).reverse()\n    elm.Vdd().at(M4.source).label(str(vdd_min)+'V')\n\n    elm.Line().at(M4.gate).tox(M3.gate).label(str(round(vdd_min-vgs_m34,2))+'V')\n    \n    d.pop()\n    elm.Line().right().tox(M5.drain)\n    elm.Line().up().toy(M3.gate).dot()"
  },
  {
    "objectID": "sizing/sizing_mosfet_diode.html",
    "href": "sizing/sizing_mosfet_diode.html",
    "title": "Sizing for MOSFET Diode Example",
    "section": "",
    "text": "Copyright 2024 Harald Pretl\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n\n# read table data\nfrom pygmid import Lookup as lk\nimport numpy as np\nlv_nmos = lk('sg13_lv_nmos.mat')\nlv_pmos = lk('sg13_lv_pmos.mat')\n# list of parameters: VGS, VDS, VSB, L, W, NFING, ID, VT, GM, GMB, GDS, CGG, CGB, CGD, CGS, CDD, CSS, STH, SFL\n# if not specified, minimum L, VDS=max(vgs)/2=0.9 and VSB=0 are used \n\n\n# define the given values\nid_spec = 20e-6\ngm_id_spec = 10\nL_spec = 0.13\n\n\n# we can calculate the gm directly\ngm = gm_id_spec * id_spec\nprint('gm =', round(gm/1e-3, 3), 'mS')\n\ngm = 0.2 mS\n\n\n\nvgs = lv_nmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=0.75, VSB=0.0)\nvgs = lv_nmos.look_upVGS(GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0.0)\n\n\n# the gm_gds we look up and calculate gds from it\ngm_gds = lv_nmos.lookup('GM_GDS', GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0)\ngds = gm / gm_gds\nprint('gds =', round(gds/1e-6, 2), 'uS')\n\ngds = 10.88 uS\n\n\n\n# find f_T (which is not stored directly, but we can find the gm to gate capacitance ratio)\ngm_cgg = lv_nmos.lookup('GM_CGG', GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0)\nf_T = gm_cgg / (2*np.pi)\nprint('Cgg =', round(gm/gm_cgg/1e-15, 1), 'fF')\nprint('f_T =', round(f_T/1e9, 1), 'GHz')\n\nCgg = 1.4 fF\nf_T = 23.0 GHz\n\n\n\n# find the W of the diode transistor\nid_w = lv_nmos.lookup('ID_W', GM_ID=gm_id_spec, L=L_spec, VDS=vgs, VSB=0)\nw = id_spec / id_w\nprint('W =', round(w, 2), 'um, rounded W =', round(w*2)/2, 'um')\n\nW = 0.86 um, rounded W = 1.0 um\n\n\n\n# let's now find the other interesting values\n# lookup normalized noise power spectral densisties and denormalize with the gm from above\nsth = lv_nmos.lookup('STH_GM', VGS=vgs, L=L_spec, VDS=vgs, VSB=0)*gm\nsfl = lv_nmos.lookup('SFL_GM', VGS=vgs, L=L_spec, VDS=vgs, VSB=0)*gm\n\ngamma = sth/(4*1.38e-23*300*gm)\n\nf_co = sfl/sth\nprint('V_GS =', round(float(vgs), 3), 'V')\nprint('gamma =', round(gamma, 2))\nprint('f_co =', round(f_co/1e6, 2), 'MHz')\n\nV_GS = 0.591 V\ngamma = 0.81\nf_co = 15.84 MHz"
  }
]